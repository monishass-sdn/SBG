//AuthorName:CHITRA V
//File:Schedule Controller.js
//Module:Manage Schedule
//Created Date:11.05.2021
//Purpose:To Manage Schedule

/***************************************************Import Packages and ViewModels Section******************************** */
const Schedule = require('../models/ScheduleModel')
const Boats=require('../models/AddBoatModel')
const manageBoat=require('../models/ManageOwnerModel')
const OwnerPartialCancelation = require('../models/Ownerpartialcancelations');
const mongoose = require("mongoose")
const moment  = require('moment');
const async = require('async');
const consecutive = require('../models/ConsecutiveDaysModel');
const PreLaunchAndLaunchBookingDays=require('../models/BookingDaysForLaunchPreLaunchModels')
const OwnerBooking_Days=require('../models/OwnerBookingDates');
const AddStandByBooking=require('../models/AddStandByBookingModel')
var loginData = require('../EmailCredentials');
const { gmail: { host, pass } } = loginData;
const nodemailer = require('nodemailer')
const Add_Special_Days= require('../models/AddSpecialDaysModel')
const Booking_Special_Days= require('../models/SpecialDayBookingModel')
const NewOwners = require('../models/AddOwnerModel');
const log1 = require('../models/LoginModel');
const Duration = require("../models/OwnershipDuration");
const {getDaysBetweenDatesYearFirst,getDaysBetweenDates,getNumberOfWeekDaysAndWeekendsFromDates,getBookingIsFromWhichSeasonBasedOnStartDate,getCurrentTimeFormatted,getDaysBetweenDatesFormat} = require("../util/dateHelper");
const No_OfCleans=require('../models/NumberOfCleansModel');
const partialCancel=require('../models/PartialCancellationModel');
const TotalNoCancellations=require('../models/NumberOfCancellation');
const nextBookinDayModel = require('../models/NextBookingModel');
const schedule  = require('node-schedule');
const tzOffset = require("tz-offset");
const cronModel = require('../models/CronModel');
const {validateIsLOAInclued} = require("../validations/scheduleValidations");
const OwnerStandByCancelModel = require("../models/OwnerStandByCancelModel");
const transporter = require('../email/transporter');
const getEmailTemplate = require('../email/emailTemplate');
const {cancelrues,cancelStandbyrules} = require('./cancelrules');
const { response } = require('express');

//const Bookeddays=require('../models/BookedDaysForOwner');
/***************************************************Import Methods and Functions******************************** */
// Function for Add AdminBooking
async function GetNextBookingID(){
 
    try {
        //  Schedule.find().count( async function(err, count){    
        const [result]  =await Schedule.find({}, null, { sort: { Booking_ID:-1 }, limit: 1 })
        if(result && result.Booking_ID)
       {
     
        return result.Booking_ID + 1; 
       }
       
    return 1001;
} 
    



catch (err) { 
    return 'error occured';
 }

  }





  const AddSchedule=async (req, res, next)=>{
     
    try{

  var ccccc=moment(req.body.start).format('MMM DD h:mm A');
   const globalbookingid=await GetNextBookingID();
   var check_Status=req.body.Check_Status;
   var Total_Count=Number(req.body.TotalDay_Count);
   var WeekDay_Count=Number(req.body.WeekDay_Count);
   var WeekEnd_Count= Number(req.body.WeekEnd_Count);
   var User_role=req.body.User_RoleType;
   var Boat_id=req.body.Boat_Id;
   var Owner_id=req.body.User_Id;
   var start_Date=req.body.start;
   var Noofcleans=1;
 var PendingSummerWeekdays= Number(req.body.summer_Winter_Calc.PENDING_SUMMER_WEEKDAYS);
 var PendingSummerWeekEnddays= Number(req.body.summer_Winter_Calc.PENDING_SUMMER_WEEKENDS);
 var PendingWinterWeekdays= Number(req.body.summer_Winter_Calc.PENDING_WINTER_WEEKDAYS);
 var PendingWinterWeekenddays= Number(req.body.summer_Winter_Calc.PENDING_WINTER_WEEKENDS);

  
 
   //var specialDayCheck=0;//special day
   var specialDayCheck=req.body.specialDayCheck;//special day
   var end_Date=req.body.end;

   /* Check Onwr duration */
   if(User_role == "Owner"){

    let ownerdurationCheck = await Duration.findOne({Boat_Id: Boat_id,Owner_Id:Owner_id}).catch((error) => console.log(error));
    if(!ownerdurationCheck || ownerdurationCheck==null){

        return res.json({
            status:false,
            message: 'Please set Ownership duration'
         });

    }else{ console.log("gg");

        let enddateDuration = new Date(ownerdurationCheck.To_Date);

        let userEnddate = new Date(end_Date);

        if(enddateDuration.getTime()< userEnddate.getTime()){

            return res.json({
                status:false,
                message: 'Your Ownership Duration Ended'
             });
        }
        

    }
  
/* check boat is suspended */
let suspendcheck = await manageBoat.findOne({Boat_Id: Boat_id,Owner_Id:Owner_id}).catch((error) => console.log(error));

if(suspendcheck.Block == false)
return res.json({
 status:false,
 message: 'Suspended'
})

 

  
   }

  




var TodaysDate= moment();
var CurrentDate=moment(TodaysDate).format('DD-MM-YYYY');


//var start_Date_NoTime=new Date(start_Date);
//console.log(start_Date_NoTime.toString(),'hi');
var Start_final=moment(start_Date);
console.log(Start_final,'checkkk1')
var Start_final_withoutTime=Start_final.startOf('day');

// var end_Date_NoTime=new Date(end_Date);
var End_final=moment(end_Date);
var End_final_withoutTime=End_final.startOf('day');

var dif=Start_final.diff(moment(),'days')
console.log("Diff::"+dif)

   if(req.body.Status=="Enable")
   {

       var  Module_status = 1;
   }
   else if (req.body.Status=="Disable")
   {
       var Module_status = 0;
    }

    //get month
    const Getmonth = new Date(Start_final);
    LaunchPreMonth=Getmonth.toLocaleString('default', { month: 'long' });
    //getmonth

    //check if any of the incoming dates already booked

    let allDaysBetweenStartAndEndOfIncomingBooking = getDaysBetweenDates(start_Date,end_Date);

    

        if(allDaysBetweenStartAndEndOfIncomingBooking.length!=0){

            let queryToCheckExistingBooking = []  
    
            allDaysBetweenStartAndEndOfIncomingBooking.map((date)=> queryToCheckExistingBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))
        
            const existingNormalBooking = await Schedule.findOne({IsActive:true,isBookingPending:false,Boat_Id:Boat_id,$or:queryToCheckExistingBooking})
        
            if(existingNormalBooking){
                return res.json({
                   status:true,
                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                })
            }
        

        }
        
    
    ///////////////////////////////////////////////////////////////////////////////////////


    //check if booking is from launch prelaunch if it is then check consecutive days 

   const boatData = await Boats.findOne({_id:Boat_id,IsActive:true},{SummerSeason_SDate:1,SummerSeason_EDate:1,Launch_Date:1}).catch((error)=> console.log(error));
   if(!boatData) return res.json({status:false,message:"Invalid boat."});

   if(User_role != 'Admin' && User_role != 'Maintenance' )

    await checkPrelaunchLaunchConsecutiveDays(boatData.Launch_Date,req.body.start,req.body.end,Boat_id,Owner_id)
   

   //////////////////////////////////////////////////////////////////////////////////////////////////////////

   //check if incomig booking has any stand by booking before incoming booking for this owner

   let dayBeforeIncomingBooking = new Date(new Date(new Date(start_Date).setDate(new Date(start_Date).getDate() -1)).setUTCHours(00,00,00,00));

   console.log(dayBeforeIncomingBooking)

   let standByBooking = await AddStandByBooking.findOne({Boat_Id:Boat_id,User_Id:Owner_id,BookingStatus:null,$and:[{start_NoTime:{$lte:dayBeforeIncomingBooking}},{end_NoTime:{$gte:dayBeforeIncomingBooking}}]}).catch((error)=> console.log(error))


   if(standByBooking){

       console.log("standby booking before this booking found")

      // check consecutive days and if the booking exceeds consecutive day throw an error

       //decide booking is from summer or winter
  
      
       if(!boatData) return res.json({status:false,message:"Invalid boat."});
  
       const consecutiveDays = await consecutive.findOne({Boat_Id:Boat_id,IsActive:true}).catch((error)=> console.log(error))
  
       if(!consecutiveDays) return res.json({status:false,message:"Set consecutive days."})

  
       //total days booked
  
       let incomingTotalDays = moment(new Date(req.body.end)).diff(moment(new Date(req.body.start)),"days") + 1;
       incomingTotalDays +=  moment(new Date(standByBooking.end_NoTime)).diff(moment(new Date(standByBooking.start_NoTime)),"days") + 1


       //check if there is a booking before standby booking if include that days to total day

       let dayBeforeStandByBooking = new Date(new Date(new Date(standByBooking.start).setDate(new Date(standByBooking.start).getDate() -1)).setUTCHours(00,00,00,00));

       let bookingBeforeStandByBooking = await Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:true,$and:[{start_NoTime:{$lte:dayBeforeStandByBooking}},{end_NoTime:{$gte:dayBeforeStandByBooking}}]}).catch((error)=> console.log(error))

       if(bookingBeforeStandByBooking){
           incomingTotalDays +=  moment(new Date(bookingBeforeStandByBooking.end_NoTime)).diff(moment(new Date(bookingBeforeStandByBooking.start_NoTime)),"days") + 1
       }
  
       console.log(incomingTotalDays,"incomingTotalDays one")
  
      
     let {isIncludedInSummer} = getBookingIsFromWhichSeasonBasedOnStartDate(boatData.SummerSeason_SDate,boatData.SummerSeason_EDate,req.body.start) || {} ;
       

  
         if(isIncludedInSummer){
     if(incomingTotalDays > consecutiveDays.Summer_ConsecutiveDays) return res.json({status:false,message:"The booking exceeds the maximum booking duration. Please try to create a booking with fewer days."});
  }else{
    if(incomingTotalDays > consecutiveDays.Winter_ConsecutiveDays) return res.json({status:false,message:"The booking exceeds the maximum booking duration. Please try to create a booking with fewer days."});
  }

   }

   //check if the booking is a canceled stand by booking by incoming owner


   let allDaysBetweenStartAndEnd = getDaysBetweenDates(req.body.start,req.body.end)

   if(allDaysBetweenStartAndEnd.length!=0){


    let queryToCheckCanceledStandByBooking = []  
      
    allDaysBetweenStartAndEnd.map((date)=> queryToCheckCanceledStandByBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))

  let isCanceledStandByBooking = await OwnerStandByCancelModel.findOne({Boat_Id:Boat_id,User_Id:Owner_id,$or:queryToCheckCanceledStandByBooking}).catch((error)=>{
          console.log(error)
})

if(isCanceledStandByBooking) return res.json({status:true,message:"You are trying to book a canceled stand by booking ."})


   }

    
  
  NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
  .then(OwnerDetails=> {
        
   if(!OwnerDetails) OwnerDetails = {}
  
    Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
       .then(boatDetails=> {

        let bookingType = getBookingTypeofAbooking(req.body.start,req.body.end,boatDetails.PreLaunch_Date,boatDetails.Launch_Date,boatDetails.SummerSeason_SDate,boatDetails.SummerSeason_EDate,boatDetails.WinterSeason_SDate,boatDetails.WinterSeason_EDate);
        

    if(boatDetails.Boat_Status=="1")//check whether boat is Active or not
    {
        //between Launch And PreLuanch

        if(check_Status=="1" && specialDayCheck==0)
        { 

           console.log("Inside launch prelaunch")

          

            console.log(dif,'diffff')
            if(dif>=0)
            {
          
           Schedule.find({Boat_Id:Boat_id,IsActive:true,User_Id:Owner_id,Check_Status:check_Status,Check_Month:LaunchPreMonth}).then(Checkresult=>
               {
                   console.log(Checkresult.length,'length')
                   var _LengthCheck=Checkresult.length;
                   
                   // _LengthCheck==0       
                   
                   console.log(Checkresult)
               
                   

            console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh') 
           PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id}).then(bookingDays=> {

               // if already a booking check available week days and weekends
                       
            //    if(Checkresult.length){

            //        let alreadyBookedDays = []

            //     for(const bookedDay of Checkresult){

            //        alreadyBookedDays = alreadyBookedDays.concat(getDaysBetweenDates(bookedDay.start,bookedDay.end))

                  
            //     }

               

            //   let {numberOfWeekDays,numberOfWeekEnds} =  getNumberOfWeekDaysAndWeekendsFromDates(alreadyBookedDays);

            //     let totalAllowedBookingDays = bookingDays.Booking_Days - numberOfWeekDays - numberOfWeekEnds
            //     let totalAllowedWeekDays = bookingDays.No_Of_WeekDays - numberOfWeekDays
            //     let toatlAllowedWeekends = bookingDays.No_Of_WeekEndDays - numberOfWeekEnds

            //     console.log(totalAllowedBookingDays)
            //     console.log(totalAllowedWeekDays)
            //     console.log(toatlAllowedWeekends)


            //     if(Total_Count > totalAllowedBookingDays){
            //         return res.json({ status:true, message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date' })
            //     }

            //     if(WeekDay_Count > totalAllowedWeekDays || WeekEnd_Count > toatlAllowedWeekends){
            //         return res.json({status:true,message:"Number of weekdays or number of weekends exceeded the limit."})
            //     }


            //    }

               // if already a booking check available week days and weekends end

                  
                  var b_days=bookingDays.Booking_Days;
                  var WeekdaysAllowed=bookingDays.No_Of_WeekDays;
                  var WeekEndsAllowed=bookingDays.No_Of_WeekEndDays;
                  console.log(b_days)
                  console.log(Total_Count)

                  ////  Commeneted Raga 3-10-21
           /* if(Total_Count<=b_days)
            {*/
               // if(WeekDay_Count<=WeekdaysAllowed && WeekEnd_Count<=WeekEndsAllowed )
                //{
           console.log('PreLanuch Condition')
       
           
             Schedule.find({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                 {
                   
                     console.log(result.length,'length')
                     var _Length=result.length;
                    if(_Length==0)
                    {
                        Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                            {
                                if(result2==null)
                            {
                        console.log('hi1')
                        Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                            {
                            if(results==null)
                            {
                               console.log('hi2')
                                Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                    {
                   
                                    if(results==null)
                                    {
                                       console.log('hi3')    
                                 
//Add 
console.log('Admin')
let Add_Schedule = new Schedule({ 
                                       
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final_withoutTime,
end_NoTime:End_final_withoutTime,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
Is_StandByBooking:req.body.Is_StandByBooking,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
color:req.body.color,
bgColor:req.body.bgColor,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state,
Check_Status:req.body.Check_Status, 
commends:req.body.commends,
Check_Month:LaunchPreMonth,
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:0,
WeekDay_Count_Reassign:0,
WeekEnd_Count_Reassign:0,
Booking_Type:bookingType

});

Add_Schedule.save()
.then(async (response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
   //mail

   const emailState =  'Successfully Booked.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Booking Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }

   
   var mailOptions = {
      
       from:"noreply.smartboatbooking@gmail.com",
       to: OwnerDetails.Email,
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                            
   };
   
   transporter.sendMail(mailOptions, function (error, info) {
      
   });           
   
   var mailOptionsAdmin = {
      
       from:"noreply.smartboatbooking@gmail.com",
        to: "admin@smartboating.com.au",
        subject: 'Successfully Booked',
        html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
   };
   
   transporter.sendMail(mailOptionsAdmin, function (error, info) {
   
      
       
   }); 
   //mail

res.json({
  
status:true,
message: 'The booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
res.json({
message: "Something went wrong while booking. try again."
})
})

}
else
{
res.json({

status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}



})
//Add
}
else
{
res.json({

status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}   }) 
                    }
                    else
                    {
                        res.json({

                            status:true,
                            message: 'An existing booking already exists for this date. A new booking cannot be created.'
                        })
                    }
                })
                    }
                    else
                    {
                        res.json({

                            status:true,
                            message: 'An existing booking already exists for this date. A new booking cannot be created.'
                        })
                    }
})
               // }
               /* else
                {

                   res.json({

                       status:true,
                       message: 'Only '  +WeekdaysAllowed +' WeekDays and ' +WeekEndsAllowed  +' WeekendDays are allowed Between launch Date And Pre-Launch Date'
                   })
                }*/ ///  commented Raga 30-10-21
        //}
       /* else
        {
           res.json({

               status:true,
               message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date'
           })
        }*///// commented Raga 30-10-21
       })
   
   
})
            }
            else
            {
               console.log('inside between Launch And PreLuanch' )
               res.json({
                   status:false,
                   message: 'A booking cannot be created for a previous day'
               })

            }
           
        }

        //between Launch And PreLaunch


        //After Launch before current date

        if(check_Status=="2" && specialDayCheck==0)
        {
           if(dif>=0)
           {

               Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                   {

                       if(Cancelresults==null)
                       {
                    

           Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
               {
                                      
                   console.log(result.length,'length')
                   var _Length=result.length;
                  if(_Length==0)
                   {
                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                           {
                               if(result2==null)
                           {
                              
                           Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                               {
                               if(results==null)
                               {

                              Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                       {
                                       if(results==null)
                                       {
                                   
                          

                       Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                           {  
                               var SummerWeekdays=response.Summer_WeekDays;
                               var SummerWeekendDays=response.Summer_WeekEndDays;
                               var  WinterWeekDays=response.Winter_WeekDays;
                               var WinterweekendDays=response.Winter_WeekEndDays;

                               //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                               
                               Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>{
                                   console.log(Boatresults)

                                 
                      //list all summer start and end date of  owne  based on owner duration  duration which include all year
              let stopExecution = {stop:false}
             let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                       console.log(error)
                       stopExecution = error
                   })


                   if(stopExecution.stop){
                       return res.json({status:true,message:stopExecution.error})
                   }

             
                                      
                               if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                               {

                                       //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return

                                                                     
                                   consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                   .then(element=> 
                                       
                                       {
                                           if(element!=null)
                                           {

                                           

                                           if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                           {

                                        
if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count)//count of weekday and week end
{

// for updating Summer days
Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
{   
                         
Summer_WeekDays:SummerWeekdays-WeekDay_Count,
Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count

},
{new: true},
function(err, data) {


});

var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
console.log(x)

        


//Add Summer Section

let Add_Schedule = new Schedule({ 
                        

                   
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final,
end_NoTime:End_final,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
Is_StandByBooking:req.body.Is_StandByBooking,
Check_Status:req.body.Check_Status,
commends:req.body.commends,
color:req.body.color,
bgColor:req.body.bgColor,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state, 
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
//mail

const emailState =  'Successfully Booked.';
const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Booking Details'
const emailDetails = [
  { key: 'Boat Name', value:  boatDetails.Boat_Name},
  { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
  name:'Booking Link',
  link:`${process.env.CLIENT_URL}/boat-bookings`
}

var mailOptions = {
  
   from:"noreply.smartboatbooking@gmail.com",
   to: OwnerDetails.Email,
   subject: 'Successfully Booked',
   html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                      
   
   
};

transporter.sendMail(mailOptions, function (error, info) {
  
});           

var mailOptionsAdmin = {
  
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Successfully Booked',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail

res.json({
status:true,
message: 'The booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
   res.json({
       status:false,
   message: "Something went wrong while booking. try again."
   })

})                              }//weekday,weekend
                           else
                               {

                                res.json({
                               status:false,
                                message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                         })


                                }
                       }
                       else
                       {

                           res.json({
                               status:false,
                               message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                           })


                       }
                   }
                   else
                   {
                       res.json({
                           status:false,
                           message: 'Consecutive days for this boat is Empty'
                       })

                   }
                       })
                   
                           }
                       

               
                               else
                               {
                                   //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                   Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=> {

                     //list all winter start and end date of  owne  based on owner duration  duration which include all year

                     let stopExecution = {stop:false}
                     let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                       console.log(error)
                       stopExecution = error
                   })

                   if(stopExecution.stop){
                       return res.json({status:true,message:stopExecution.error})
                   }
                             

                 
                                   if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                   {
                                      
                                    //check if next booking included

                                    let isNextDaysError = false
                                    let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id).catch((error)=>{
                                         isNextDaysError = true
                                         return res.json(error)
                                    })

                                    
                                     if(isNextDaysError) return
                               
                                   consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                   .then(element=> 
                                       
                                       {
                                           if(element!=null)
                                           {

                                   if(element.Winter_ConsecutiveDays>=Total_Count)
                                   {
                                
                                       if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                       {
                                       
                                            // for updating Summer days
                                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                            {   
                                                                             
                                               Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                               Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                
                                            },
                                            {new: true},
                                            function(err, data) {
                                                
                                                
                                            });
                                       
                                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                            console.log(x)
                                            
//Add Winter Section

let Add_Schedule = new Schedule({ 
                        
                     
                   
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final,
end_NoTime:End_final,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
Is_StandByBooking:req.body.Is_StandByBooking,
Check_Status:req.body.Check_Status,
commends:req.body.commends,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
color:req.body.color,
bgColor:req.body.bgColor,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state, 
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
//mail

const emailState =  'Successfully Booked.';
const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Booking Details'
const emailDetails = [
  { key: 'Boat Name', value:  boatDetails.Boat_Name},
  { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
  name:'Booking Link',
  link:`${process.env.CLIENT_URL}/boat-bookings`
}


var mailOptions = {
  
   from:"noreply.smartboatbooking@gmail.com",
   to: OwnerDetails.Email,
   subject: 'Successfully Booked',
   html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptions, function (error, info) {
  
});           

var mailOptionsAdmin = {
  
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Successfully Booked',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail

res.json({

status:true,
message: 'The booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
res.json({
message: "Something went wrong while booking. try again."
})
})

                                       }//weekday weekend count
                                       else{

                                           res.json({
                                               status:false,
                                                message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                   })
   
   
                                                
                                       }
//Add Winter Section
}
                                 
else
{

res.json({
status:false,
message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
})

}
                                           }
                                           else
                                           {
                                             res.json({
                                                   status:false,
                                                   message: 'Consecutive days for this boat is Empty'
                                               })
                                           }
})                                     }
                             else
                             {
                               res.json({
                                   status:false,
                                   message: 'These dates are not allowed for booking '
                                   //because you are trying to book a date that is not included in the winter or summer of this boat after launch and before the current date.'
                               })
                             }
                           })
                           }//else


                               
                           });
                       })
                   }
                   else
                   {
                       res.json({
                           status:false,
                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                       })
                   }
                                     
                       })
                       }
                       else
                       {

                           res.json({
                               status:false,
                               message: 'An existing booking already exists for this date. A new booking cannot be created.'
                           })

                       }

                   })
               }
               else
               {
                   res.json({
                       status:false,
                       message: 'An existing booking already exists for this date. A new booking cannot be created.'
                   })

               }
       
            
               });//else inside function owner


           }
           else
           {
               res.json({
                   status:false,
                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
               })
           }

           });

       }
       else
       {
 
           console.log(Start_final_withoutTime)
           console.log(End_final_withoutTime)
           console.log(Cancelresults.Updated_time,'thissssssssss')
           var todaysdate=moment();
           console.log(todaysdate)
           var canceldate =moment(Cancelresults.Updated_time)
           var dif=moment.duration(todaysdate.diff(canceldate));
           console.log(dif.asHours());
           var Hrdif=Math.round(dif.asHours());
       
           console.log(Hrdif);


           if(Hrdif>24)

           {
              
               Schedule.find({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                   {
                                          
                       console.log(result.length,'length')
                       var _Length=result.length;
                      if(_Length==0)
                       {
                           Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                   if(result2==null)
                               {
                                  
                               Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                   {
                                   if(results==null)
                                   {
   
                                  Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                           {
                                           if(results==null)
                                           {
                                       
                              
   
                           Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                               {  
                                   var SummerWeekdays=response.Summer_WeekDays;
                                   var SummerWeekendDays=response.Summer_WeekEndDays;
                                   var  WinterWeekDays=response.Winter_WeekDays;
                                   var WinterweekendDays=response.Winter_WeekEndDays;

                                   //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                   
                                   Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                       {
                                      
                                           let stopExecution = {stop:false}
                                           let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                               console.log(error)
                                                stopExecution = error
                                           })
                                          

                                           if(stopExecution.stop){
                                               return res.json({status:true,message:stopExecution.error})
                                           }

                                           if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                   {

                                //check if next booking included

                                let isNextDaysError = false
                                let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id).catch((error)=>{
                                     isNextDaysError = true
                                     return res.json(error)
                                })

                                
                                 if(isNextDaysError) return
   
                                                                         
                                       consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                       .then(element=> 
                                           
                                           {
                                               if(element!=null)
                                               {
   
                                               
   
                                               if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                               {
   
                                            
   if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
   {
   
   // for updating Summer days
   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
   {   
                             
   Summer_WeekDays:SummerWeekdays-WeekDay_Count,
   Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
   },
   {new: true},
   function(err, data) {
   
   
   });
   
   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
   console.log(x)
   
            
   
   
   //Add Summer Section
   
   let Add_Schedule = new Schedule({ 
                            
                         
                       
   Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
   Booking_ID:globalbookingid,
   Boat_Name:req.body.Boat_Name,
   Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
   calendarId:mongoose.Types.ObjectId(req.body.calendarId),
   title:req.body.title,
   body:req.body.body,
   start:req.body.start,
   end:req.body.end,
   start_NoTime:Start_final,
   end_NoTime:End_final,
   goingDuration:req.body.goingDuration,
   comingDuration:req.body.comingDuration,
   isAllDay:req.body.isAllDay,
   category:req.body.category,
   dueDateClass:req.body.dueDateClass,
   location:req.body.location,
   attendees:req.body.attendees,
   recurrenceRule:req.body.recurrenceRule,
   isPending:req.body.isPending,
   isFocused:req.body.isFocused,
   isVisible:req.body.isVisible,
   isReadOnly:req.body.isReadOnly,
   isPrivate:req.body.isPrivate,
   Is_StandByBooking:req.body.Is_StandByBooking,
   Check_Status:req.body.Check_Status,
   commends:req.body.commends,
   color:req.body.color,
   bgColor:req.body.bgColor,
   dragBgColor:req.body.dragBgColor,
   borderColor:req.body.borderColor,
   customStyle:req.body.customStyle,
   raw:req.body.raw,
   state:req.body.state, 
   User_RoleType:req.body.User_RoleType,
   User_Id:mongoose.Types.ObjectId(req.body.User_Id),
   Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
   Status:Module_status,
   IsActive: req.body.IsActive,
   Current_Time:moment(Date.now()),
   Updated_time: moment(Date.now()),
   Total_DaysBooked_Reassign:Total_Count,
   WeekDay_Count_Reassign:WeekDay_Count,
   WeekEnd_Count_Reassign: WeekEnd_Count,
   Booking_Type:bookingType,
   isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
   
   });
   
   Add_Schedule.save()
   .then(async(response) => {
       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
   res.json({
   
   status:true,
   message: 'The booking has been successfully created'
   })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })                              }//weekday,weekend
                               else
                                   {
   
                                    res.json({
                                   status:false,
                                    message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                             })
   
   
                                    }
                           }
                           else
                           {
   
                               res.json({
                                   status:false,
                                   message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                               })
   
   
                           }
                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'Consecutive days for this boat is Empty'
                           })
   
                       }
                           })
                       
                               }
                           
   
                   
                                   else
                                   {

                                       //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                       Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                           {
                                          console.log(BoatresultsWinter);

                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                                           console.log(error)
                                           stopExecution = error
                                       })


                                       if(stopExecution.stop){
                                           return res.json({status:true,message:stopExecution.error})
                                       }

                                     if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                       {
                                          
                                            //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                       
                                   
                                       consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                       .then(element=> 
                                           
                                           {
                                               if(element!=null)
                                               {
   
                                       if(element.Winter_ConsecutiveDays>=Total_Count)
                                       {
                                    
                                           if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                           {
                                           
                                                // for updating Summer days
                                                Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                {   
                                                                                 
                                                   Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                   Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                    
                                                },
                                                {new: true},
                                                function(err, data) {
                                                    
                                                    
                                                });
                                           
                                                var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                console.log(x)
                                                
   //Add Winter Section
   
   let Add_Schedule = new Schedule({ 
                            
                         
                       
   Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
   Booking_ID:globalbookingid,
   Boat_Name:req.body.Boat_Name,
   Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
   calendarId:mongoose.Types.ObjectId(req.body.calendarId),
   title:req.body.title,
   body:req.body.body,
   start:req.body.start,
   end:req.body.end,
   start_NoTime:Start_final,
   end_NoTime:End_final,
   goingDuration:req.body.goingDuration,
   comingDuration:req.body.comingDuration,
   isAllDay:req.body.isAllDay,
   category:req.body.category,
   dueDateClass:req.body.dueDateClass,
   location:req.body.location,
   attendees:req.body.attendees,
   recurrenceRule:req.body.recurrenceRule,
   isPending:req.body.isPending,
   isFocused:req.body.isFocused,
   Is_StandByBooking:req.body.Is_StandByBooking,
   Check_Status:req.body.Check_Status,
   commends:req.body.commends,
   isVisible:req.body.isVisible,
   isReadOnly:req.body.isReadOnly,
   isPrivate:req.body.isPrivate,
   color:req.body.color,
   bgColor:req.body.bgColor,
   dragBgColor:req.body.dragBgColor,
   borderColor:req.body.borderColor,
   customStyle:req.body.customStyle,
   raw:req.body.raw,
   state:req.body.state, 
   User_RoleType:req.body.User_RoleType,
   User_Id:mongoose.Types.ObjectId(req.body.User_Id),
   Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
   Status:Module_status,
   IsActive: req.body.IsActive,
   Current_Time:moment(Date.now()),
   Updated_time: moment(Date.now()),
   Total_DaysBooked_Reassign:Total_Count,
   WeekDay_Count_Reassign:WeekDay_Count,
   WeekEnd_Count_Reassign: WeekEnd_Count,
   Booking_Type:bookingType,
   isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
   
   });
   
   Add_Schedule.save()
   .then(async(response) => {

       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
   res.json({
   
   status:true,
   message: 'The booking has been successfully created'
   })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })
   
                                           }//weekday weekend count
                                           else{
   
                                               res.json({
                                                   status:false,
                                                    message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                       })
       
       
                                                    
                                           }
   //Add Winter Section
   }
                                     
   else
   {
   
   res.json({
   status:false,
   message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
   })
   
   }
                                               }
                                               else
                                               {
                                                 res.json({
                                                       status:false,
                                                       message: 'Consecutive days for this boat is Empty'
                                                   })
                                               }
   })                                     }
                                 else
                                 {
                                   res.json({
                                       status:false,
                                       message: 'These dates are not allowed for booking .'
                                       //because you are trying to book a date that is not included in the winter or summer of this boat after launch and before the current date.!'
                                   })
                                 }
                               })
                               }//else
   
   
                                   
                               });
                           })
                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'An existing booking already exists for this date. A new booking cannot be created.'
                           })
                       }
                                         
                           })
                           }
                           else
                           {
   
                               res.json({
                                   status:false,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })
   
                           }
   
                       })
                   }
                   else
                   {
                       res.json({
                           status:false,
                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                       })
   
                   }
           
                
                   });//else inside function owner
   
   
               }
               else
               {
                   res.json({
                       status:false,
                       message: 'An existing booking already exists for this date. A new booking cannot be created.'
                   })
               }
   
               });
           }
              else
              {
                   res.json({
                   status:false,
                   message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
               })
              } 

       }
   })

       }
       else
       {
           res.json({
               status:false,
               message: 'A booking cannot be created for a previous day'
           }) 
       }
        }
        


       //after launch
       if(check_Status=="3" && specialDayCheck==0)
       {
         
                       if(dif>=0)//for Previous Date
                       {  
                          
                          if(User_role=='Admin')//for Admin
                          {
                            Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                                {
                                  
                                    console.log(result.length,'length')
                                    var _Length=result.length;
                                   if(_Length==0)
                                   {
                                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                           {
                                               if(result2==null)
                                           {
                                       
                                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                           {
                                           if(results==null)
                                           {
                                               Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                                   {
                                                   if(results==null)
                                                   {
                                                   
                                                
//Add 
console.log('Admin')
let Add_Schedule = new Schedule({ 
                                    
                   
                               
   Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
   Booking_ID:globalbookingid,
   Boat_Name:req.body.Boat_Name,
   Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
   WeekEnd_Count: WeekEnd_Count,
   calendarId:mongoose.Types.ObjectId(req.body.calendarId),
   title:req.body.title,
   body:req.body.body,
   start:req.body.start,
    end:req.body.end,
    start_NoTime:Start_final_withoutTime,
    end_NoTime:End_final_withoutTime,
    goingDuration:req.body.goingDuration,
    comingDuration:req.body.comingDuration,
    isAllDay:req.body.isAllDay,
    category:req.body.category,
    dueDateClass:req.body.dueDateClass,
    location:req.body.location,
    attendees:req.body.attendees,
    recurrenceRule:req.body.recurrenceRule,
    isPending:req.body.isPending,
    isFocused:req.body.isFocused,
    isVisible:req.body.isVisible,
    isReadOnly:req.body.isReadOnly,
    isPrivate:req.body.isPrivate,
    color:req.body.color,
    bgColor:req.body.bgColor,
    Is_StandByBooking:req.body.Is_StandByBooking,
    Check_Status:req.body.Check_Status,
    commends:req.body.commends,
    dragBgColor:req.body.dragBgColor,
    borderColor:req.body.borderColor,
    customStyle:req.body.customStyle,
    raw:req.body.raw,
    state:req.body.state, 
    User_RoleType:req.body.User_RoleType,
    User_Id:mongoose.Types.ObjectId(req.body.User_Id),
    Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
    Status:Module_status,
    IsActive: req.body.IsActive,
    Current_Time:moment(Date.now()),
    Updated_time: moment(Date.now()),
    Total_DaysBooked_Reassign:Total_Count,
    WeekDay_Count_Reassign:WeekDay_Count,
   WeekEnd_Count_Reassign: WeekEnd_Count,
   Booking_Type:bookingType

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
//mail
const emailState =  'Successfully Booked.';
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Booking Details'
const emailDetails = [
 { key: 'Boat Name', value:  boatDetails.Boat_Name},
 { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
 name:'Booking Link',
 link:`${process.env.CLIENT_URL}/boat-bookings`
}
         

var mailOptionsAdmin = {
  
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Successfully Booked',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail

    res.json({
        
        status:true,
        message: 'The admin booking has been successfully created'
    })
})
.catch(error => {
   console.log(error,"error")
   res.json({
       status:false,
   message: "Something went wrong while booking. try again."
   })
})
     
}
else
{
   res.json({
           
       status:true,
       message: 'An existing booking already exists for this date. A new booking cannot be created.'
   })

}



})
//Add
}
else
{
   res.json({
           
       status:true,
       message: 'An existing booking already exists for this date. A new booking cannot be created.'
   })

}   }) 
                                   }
                                   else
                                   {
                                       res.json({
           
                                           status:true,
                                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                       })
                                   }
                               })
                                   }
                                   else
                                   {
                                       res.json({
           
                                           status:true,
                                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                       })
                                   }
})
}

                       else//For Owner
                       {
                           Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                               {

                                   if(Cancelresults==null)
                                   {

                              
console.log(Cancelresults,'cancellation rewsulttttt')
                              
                  
                          
                         Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                                                  
                               console.log(result.length,'length')
                               var _Length=result.length;
                              if(_Length==0)
                               {
                                   Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true,isBookingPending:false}).then(result2=>
                                       {
                                           if(result2==null)
                                       {
                                          
                                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true,isBookingPending:false}).then(results=>
                                           {
                                           if(results==null)
                                           {

                                          Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                                   {
                                                   if(results==null)
                                                   {
                          
                                      

                                   Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                       {  
                                           var SummerWeekdays=response.Summer_WeekDays;
                                           var SummerWeekendDays=response.Summer_WeekEndDays;
                                           var  WinterWeekDays=response.Winter_WeekDays;
                                           var WinterweekendDays=response.Winter_WeekEndDays;

                                           //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                           
                                           Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                               {
                                               console.log(Boatresults)
                                               let stopExecution = {stop:false}
                                       let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                   console.log(error)
                                                    stopExecution = error
                                               })

                                               if(stopExecution.stop){
                                                   return res.json({status:true,message:stopExecution.error})
                                               }

                                           if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                           {


                                                //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                                                                 
                                               consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                               .then(element=> 
                                                   
                                                   {
                                                       if(element!=null)
                                                       {

                                                       
           
                                                       if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                       {
           
                                                    
if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
{

    // for updating Summer days
    Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
    {   
                                     
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
        
    },
    {new: true},
    function(err, data) {
        
        
    });
    

   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
   console.log(x)
   
    //update Summer
                    


//Add Summer Section

let Add_Schedule = new Schedule({ 
                                    
                                 
                               
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      WeekDay_Count:WeekDay_Count,
   WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final,
       end_NoTime:End_final,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
//mail

const emailState =  'Successfully Booked.';
const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Booking Details'
const emailDetails = [
  { key: 'Boat Name', value:  boatDetails.Boat_Name},
  { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
  name:'Booking Link',
  link:`${process.env.CLIENT_URL}/boat-bookings`
}

var mailOptions = {
  
   from:"noreply.smartboatbooking@gmail.com",
   to: OwnerDetails.Email,
  
   subject: 'Successfully Booked',
   html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                      
   
   
};

transporter.sendMail(mailOptions, function (error, info) {
  
});           

var mailOptionsAdmin = {
  
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Successfully Booked',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail


       res.json({
           
           status:true,
           message: 'The booking has been successfully created'
       })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })                              }//weekday,weekend
                                       else
                                           {

                                            res.json({
                                           status:false,
                                            message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                     })


                                            }
                                   }
                                   else
                                   {

                                       res.json({
                                           status:false,
                                           message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                       })


                                   }
                               }
                               else
                               {
                                   res.json({
                                       status:false,
                                       message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                   })

                               }
                                   })
                               
                                       }
                                   

                           
                                           else
                                           {
                                               //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}
                                               Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                   {
                                                  console.log(BoatresultsWinter);
                                                  let stopExecution = {stop:false}
                                                  let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                   console.log(error)
                                                    stopExecution = error
                                               })

                                               

                                               if(stopExecution.stop){
                                                   return res.json({status:true,message:stopExecution.error})
                                               }

                                               

                                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                               {
                                                  
                                                 //check if next booking included

                                                   let isNextDaysError = false
                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id).catch((error)=>{
                                                   isNextDaysError = true
                                                   return res.json(error)
                                              })

                                              
                                               if(isNextDaysError) return
                                           
                                               consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                               .then(element=> 
                                                   
                                                   {
                                                       if(element!=null)
                                                       {

                                               if(element.Winter_ConsecutiveDays>=Total_Count)
                                               {
                                            
                                                   if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                   {
                                                   
                                                        // for updating Summer days
                                                        Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                        {   
                                                                                         
                                                           Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                           Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                            
                                                        },
                                                        {new: true},
                                                        function(err, data) {
                                                            
                                                            
                                                        });
                                                   

                                                        var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                        console.log(x)
                                                      
//Add Winter Section

let Add_Schedule = new Schedule({ 
                                    
                                 
                               
   Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
   Booking_ID:globalbookingid,
   Boat_Name:req.body.Boat_Name,
   Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final,
       end_NoTime:End_final,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       color:req.body.color,
       bgColor:req.body.bgColor,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
//mail
const emailState =  'Successfully Booked.';
const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Booking Details'
const emailDetails = [
  { key: 'Boat Name', value:  boatDetails.Boat_Name},
  { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
  name:'Booking Link',
  link:`${process.env.CLIENT_URL}/boat-bookings`
}

var mailOptions = {
  
   from:"noreply.smartboatbooking@gmail.com",
   to: OwnerDetails.Email,
   //to: "bjibin3@gmail.com",
   subject: 'Successfully Booked',
   html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                      
   
   
};

transporter.sendMail(mailOptions, function (error, info) {
  
});           

var mailOptionsAdmin = {
  
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Successfully Booked',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail

       res.json({
           
           status:true,
           message: 'The booking has been successfully created'
       })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })

                                                   }//weekday weekend count
                                                   else{

                                                       res.json({
                                                           status:false,
                                                            message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                               })
               
               
                                                            
                                                   }
//Add Winter Section
}
                                             
else
{

   res.json({
       status:false,
       message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
   })

}
                                                       }
                                                       else
                                                       {
                                                         res.json({
                                                               status:false,
                                                               message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                           })
                                                       }
})                                     }
                                         else
                                         {
                                           res.json({
                                               status:false,
                                               message: 'These dates are not allowed for booking '
                                               //because you are trying to book a date that is not included in the winter or summer of this after launch period .'
                                           })
                                         }
                                       })
                                       }//else


                                           
                                       });
                                   })
                               }
                               else
                               {
                                   res.json({
                                       status:false,
                                       message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                   })
                               }
                                                 
                                   })
                                   }
                                   else
                                   {

                                       res.json({
                                           status:false,
                                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                       })

                                   }

                               })
                           }
                           else
                           {
                               res.json({
                                   status:false,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })

                           }
                   
                        
                           });//else inside function owner


                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'An existing booking already exists for this date. A new booking cannot be created.'
                           })
                       }

                       });
                   }
                   else
                   {

                       //
                   
                   console.log(Start_final_withoutTime)
                   console.log(End_final_withoutTime)
                   console.log(Cancelresults.Updated_time,'thissssssssss')
                   var todaysdate=moment();
                   console.log(todaysdate)
                   var canceldate =moment(Cancelresults.Updated_time)
                   var dif=moment.duration(todaysdate.diff(canceldate));
                   console.log(dif.asHours());
                   var Hrdif=Math.round(dif.asHours());
               
                   console.log(Hrdif);


                   if(Hrdif>24)

                   {
                       Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                                                  
                               console.log(result.length,'length')
                               var _Length=result.length;
                              if(_Length==0)
                               {
                                   Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                       {
                                           if(result2==null)
                                       {
                                          
                                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                           {
                                           if(results==null)
                                           {

                                          Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                                   {
                                                   if(results==null)
                                                   {
                          
                                      

                                   Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                       {  
                                           var SummerWeekdays=response.Summer_WeekDays;
                                           var SummerWeekendDays=response.Summer_WeekEndDays;
                                           var  WinterWeekDays=response.Winter_WeekDays;
                                           var WinterweekendDays=response.Winter_WeekEndDays;

                                           //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                           
                                           Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                               {
                                                   let stopExecution = {stop:false}
                                                   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                       console.log(error)
                                                        stopExecution = error
                                                   })
                                                  

                                                   if(stopExecution.stop){
                                                       return res.json({status:true,message:stopExecution.error})
                                                   }

                                                   if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                           {

                                                //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                                                                 
                                               consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                               .then(element=> 
                                                   
                                                   {
                                                       if(element!=null)
                                                       {

                                                       
           
                                                       if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                       {
           
                                                    
if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
{

    // for updating Summer days
    Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
    {   
                                     
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
        
    },
    {new: true},
    function(err, data) {
        
        
    });
    

   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
   console.log(x)
  
    //update Summer
                    


//Add Summer Section

let Add_Schedule = new Schedule({ 
                                    
                                 
                               
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final,
       end_NoTime:End_final,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
       res.json({
           
           status:true,
           message: 'The booking has been successfully created'
       })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })                              }//weekday,weekend
                                       else
                                           {

                                            res.json({
                                           status:false,
                                            message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                     })


                                            }
                                   }
                                   else
                                   {

                                       res.json({
                                           status:false,
                                           message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                       })


                                   }
                               }
                               else
                               {
                                   res.json({
                                       status:false,
                                       message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                   })

                               }
                                   })
                               
                                       }
                                   

                           
                                           else
                                           {
                                              // WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}
                                               Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                   {
                                                  console.log(BoatresultsWinter);
                                                  let stopExecution = {stop:false}
                                                  let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                   console.log(error)
                                                    stopExecution = error
                                               })


                                               if(stopExecution.stop){
                                                   return res.json({status:true,message:stopExecution.error})
                                               }

                           if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                               {
                                                  
                                                    //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                               
                                           
                                               consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                               .then(element=> 
                                                   
                                                   {
                                                       if(element!=null)
                                                       {

                                               if(element.Winter_ConsecutiveDays>=Total_Count)
                                               {
                                            
                                                   if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                   {
                                                   
                                                        // for updating Summer days
                                                        Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                        {   
                                                                                         
                                                           Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                           Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                            
                                                        },
                                                        {new: true},
                                                        function(err, data) {
                                                            
                                                            
                                                        });
                                                   

                                                        var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                        console.log(x)
                                                      
//Add Winter Section

let Add_Schedule = new Schedule({ 
                                    
                                 
                               
   Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
   Booking_ID:globalbookingid,
   Boat_Name:req.body.Boat_Name,
   Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final,
       end_NoTime:End_final,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       color:req.body.color,
       bgColor:req.body.bgColor,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {

       let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
           console.log(error)  
           console.log(isCleanDay)  
       })
       res.json({
           
           status:true,
           message: 'The booking has been successfully created'
       })
   })
   .catch(error => {
       console.log(error,"error")
       res.json({
           status:false,
       message: "Something went wrong while booking. try again."
       })
   })

                                                   }//weekday weekend count
                                                   else{

                                                       res.json({
                                                           status:false,
                                                            message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                               })
               
               
                                                            
                                                   }
//Add Winter Section
}
                                             
else
{

   res.json({
       status:false,
       message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
   })

}
                                                       }
                                                       else
                                                       {
                                                         res.json({
                                                               status:false,
                                                               message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                           })
                                                       }
})                                     }
                                         else
                                         {
                                           res.json({
                                               status:false,
                                               message: 'These dates are not allowed for booking '
                                               //because you are trying to book a date that is not included in the winter or summer of this boat after launch period . !'
                                           })
                                         }
                                       })
                                       }//else


                                           
                                       });
                                   })
                               }
                               else
                               {
                                   res.json({
                                       status:false,
                                       message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                   })
                               }
                                                 
                                   })
                                   }
                                   else
                                   {

                                       res.json({
                                           status:false,
                                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                       })

                                   }

                               })
                           }
                           else
                           {
                               res.json({
                                   status:false,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })

                           }
                   
                        
                           });//else inside function owner


                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'An existing booking already exists for this date. A new booking cannot be created.'
                           })
                       }

                       });

                   }
                      else
                      {
                           res.json({
                           status:false,
                           message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                       })
                      } //

                       // res.json({
                       //     status:false,
                       //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                       // })

                   }
               })
                       }

                       }
                                       
                       else {
                           res.json({
                               status:false,
                               message: 'A booking cannot be created for a previous day'
                           })
                       } 
                       
                   }

             if(check_Status="4" && User_role=="Maintenance" )
             {
               if(dif>=0)//for Previous Date
               { 

               Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                   {
                     
                       console.log(result.length,'length')
                       var _Length=result.length;
                      if(_Length==0)
                      {
                          Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                              {
                                  if(result2==null)
                              {
                          
                          Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                              {
                              if(results==null)
                              {
                                  Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                      {
                                      if(results==null)
                                      {
                                      
                                   
//Add 
console.log('Admin')
let Add_Schedule = new Schedule({ 
                       
      
                  
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final_withoutTime,
end_NoTime:Start_final_withoutTime,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
color:req.body.color,
Is_StandByBooking:req.body.Is_StandByBooking,
Check_Status:req.body.Check_Status,
commends:req.body.commends,
bgColor:req.body.bgColor,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state, 
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
//mail

const emailState =  'Successfully Booked.';
const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully created a boat maintainance on  on ${getCurrentTimeFormatted()}`
const emailDetailName = 'Maintenance Details'
const emailDetails = [
  { key: 'Boat Name', value:  boatDetails.Boat_Name},
  { key: 'Booking Date', value: getCurrentTimeFormatted() },
];
const emailNameAndLink = {
  name:'Booking Link',
  link:`${process.env.CLIENT_URL}/boat-bookings`
}


       

var mailOptionsAdmin = {   
   from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Maintainance Booking',
    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

  
   
}); 
//mail


res.json({

status:true,
message: 'The boat maintenance booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
res.json({
message: "Something went wrong while booking. try again."
})
})

}
else
{
res.json({

status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}



})
//Add
}
else
{
res.json({

status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}   }) 
                      }
                      else
                      {
                          res.json({

                              status:true,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
                  })
                      }
                      else
                      {
                          res.json({

                              status:true,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
})
               }
               else
               {
                   res.json({
                       status:false,
                       message: 'A booking cannot be created for a previous day'
                   })

               }

             }

// special Day
if(specialDayCheck==1)
{
 console.log("special dayyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy");
const Specialday_id=req.body.Specialday_id;
const obj=req.body.Special_Day;
  
               if(dif>=0)//for Previous Date
               {  
                  
                  if(User_role=='Admin')//for Admin
                  {
                    Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                        {
                          
                            console.log(result.length,'length')
                            var _Length=result.length;
                           if(_Length==0)
                           {
                               Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                   {
                                       if(result2==null)
                                   {
                               
                               Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                   {
                                   if(results==null)
                                   {
                                       Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                           {
                                           if(results==null)
                                           {
                                           
                                        
//Add 
console.log('Admin')
let Add_Schedule = new Schedule({ 
                            
           
                       
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final_withoutTime,
end_NoTime:End_final_withoutTime,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
color:req.body.color,
bgColor:req.body.bgColor,
Is_StandByBooking:req.body.Is_StandByBooking,
Check_Status:req.body.Check_Status,
commends:req.body.commends,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state, 
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })

res.json({

status:true,
message: 'The admin booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
res.json({
message: "Something went wrong while booking. try again."
})
})

}
else
{
res.json({
   
status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}



})
//Add
}
else
{
res.json({
   
status:true,
message: 'An existing booking already exists for this date. A new booking cannot be created.'
})

}   }) 
                           }
                           else
                           {
                               res.json({
   
                                   status:true,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })
                           }
                       })
                           }
                           else
                           {
                               res.json({
   
                                   status:true,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })
                           }
})
}

               else//For Owner
               {

          
                  
                 Schedule.find({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                   {
                                          
                       console.log(result.length,'length')
                       var _Length=result.length;
                      if(_Length==0)
                       {
                           Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                   if(result2==null)
                               {
                                  
                               Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                   {
                                   if(results==null)
                                   {

                                  Schedule.findOne({Boat_Id:Boat_id,isBookingPending:false,IsActive:true,$or:[{end:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}}]}).then(results=>
                                           {
                                           if(results==null)
                                           {
                                              
                                              
                                             // special Day
                                   // CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
                                   //     console.log(myflag,'Orginal value')
                                       
                                   // if(myflag==0)
                                   // {
                                   //     console.log('inside if jibin')
                               
                                   //     obj.map(function(objs) {   
                                   //     var specialday=objs.special_date;
                                   //     var Specialdayid=objs._id;
                                   //     var Start_final=moment(specialday);
                                   //     var Start_final_withoutTime=Start_final.startOf('day');
                                   //     console.log(Start_final_withoutTime)
                                   // var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                   // if( addspecial == true)
                                   //     {
                                   //     console.log('successs')
                                   //     }
                                   //     else{
                                   //         console.log('fail')
                                   //     }
                                   // })
                               // }
                   
                           
                   //special day
                              

                           Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                               {  
                                   var SummerWeekdays=response.Summer_WeekDays;
                                   var SummerWeekendDays=response.Summer_WeekEndDays;
                                   var  WinterWeekDays=response.Winter_WeekDays;
                                   var WinterweekendDays=response.Winter_WeekEndDays;

                                   //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                   
                                   Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                       {
                                       console.log(Boatresults)
                                       let stopExecution = {stop:false}
                                       let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                           console.log(error)
                                            stopExecution = error
                                       })

                                       if(stopExecution.stop){
                                           return res.json({status:true,message:stopExecution.error})
                                       }

                                       //check Date Between Summer Dates
                   if(isAvailableDay && isAvailableDay.status)
                                   {

                                        //check if next booking included

                                        let isNextDaysError = false
                                        let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id).catch((error)=>{
                                             isNextDaysError = true
                                             return res.json(error)
                                        })

                                        
                                         if(isNextDaysError) return
                                                                         
                                       consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                       .then(element=> 
                                           
                                           {
                                               if(element!=null)
                                               {

                                               
   
                                               if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                               {
   
                                            
if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
{

// for updating Summer days
Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
{   
                             
Summer_WeekDays:SummerWeekdays-WeekDay_Count,
Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count

},
{new: true},
function(err, data) {


});


var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
console.log(x)

//update Summer
  // special Day
  
    CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
     
       
if(myflag==0)
{
   console.log('inside if jibin')

       obj.map(function(objs) {   
       var specialday=objs.special_date;
       var Specialdayid=objs._id;
       var Start_final=moment(specialday);
       var Start_final_withoutTime=Start_final.startOf('day');
       console.log(Start_final_withoutTime)
       var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
   if( addspecial == true)
       {
       console.log('successs')
       }
       else{
           console.log('fail')
       }
})

  // special Day


//Add Summer Section

let Add_Schedule = new Schedule({ 
                            
                         
                       
Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
Booking_ID:globalbookingid,
Boat_Name:req.body.Boat_Name,
Total_DaysBooked:Total_Count,
WeekDay_Count:WeekDay_Count,
WeekEnd_Count: WeekEnd_Count,
calendarId:mongoose.Types.ObjectId(req.body.calendarId),
title:req.body.title,
body:req.body.body,
start:req.body.start,
end:req.body.end,
start_NoTime:Start_final,
end_NoTime:End_final,
goingDuration:req.body.goingDuration,
comingDuration:req.body.comingDuration,
isAllDay:req.body.isAllDay,
category:req.body.category,
dueDateClass:req.body.dueDateClass,
location:req.body.location,
attendees:req.body.attendees,
recurrenceRule:req.body.recurrenceRule,
Is_StandByBooking:req.body.Is_StandByBooking,
Check_Status:req.body.Check_Status,
commends:req.body.commends,
isPending:req.body.isPending,
isFocused:req.body.isFocused,
isVisible:req.body.isVisible,
isReadOnly:req.body.isReadOnly,
isPrivate:req.body.isPrivate,
color:req.body.color,
bgColor:req.body.bgColor,
dragBgColor:req.body.dragBgColor,
borderColor:req.body.borderColor,
customStyle:req.body.customStyle,
raw:req.body.raw,
state:req.body.state, 
User_RoleType:req.body.User_RoleType,
User_Id:mongoose.Types.ObjectId(req.body.User_Id),
Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
Status:Module_status,
IsActive: req.body.IsActive,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now()),
Total_DaysBooked_Reassign:Total_Count,
WeekDay_Count_Reassign:WeekDay_Count,
WeekEnd_Count_Reassign: WeekEnd_Count,
Booking_Type:bookingType,
isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded

});

Add_Schedule.save()
.then(async(response) => {
   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
       console.log(error)  
       console.log(isCleanDay)  
   })
res.json({
   
   status:true,
   message: 'The booking has been successfully created'
})
})
.catch(error => {
   console.log(error,"error")
res.json({
message: "Something went wrong while booking. try again."
})
})        

}//special day
else
{
   res.json({
   
       status:true,
       message: 'You Have Already Booked Special Day'
   })
}
})

}//weekday,weekend



                               else
                                   {

                                    res.json({
                                   status:false,
                                    message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                             })


                                    }
                           }
                           else
                           {

                               res.json({
                                   status:false,
                                   message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                               })


                           }
                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                           })

                       }
                           })
                       
                               }
                           

                   
                                   else
                                   {

                                       //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                       Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                           {
                                          console.log(BoatresultsWinter);
                                       
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                                           console.log(error)
                                            stopExecution = error
                                       })

                                       if(stopExecution.stop){
                                           return res.json({status:true,message:stopExecution.error})
                                       }

                   if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                       {
                                          
                                        //check if next booking included

                                        let isNextDaysError = false
                                        let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id).catch((error)=>{
                                             isNextDaysError = true
                                             return res.json(error)
                                        })

                                        
                                         if(isNextDaysError) return
                                   
                                       consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                       .then(element=> 
                                           
                                           {
                                               if(element!=null)
                                               {

                                       if(element.Winter_ConsecutiveDays>=Total_Count)
                                       {
                                    
                                           if(PendingWinterWeekdays >=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                           {
                                           
                                                // for updating Summer days
                                                Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                {   
                                                                                 
                                                   Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                   Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                    
                                                },
                                                {new: true},
                                                function(err, data) {
                                                    
                                                    
                                                });
                                           

                                                var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag){
                                                    if(myflag==0){

                                                        
                                                obj.map(function(objs) {   
                                                    var specialday=objs.special_date;
                                                    var Specialdayid=objs._id;
                                                    var Start_final=moment(specialday);
                                                    var Start_final_withoutTime=Start_final.startOf('day');
                                                    console.log(Start_final_withoutTime);
                                                   
                                                    var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                                if( addspecial == true)
                                                    {
                                                    console.log('successs')
                                                    }
                                                    else{
                                                        console.log('fail')
                                                    }
                                            })

                                              // Add winter Section 

                                              let Add_Schedule = new Schedule({ 
                            
                         
                       
                                                Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
                                                Booking_ID:globalbookingid,
                                                Boat_Name:req.body.Boat_Name,
                                                Total_DaysBooked:Total_Count,
                                                WeekDay_Count:WeekDay_Count,
                                                WeekEnd_Count: WeekEnd_Count,
                                                calendarId:mongoose.Types.ObjectId(req.body.calendarId),
                                                title:req.body.title,
                                                body:req.body.body,
                                                start:req.body.start,
                                                end:req.body.end,
                                                start_NoTime:Start_final,
                                                end_NoTime:End_final,
                                                goingDuration:req.body.goingDuration,
                                                comingDuration:req.body.comingDuration,
                                                isAllDay:req.body.isAllDay,
                                                category:req.body.category,
                                                dueDateClass:req.body.dueDateClass,
                                                location:req.body.location,
                                                attendees:req.body.attendees,
                                                recurrenceRule:req.body.recurrenceRule,
                                                isPending:req.body.isPending,
                                                isFocused:req.body.isFocused,
                                                isVisible:req.body.isVisible,
                                                isReadOnly:req.body.isReadOnly,
                                                isPrivate:req.body.isPrivate,
                                                Is_StandByBooking:req.body.Is_StandByBooking,
                                                Check_Status:req.body.Check_Status,
                                                commends:req.body.commends,
                                                color:req.body.color,
                                                bgColor:req.body.bgColor,
                                                dragBgColor:req.body.dragBgColor,
                                                borderColor:req.body.borderColor,
                                                customStyle:req.body.customStyle,
                                                raw:req.body.raw,
                                                state:req.body.state, 
                                                User_RoleType:req.body.User_RoleType,
                                                User_Id:mongoose.Types.ObjectId(req.body.User_Id),
                                                Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
                                                Status:Module_status,
                                                IsActive: req.body.IsActive,
                                                Current_Time:moment(Date.now()),
                                                Updated_time: moment(Date.now()),
                                                Total_DaysBooked_Reassign:Total_Count,
                                                WeekDay_Count_Reassign:WeekDay_Count,
                                                WeekEnd_Count_Reassign: WeekEnd_Count,
                                                Booking_Type:bookingType,
                                                isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
                                                
                                                });
                                                
                                                Add_Schedule.save()
                                                .then(async(response) => {
                                                
                                                   let isCleanDay =  await AddCleans(Boat_id,Owner_id,Noofcleans,User_role).catch((error)=>{
                                                       console.log(error)  
                                                       console.log(isCleanDay)  
                                                   })
                                                res.json({
                                                   
                                                   status:true,
                                                   message: 'The booking has been successfully created'
                                                })
                                                })
                                                .catch(error => {
                                                   console.log(error,"error")
                                                res.json({
                                                message: "Something went wrong while booking. try again."
                                                })
                                                })
                                                

                                                    }else{

                                                        res.json({
   
                                                            status:true,
                                                            message: 'You Have Already Booked Special Day'
                                                        })

                                                    }

                                                });
                                               
//Add Winter Section


                                           }//weekday weekend count
                                           else{

                                               res.json({
                                                   status:false,
                                                    message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                       })
       
       
                                                    
                                           }
//Add Winter Section
}
                                     
else
{

res.json({
status:false,
message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
})

}
                                               }
                                               else
                                               {
                                                 res.json({
                                                       status:false,
                                                       message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                   })
                                               }
})                                     }
                                 else
                                 {
                                   res.json({
                                       status:false,
                                       message: 'These dates are not allowed for booking '
                                       //because you are trying to book a date that is not included in the winter or summer of this boat in special day.'
                                   })
                                 }
                               })
                               }//else


                                   
                               });
                           })
//Special day  
// }
// else
// {
 
//   return res.json({

//         status:false,
//         message: 'You have Already booked this Special Day'
//     })
// }
// })


                       }
                       else
                       {
                           res.json({
                               status:false,
                               message: 'An existing booking already exists for this date. A new booking cannot be created.'
                           })
                       }

              
                       
                                         
                           })
                           }
                           else
                           {

                               res.json({
                                   status:false,
                                   message: 'An existing booking already exists for this date. A new booking cannot be created.'
                               })

                           }

                       })
                   }
                   else
                   {
                       res.json({
                           status:false,
                           message: 'An existing booking already exists for this date. A new booking cannot be created.'
                       })

                   }
           
                
                   });//else inside function owner


               }
               else
               {
                   res.json({
                       status:false,
                       message: 'An existing booking already exists for this date. A new booking cannot be created.'
                   })
               }

               });
               }

               }
                               
               else {
                   res.json({
                       status:false,
                       message: 'A booking cannot be created for a previous day'
                   })
               } 
               
           }

//special Day

           
       }
       else
       {

           res.json({
               status:false,
               message: 'Boat Selected is not Active'
           })

       }
  
   });
})

    }catch(error){
        console.log(error)
        return res.json(error)
    }

};

const EditSchedule=async(req, res, next)=>{ 
    
  try{

      
  
  const scheduleid=req.body._id;
  var Back_to_Back_id=req.body.Back_to_Back_id;
  var Back_to_Back_Sheduler_id=req.body.Back_to_Back_Sheduler_id;
  var check_Status=req.body.Check_Status;
  var Total_Count_New=Number(req.body.TotalDay_Count);
  var WeekDay_Count=Number(req.body.WeekDay_Count);
  var WeekEnd_Count= Number(req.body.WeekEnd_Count);
  var User_role=req.body.User_RoleType;
  var Boat_id=req.body.Boat_Id;
  var Owner_id=req.body.User_Id;
  var specialDayCheck=req.body.specialDayCheck;
  console.log(specialDayCheck,'check here')
  var start_Date_New=req.body.start;   
  console.log(start_Date_New)
  var end_Date_New=req.body.end;
var TodaysDate= moment();
var CurrentDate=moment(TodaysDate).format('DD-MM-YYYY');
console.log(CurrentDate);

// var start_Date_NoTime_new=new Date(start_Date_New);
//console.log(start_Date_NoTime.toString(),'hi');
var Start_final_New=moment(start_Date_New);
var Start_final_withoutTime_New=Start_final_New.startOf('day');
// var end_Date_NoTime_New=new Date(end_Date_New);
var End_final_New=moment(end_Date_New);
var End_final_withoutTime_New=End_final_New.startOf('day');
var PendingSummerWeekdays= Number(req.body.summer_Winter_Calc.PENDING_SUMMER_WEEKDAYS);
var PendingSummerWeekEnddays= Number(req.body.summer_Winter_Calc.PENDING_SUMMER_WEEKENDS);
var PendingWinterWeekdays= Number(req.body.summer_Winter_Calc.PENDING_WINTER_WEEKDAYS);
var PendingWinterWeekenddays= Number(req.body.summer_Winter_Calc.PENDING_WINTER_WEEKENDS);

console.log(PendingSummerWeekdays,PendingSummerWeekEnddays,PendingWinterWeekdays,PendingWinterWeekenddays)
var dif=Start_final_New.diff(moment(),'days')
console.log(dif)

  if(req.body.Status=="Enable")
  {

      var  Module_status = 1;
  }
  else if (req.body.Status=="Disable")
  {
      var Module_status = 0;
   }

   

   /* check boat is suspended */
   
      if(User_role == "Owner"){

        let suspendcheck = await manageBoat.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id),Owner_Id:mongoose.Types.ObjectId(Owner_id)}).catch((error) => console.log(error));
      if(suspendcheck.Block == false)
      return res.json({
      status:false,
      message: 'Suspended'
      })

      }
      

   



 let OwnerDetails = await NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)}).catch((error)=> console.log(error)) || {}

    //check if any of the incoming dates already booked

  //   let allDaysBetweenStartAndEndOfIncomingBooking = getDaysBetweenDates(start_Date_New,end_Date_New)

  //   let queryToCheckExistingBooking = []  
    
  //   allDaysBetweenStartAndEndOfIncomingBooking.map((date)=> queryToCheckExistingBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))

  //   const existingNormalBooking = await Schedule.findOne({IsActive:true,isBookingPending:false,Boat_Id:Boat_id,$or:queryToCheckExistingBooking})

  //   if(existingNormalBooking){
  //       return res.json({
  //          status:true,
  //          message: 'An existing booking already exists for this date. A new booking cannot be created.'
  //       })
  //   }

    ///////////////////////////////////////////////////////////////////////////////////////

   //check consecutive days in case of stand by booking and normal booking

   let dayBeforeIncomingBooking;
   let incomingTotalDays;
   let currentBookingStartDate;
   let currentBookingEndDate;

   if(Back_to_Back_id == 0){
       dayBeforeIncomingBooking = new Date(new Date(new Date(start_Date_New).setDate(new Date(start_Date_New).getDate() -1)).setUTCHours(00,00,00,00));
       incomingTotalDays = moment(new Date(req.body.end)).diff(moment(new Date(req.body.start)),"days") + 1;
       currentBookingStartDate = req.body.start;
       currentBookingEndDate = req.body.end
   }else if(Back_to_Back_id == 1){// Back date merge
       //start date is need to be retrived from DB
      const schedule = await Schedule.findOne({_id:scheduleid}).catch((error)=> console.log(error));
      dayBeforeIncomingBooking = new Date(new Date(new Date(schedule.start_NoTime).setDate(new Date(schedule.start_NoTime).getDate() -1)).setUTCHours(00,00,00,00));
      incomingTotalDays = moment(new Date(req.body.end)).diff(moment(new Date(schedule.start)),"days") + 1;
      currentBookingStartDate = schedule.start;
      currentBookingEndDate = req.body.end
   }else if(Back_to_Back_id == 2){// front date merge
      dayBeforeIncomingBooking = new Date(new Date(new Date(start_Date_New).setDate(new Date(start_Date_New).getDate() -1)).setUTCHours(00,00,00,00));
      incomingTotalDays = moment(new Date(req.body.end)).diff(moment(new Date(req.body.start)),"days") + 1;
      currentBookingStartDate = req.body.start;
      currentBookingEndDate = req.body.end
   }else if(Back_to_Back_id == 3){// middle merge

    /***** Reduce Numbeer Of Cleans  */
    let getCleanDays = await  No_OfCleans.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id), Owner_Id: mongoose.Types.ObjectId(Owner_id) }).catch((error)=> console.log(error));
    if(getCleanDays){
        let resultCleanday=(getCleanDays.Cleans)-1;
        const updateVals = { Cleans: resultCleanday};
        const updateCond = { Boat_Id: mongoose.Types.ObjectId(Boat_id), Owner_Id: mongoose.Types.ObjectId(Owner_id) };  
        let durationupdate = await No_OfCleans.findOneAndUpdate(updateCond,updateVals).catch((error) => console.log(error));

    }

     //***** End Reduce Numbeer Of Cleans  *********//
        //start date is need to be retrived from DB
      const schedule = await Schedule.findOne({_id:scheduleid}).catch((error)=> console.log(error));
      
     
      dayBeforeIncomingBooking = new Date(new Date(new Date(schedule.start_NoTime).setDate(new Date(schedule.start_NoTime).getDate() -1)).setUTCHours(00,00,00,00));
      incomingTotalDays = moment(new Date(req.body.end)).diff(moment(new Date(schedule.start)),"days") + 1;
      currentBookingStartDate = schedule.start;
      currentBookingEndDate = req.body.end
   }

   

   let standByBooking = await AddStandByBooking.findOne({Boat_Id:Boat_id,User_Id:Owner_id,BookingStatus:null,$and:[{start_NoTime:{$lte:dayBeforeIncomingBooking}},{end_NoTime:{$gte:dayBeforeIncomingBooking}}]}).catch((error)=> console.log(error))

      
  const boatData = await Boats.findOne({_id:Boat_id,IsActive:true},{SummerSeason_SDate:1,SummerSeason_EDate:1,Launch_Date:1}).catch((error)=> console.log(error));
          
  if(!boatData) return res.json({status:false,message:"Invalid boat."});


  //////////////////////////////////////////////////////////////////////////////////////////////////////

    //check if booking is from launch prelaunch if it is then check consecutive days 

    if(User_role != 'Admin' && User_role != 'Maintenance'){

      let {isBookingBeforeLaunchDate} = await checkPrelaunchLaunchConsecutiveDays(boatData.Launch_Date,currentBookingStartDate,currentBookingEndDate,Boat_id,Owner_id,true,scheduleid,Back_to_Back_Sheduler_id) || {}

      if(!isBookingBeforeLaunchDate){
          // check consecutive days after launch and if the booking exceeds consecutive day throw an error

//decide booking is from summer or winter

const consecutiveDays = await consecutive.findOne({Boat_Id:Boat_id,IsActive:true}).catch((error)=> console.log(error))

if(!consecutiveDays) return res.json({status:false,message:"Set consecutive days."})

if(standByBooking){     

incomingTotalDays +=  moment(new Date(standByBooking.end_NoTime)).diff(moment(new Date(standByBooking.start_NoTime)),"days") + 1

//check if there is a booking before standby booking if include that days to total day

let dayBeforeStandByBooking = new Date(new Date(new Date(standByBooking.start).setDate(new Date(standByBooking.start).getDate() -1)).setUTCHours(00,00,00,00));

let bookingBeforeStandByBooking = await Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:true,$and:[{start_NoTime:{$lte:dayBeforeStandByBooking}},{end_NoTime:{$gte:dayBeforeStandByBooking}}]}).catch((error)=> console.log(error))

if(bookingBeforeStandByBooking){
  incomingTotalDays +=  moment(new Date(bookingBeforeStandByBooking.end_NoTime)).diff(moment(new Date(bookingBeforeStandByBooking.start_NoTime)),"days") + 1
}

}

console.log(incomingTotalDays,"incomingTotalDays one")


let {isIncludedInSummer} = getBookingIsFromWhichSeasonBasedOnStartDate(boatData.SummerSeason_SDate,boatData.SummerSeason_EDate,req.body.start) || {} ;



if(isIncludedInSummer){
if(incomingTotalDays > consecutiveDays.Summer_ConsecutiveDays) return res.json({status:false,message:"The booking exceeds the maximum booking duration . Please try to create a booking with fewer days.."});
}else{
if(incomingTotalDays > consecutiveDays.Winter_ConsecutiveDays) return res.json({status:false,message:"The booking exceeds the maximum booking duration . Please try to create a booking with fewer days.."});
}

 }



      
    }

   

    
  

  
   //////////////////////////////////////////////////////////////////////////////////////////////////


  //check if the booking is a canceled stand by booking by incoming owner


  let allDaysBetweenStartAndEnd = getDaysBetweenDates(req.body.start,req.body.end)

     let queryToCheckCanceledStandByBooking = []  
     
     allDaysBetweenStartAndEnd.map((date)=> queryToCheckCanceledStandByBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))

   

   let isCanceledStandByBooking = await OwnerStandByCancelModel.findOne({Boat_Id:Boat_id,User_Id:Owner_id,$or:queryToCheckCanceledStandByBooking}).catch((error)=>{
           console.log(error)
 })

 if(isCanceledStandByBooking) return res.json({status:true,message:"You are trying to book a canceled stand by booking ."})

 /////////////////////////////////////////////////////////////////////////////////////////

 // check if the user role match the exisisting 

 const existingBookingOfIncomingBooking = await Schedule.findOne({_id:scheduleid,IsActive:true,User_RoleType:req.body.User_RoleType}).catch((error)=>console.log(error))
 
 if(!existingBookingOfIncomingBooking) return res.json({status:false,message:"You don't have permission to edit this booking"})

 //////////////////////////////////////////////////////////////////////////////////////////


 /* Check it is a rejected booking or not */

 let schedulerejected = await Schedule.findOne({_id:mongoose.Types.ObjectId(scheduleid)}).catch((error)=> console.log(error));

 if(schedulerejected.BookingStatus == "Rejected"){

    return res.json({
        status:false,
        message: 'Permission Denied'
        })

 }

 /*  end rejected booking check */



if(Back_to_Back_id=="0")
{
 
  console.log(Back_to_Back_id,'bcktobck0')
       Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(async(BookingResponse)=>
          { 

             
              console.log(BookingResponse)
              var globalbookingid=BookingResponse.Booking_ID;
              var Startdate_old=BookingResponse.start;
              let Enddate_old = BookingResponse.end;
              var start_Date=Startdate_old;   
              console.log(start_Date)
              var Start_final=moment(start_Date);
              console.log(Start_final,'checkkkk5')
              var Start_final_withoutTime=Start_final.startOf('day');
              var Totalday_old=BookingResponse.Total_DaysBooked;
              var Total_Count=Total_Count_New;
              var end_Date=end_Date_New;
              let end_date_old = BookingResponse.end
              var End_final=moment(end_Date);
              var End_final_withoutTime=End_final.startOf('day');
              console.log(End_final_withoutTime,'this is my end day')
              const Getmonth = new Date(Startdate_old);
             var LaunchPreMonth=Getmonth.toLocaleString('default', { month: 'long' });
             var Weekdays_prev=BookingResponse.WeekDay_Count;
             var WeekEndDays_prev=BookingResponse.WeekEnd_Count;

             var CancelledStartDate=new Date(end_Date_New);
            var StartDate_Cancelled=new Date(CancelledStartDate.setDate(CancelledStartDate.getDate() + 1));

              let cancaledDays = getAllCanceledDates(Startdate_old,Enddate_old,req.body.start,req.body.end)
              
      
       Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
          .then(boatDetails=> {

      let bookingType = getBookingTypeofAbooking(start_Date_New,end_Date_New,boatDetails.PreLaunch_Date,boatDetails.Launch_Date,boatDetails.SummerSeason_SDate,boatDetails.SummerSeason_EDate,boatDetails.WinterSeason_SDate,boatDetails.WinterSeason_EDate);
            
       if(boatDetails.Boat_Status=="1")//check whether boat is Active or not
       {
          if(dif>=0)
          {
              
          //between Launch And PreLuanch
  
           if(check_Status=="1" && specialDayCheck==0)
           { 
               
               NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
               .then(OwnerDetails=> {    
             
                  if(!OwnerDetails) OwnerDetails = {}

              Schedule.find({Boat_Id:Boat_id,IsActive:true,User_Id:Owner_id,Check_Status:check_Status,Check_Month:LaunchPreMonth}).then(Checkresult=>
                  {
                      console.log(Checkresult.length,'length')
                      // var _LengthCheck=Checkresult.length;                           
                      
               console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh') 
              PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id}).then(bookingDays=>
                  
                  {
                    
                  var WeekdaysAllowed=bookingDays.No_Of_WeekDays;
                 var WeekEndsAllowed=bookingDays.No_Of_WeekEndDays;
                     var b_days=bookingDays.Booking_Days;
                     console.log(b_days)
                     console.log(Total_Count)
               if(Total_Count<=b_days)
               {
                  if(WeekDay_Count<=WeekdaysAllowed && WeekEnd_Count<=WeekEndsAllowed )
                  {
              console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii')
               
              
                Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                    {
                      
                        console.log(result.length,'length')
                       // var _Length=result.length;
                       
                           Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                
                           console.log('hi1')
                           Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                               {
                               
                                 if(Total_Count>Totalday_old)
                                 {
                                    let allDaysBookedBacktoOne = getDaysBetweenDates(start_Date_New,end_Date_New);

                                    let arrayofBookOne = []  
                                    
                                    allDaysBookedBacktoOne.map((date)=> arrayofBookOne.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));
                                    Schedule.findOne({_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:arrayofBookOne}).then(results=>
                                //   Schedule.findOne({_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                       {
                                          console.log(Start_final_withoutTime);
                                          console.log(End_final_withoutTime);
                                    //   if(results==null||results._id==scheduleid)
                                    if(results==null)
                                       {
                                          console.log('hi3')    
                                  
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state,
  Check_Status:req.body.Check_Status, 
  commends:req.body.commends,
  Check_Month:LaunchPreMonth,
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays
  
},
    
async function(err, data) { /*console.log("Totalday_old::"+Totalday_old);

    console.log("PartialEntry Back to back id 0::::::::check status::1");

  // Raga partial cancellation
  const getyear = new Date(Start_final);
  const Cancellationyear=getyear.getFullYear();
  
  var Noofcancellation=Totalday_old-Total_Count;
 
  let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
      console.log(error)  
      console.log(TotalCancellation)  
  })*/
  // Raga partial cancellation
  console.log(data,'successs')
  
      //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }


     
      
      var mailOptions = {
         
          from:"noreply.smartboatbooking@gmail.com",
          to: OwnerDetails.Email,
          subject: 'Successfully Edited',
          html: getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                             
          
          
      };
      
      transporter.sendMail(mailOptions, function (error, info) {
         
      });           
      
      var mailOptionsAdmin = {
         
          from:"noreply.smartboatbooking@gmail.com",
           to: "admin@smartboating.com.au",
           subject: 'Successfully Edited',
           html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
      };
      
      transporter.sendMail(mailOptionsAdmin, function (error, info) {
      
         
          
      }); 
      //mail
  
  res.json({
     
  status:true,
  message: 'The booking has been successfully Updated'
  })
 
})  
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
}
else
{

  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state,
  Check_Status:req.body.Check_Status, 
  commends:req.body.commends,
  Check_Month:LaunchPreMonth,
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  Booking_Type:bookingType,
  cancaledDays
  
},
    
async function(err, data) {/*console.log("Totalday_oldElse::"+Totalday_old);

    console.log("PartialEntry Back to back id 0::::::::check status::1 else");

    // Raga partial cancellation
    const getyear = new Date(Start_final);
    const Cancellationyear=getyear.getFullYear();
    
    var Noofcancellation=Totalday_old-Total_Count;
   
    let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
        console.log(error)  
        console.log(TotalCancellation)  
    })*/
    // Raga partial cancellation
  console.log(data,'successs else block')
  
      //mail

          const emailState =  'Successfully Edited.';
          const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
          const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
          const emailDetailName = 'Booking Details'
          const emailDetails = [
            { key: 'Boat Name', value:  boatDetails.Boat_Name},
            { key: 'Booking Date', value: getCurrentTimeFormatted() },
          ];
          const emailNameAndLink = {
            name:'Login Link',
            link:`${process.env.CLIENT_URL}/boat-bookings`
          }
      
      
      var mailOptions = {
         
          from:"noreply.smartboatbooking@gmail.com",
          to: OwnerDetails.Email,
          subject: 'Successfully Edited',
          html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                             
          
          
      };
      
      transporter.sendMail(mailOptions, function (error, info) {
         
      });           
      
      var mailOptionsAdmin = {
         
          from:"noreply.smartboatbooking@gmail.com",
           to: "admin@smartboating.com.au",
           subject: 'Successfully Edited',
           html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
      };
      
      transporter.sendMail(mailOptionsAdmin, function (error, info) {
      
         
          
      }); 
      //mail
  
  res.json({
     
  status:true,
  message: 'The booking has been successfully Updated'
  })
 
})

} 

     
}) 
                       
                      
                   })
                       
                      
  })
  
                  }
                  else
                  {
                      res.json({

                          status:true,
                          message: 'Only '  +WeekdaysAllowed +' WeekDays and ' +WeekEndsAllowed  +' WeekendDays are allowed Between launch Date And Pre-Launch Date'
                      })
                  }
              }
           else
           {
              res.json({
  
                  status:true,
                  message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date'
              })
           }
          })
      
      
  })
})
              
              
           }
  
           //between Launch And PreLaunch
  
  
           //After Launch before current date
  
           if(check_Status=="2" && specialDayCheck==0)
           {
              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
  
                  Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                      {
  
                          if(Cancelresults==null)
                          {
                       
  
              Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                  {
                                         
                      console.log(result.length,'length')
                     // var _Length=result.length;
                     
                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                              {
                              
                                 
                              Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                  {
                                      if(Total_Count>Totalday_old)
                                      {
                                      
  
                                          Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                          {
                                            
                                          if(results==null)
                                          {
                                      
                             
  
                          Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                              {  
                                  var SummerWeekdays=response.Summer_WeekDays;
                                  var SummerWeekendDays=response.Summer_WeekEndDays;
                                  var  WinterWeekDays=response.Winter_WeekDays;
                                  var WinterweekendDays=response.Winter_WeekEndDays;

                                  //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                  
                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                      {
                                      
                                         
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {

                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                        
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                              
  
                                              if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                              {
  
                                           
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                            
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
  
  },
  {new: true},
  function(err, data) {
  
  
  });
  var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
  var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
  console.log(x)
         
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {                         
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
 
   //mail
   
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink) 
                         
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
                                }//weekday,weekend
                              else
                                  {
  
                                   res.json({
                                  status:false,
                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                            })
  
  
                                   }
                          }
                          else
                          {
  
                              res.json({
                                  status:false,
                                  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                              })
  
  
                          }
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'Consecutive days for this boat is Empty'
                          })
  
                      }
                          })
                      
                              }
                          
  
                  
                                  else
                                  {

                                      //,WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                          {
                                         console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
 
                                         
                                       //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                  
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                      if(element.Winter_ConsecutiveDays>=Total_Count)
                                      {
                                   
                                          if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                          {
                                          
                                               // for updating Summer days
                                               Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                               {   
                                                                                
                                                  Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                  Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                   
                                               },
                                               {new: true},
                                               function(err, data) {
                                                   
                                                   
                                               });
                                               var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
                                               var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
                                               var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
                                               console.log(x)
                                              
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  },
  
  function(err, data) {
  
   //mail
   
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                         
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
 
  
                                          }//weekday weekend count
                                          else{
  
                                              res.json({
                                                  status:false,
                                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                      })
      
      
                                                   
                                          }
  //Add Winter Section
  }
                                    
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                              }
                                              else
                                              {
                                                res.json({
                                                      status:false,
                                                      message: 'Consecutive days for this boat is Empty'
                                                  })
                                              }
  })                                     }
                                else
                                {
                                  res.json({
                                      status:false,
                                      message: 'These Dates Are not Allowed for Booking'
                                  })
                                }
                              })
                              }//else
  
  
                                  
                              });
                          })
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
                                        
                          })
                          
                      }
                      else
                      {
                         

                          Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                              {  
                                  var SummerWeekdays=response.Summer_WeekDays;
                                  var SummerWeekendDays=response.Summer_WeekEndDays;
                                  var  WinterWeekDays=response.Winter_WeekDays;
                                  var WinterweekendDays=response.Winter_WeekEndDays;

                                  //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                  
                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                      {
                                     
                                         
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {

                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                        
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(async(element)=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                              
  
                                              if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                              {
  
                                           
                          if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                            
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
  
  },
  {new: true},
  function(err, data) {
  
  
  });

   //partial cancellation
   const getyear = new Date(Start_final);
   const Cancellationyear=getyear.getFullYear();
   var Noofcancellation=Totalday_old-Total_Count;
   let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
       console.log(error)  
       console.log(TotalCancellation)  
   })
   //partial cancellation
  

   var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
  })
 var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
  })
  var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
  })
  if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
  {

      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;

      //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

      if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })

  

  if(GetCancellationNumber.No_PartialCancellation){

      console.log("insde check status 2 in back to back 0");

      console.log(Start_final,"Start_final",End_final,"End_final");


  let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)

      console.log(reAssignedWeekDaysCount,reAssignedWeekendCount,"reAssignedWeekDaysCount","reAssignedWeekendCount")

        //update allocated cancellation days

      //reassigning
    

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-reAssignedWeekDaysCount,
  Summer_WeekEndDays:SE_day-reAssignedWeekendCount,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }


   //get days and weeks 

//update allocated cancellation days
        
manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
  { 
  No_PartialCancellation:0,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  });

  
  }    
  else
  {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;

      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
      { 
      No_PartialCancellation:No_Of_LOA,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      });

      //update allocated cancellation days

      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-WeekdayCancelled,
  Summer_WeekEndDays:SE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }   
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                                                         
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
 
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                         
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
                                }//weekday,weekend
                              else
                                  {
  
                                   res.json({
                                  status:false,
                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                            })
  
  
                                   }
                          }
                          else
                          {
  
                              res.json({
                                  status:false,
                                  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                              })
  
  
                          }
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'Consecutive days for this boat is Empty'
                          })
  
                      }
                          })
                      
                              }
                          
  
                  
                                  else
                                  {
                                      //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                          {
                                         console.log(BoatresultsWinter);
  
                                    //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                         
                                       //check if next booking included

                                       let isNextDaysError = false
                                       let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                            isNextDaysError = true
                                            return res.json(error)
                                       })

                                       
                                        if(isNextDaysError) return
                                  
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(async(element)=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                      if(element.Winter_ConsecutiveDays>=Total_Count)
                                      {
                                   
                                          if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                          {
                                          
                                               // for updating Summer days
                                               Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                               {   
                                                                                
                                                  Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                  Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                   
                                               },
                                               {new: true},
                                               function(err, data) {
                                                   
                                                   
                                               });

                                                 //partial cancellation
 //partial cancellation
 const getyear = new Date(Start_final);
 const Cancellationyear=getyear.getFullYear();
 var Noofcancellation=Totalday_old-Total_Count;
 let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
     console.log(error)  
     console.log(TotalCancellation)  
 })
 //partial cancellation


 var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
})
var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
})
if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
{
      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
       //update allocated cancellation days
              //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })


  if(GetCancellationNumber.No_PartialCancellation){



  let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)


        //update allocated cancellation days

      //reassigning
    

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
 
  var WS_day=result.Winter_WeekDays;
  var WE_day=result.Winter_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Winter_WeekDays:WS_day-reAssignedWeekDaysCount,
  Winter_WeekEndDays:WE_day-reAssignedWeekendCount,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }

   //get days and weeks 
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
  }
  else
  {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
       //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var WS_day=result.Winter_WeekDays;
  var WE_day=result.Winter_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Winter_WeekDays:WS_day-WeekdayCancelled,
  Winter_WeekEndDays:WE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }  
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
 
  
                                          }//weekday weekend count
                                          else{
  
                                              res.json({
                                                  status:false,
                                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                      })
      
      
                                                   
                                          }
  //Add Winter Section
  }
                                    
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                              }
                                              else
                                              {
                                                res.json({
                                                      status:false,
                                                      message: 'Consecutive days for this boat is Empty'
                                                  })
                                              }
  })                                     }
                                else
                                {
                                  res.json({
                                      status:false,
                                      message: 'These Dates Are not Allowed for Booking'
                                  })
                                }
                              })
                              }//else
  
  
                                  
                              });
                          })
                          
                      }      
  
                      })
                  
                 
          
               
                  });//else inside function owner
  
  
              
             
  
              });
  
          }
          else
          {
    
              console.log(Start_final_withoutTime)
              console.log(End_final_withoutTime)
              console.log(Cancelresults.Updated_time,'thissssssssss')
              var todaysdate=moment();
              console.log(todaysdate)
              var canceldate =moment(Cancelresults.Updated_time)
              var dif=moment.duration(todaysdate.diff(canceldate));
              console.log(dif.asHours());
              var Hrdif=Math.round(dif.asHours());
          
              console.log(Hrdif);
  
  
              if(Hrdif>24)
  
              {
                 
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                          if(Total_Count>Totalday_old)
                                          {
                                          
      
                                              Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                          
                                 
      
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                      
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {

                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                   if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
      {
      
      // for updating Summer days
      Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
      {   
                                
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
      
      },
      {new: true},
      function(err, data) {
      
      
      });
     
      var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
      var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
      console.log(x)
      
               
      
      
      //Add Summer Section
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      start_CancelledDate:StartDate_Cancelled,
      end_CancelledDate:end_date_old,
      Booking_Type:bookingType,
      cancaledDays,
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
  },
  
  function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
                                 }//weekday,weekend
                                  else
                                      {
      
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
      
      
                                       }
                              }
                              else
                              {
      
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
      
      
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'Consecutive days for this boat is Empty'
                              })
      
                          }
                              })
                          
                                  }
                              
      
                      
                                      else
                                      {
                                          //,WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}

                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
      
                                         //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                              //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                          
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count)//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                                   
                                                   var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
                                                   var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
                                                   console.log(x)
                                                   
      //Add Winter Section
      
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      WeekDay_Count:WeekDay_Count,
     WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      start_CancelledDate:StartDate_Cancelled,
      end_CancelledDate:end_date_old,
      Booking_Type:bookingType,
      cancaledDays,
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
      },
      
      function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
      
      
                                              }//weekday weekend count
                                              else{
      
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
      //Add Winter Section
      }
                                        
      else
      {
      
      res.json({
      status:false,
      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
      
      }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'Consecutive days for this boat is Empty'
                                                      })
                                                  }
      })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
      
      
                                      
                                  });
                              })
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
                                            
                              })
                          }
                          else
                          {
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                         
                                             
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {
      
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(async(element)=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
      {
      
      // for updating Summer days
      Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
      {   
                                
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
      
      },
      {new: true},
      function(err, data) {
      
      
      });
                                                    //partial cancellation
//partial cancellation
const getyear = new Date(Start_final);
const Cancellationyear=getyear.getFullYear();
var Noofcancellation=Totalday_old-Total_Count;
let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
   console.log(error)  
   console.log(TotalCancellation)  
})
//partial cancellation

var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
})

var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
})
if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
{
      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;

    //get days and weeks 
    var obj = Object();
    obj.start =Start_final;
    obj.end = End_final;
    
    var datas =  getDaysInMonth_Sheduler(obj);
    console.log(datas)
                   var arr=[];
                 
                  datas.forEach(function(item) {
                    Object.keys(item).forEach(function(key) {
                        arr.push(item[key]);
                      console.log( item[key]);
                    });
                  });
    console.log(arr)
    var index=arr.length - 1;
    var Loa_Length=No_Of_LOA;
    var WeekDay_Count_edit=0;
    var   WeekEnd_Count_edit=0;
    while(Loa_Length>0)
    {
    
        
        console.log(arr[index]);
        let day = arr[index];

        if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
            WeekDay_Count_edit=WeekDay_Count_edit+1;
          
        }
        else
        {
            WeekEnd_Count_edit= WeekEnd_Count_edit+1;
    
        }
    
        Loa_Length--;
        index--;
    }
    var WeekDay_Count_edits=WeekDay_Count_edit;
    var WeekEnd_Count_edits=WeekEnd_Count_edit;
      
    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        WeekDay_Count_Edit:WeekDay_Count_edits,
        WeekEnd_Count_Edit:WeekEnd_Count_edits,
        Total_Edit_Loa:No_Of_LOA,
        PartialCancellation_Status:1,
        Updated_time: moment(Date.now()),
     
    },
      
        function(err, data) {
        })


        if(GetCancellationNumber.No_PartialCancellation){


          let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
      
            
                //update allocated cancellation days
      
              //reassigning
            
      
      OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
          {
          console.log(result)
          var SS_day=result.Summer_WeekDays;
          var SE_day=result.Summer_WeekEndDays;   
          
          OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
          { 
          
          Boat_Id:Boat_id,
          Owner_Id:Owner_id,
          Summer_WeekDays:SS_day-reAssignedWeekDaysCount,
          Summer_WeekEndDays:SE_day-reAssignedWeekendCount,
          IsActive:true,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
          });
          })
          
          //reassigning
          }
    
         //get days and weeks 


      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
  
     }         
     else
     {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
           //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-WeekdayCancelled,
  Summer_WeekEndDays:SE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
     }  
      
      //Add Summer Section
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
      Booking_Type:bookingType,
      cancaledDays,
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
  },
  
  function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
                                 }//weekday,weekend
                                  else
                                      {
      
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
      
      
                                       }
                              }
                              else
                              {
      
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
      
      
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'Consecutive days for this boat is Empty'
                              })
      
                          }
                              })
                          
                                  }
                              
      
                      
                                      else
                                      {

                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
      
                                       //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                             
                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(async(element)=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
 //partial cancellation
 const getyear = new Date(Start_final);
 const Cancellationyear=getyear.getFullYear();
 var Noofcancellation=Totalday_old-Total_Count;
 let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
     console.log(error)  
     console.log(TotalCancellation)  
 })
 //partial cancellation


 var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
})
var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
})
if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
{  var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
      //update allocated cancellation days
              //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })

  if(GetCancellationNumber.No_PartialCancellation){



      let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
  
  
            //update allocated cancellation days
  
          //reassigning
        
  
  OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
      {
      console.log(result)
     
      var WS_day=result.Winter_WeekDays;
      var WE_day=result.Winter_WeekEndDays;   
      
      OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
      { 
      
      Boat_Id:Boat_id,
      Owner_Id:Owner_id,
      Winter_WeekDays:WS_day-reAssignedWeekDaysCount,
      Winter_WeekEndDays:WE_day-reAssignedWeekendCount,
      IsActive:true,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
      });
      })
      
      //reassigning
      }

   //get days and weeks 
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
  }    
  else
  {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var WS_day=result.Winter_WeekDays;
  var WE_day=result.Winter_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Winter_WeekDays:WS_day-WeekdayCancelled,
  Winter_WeekEndDays:WE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }  
  
  //Add Winter Section
      
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
      Booking_Type:bookingType,
      cancaledDays,
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
      },
      
      function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
      
      
                                              }//weekday weekend count
                                              else{
      
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
      //Add Winter Section
      }
                                        
      else
      {
      
      res.json({
      status:false,
      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
      
      }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'Consecutive days for this boat is Empty'
                                                      })
                                                  }
      })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
      
      
                                      
                                  });
                              })

                          }
                             
      
                          })
                                      
              
                   
                      });//else inside function owner
      
      
                 
      
                  });
              }
                 else
                 {
                      res.json({
                      status:false,
                      message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                  })
                 } 
  
          }
      })
  })
  
         
           }
           
  
  
          //between Launch And PreLuanch
          if(check_Status=="3" && specialDayCheck==0)
          {
            
                          
                             
                             if(User_role=='Admin')//for Admin
                             {
                               Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                                   {
                                     
                                       console.log(result.length,'length')
                                       var _Length=result.length;
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                              {
                                              
                                          
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             if(Total_Count>Totalday_old)
                                             {
                                                let getAllDaysChek3 = getDaysBetweenDates(start_Date_New,end_Date_New);

                                                let getAarrayDatesCheck3 = []  

                                                getAllDaysChek3.map((date)=> getAarrayDatesCheck3.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));

                                                Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:getAarrayDatesCheck3}).then(results=>

                                             // Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                                                      
                                                   
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                      
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final_withoutTime,
       end_NoTime:End_final_withoutTime,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
       Booking_Type:bookingType,
       cancaledDays
  
  },
  
  function(err, data) {
  
  //mail        

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
            
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
       res.json({
           
           status:true,
           message: 'The admin booking has been successfully Updated'
       })
   })
   
        
  }
  else
  {
      res.json({
              
          status:true,
          message: 'An existing booking already exists for this date. A new booking cannot be created.'
      })
  
  }
  
  
  
  })
  //Add
}
else
{
                                                 
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                      
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
       end:req.body.end,
       start_NoTime:Start_final_withoutTime,
       end_NoTime:End_final_withoutTime,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now()),
       start_CancelledDate:StartDate_Cancelled,
       end_CancelledDate:end_date_old,
       Booking_Type:bookingType,
       cancaledDays
  
  },
  
  function(err, data) {
  
  //mail
 
  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
            
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
       res.json({
           
           status:true,
           message: 'The admin booking has been successfully Updated'
       })
   })

}
   
}) 
                                      
                                    
                                  })
                                      
                                      
   })
  }
  
                          else//For Owner
                          {
                              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
                              Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                                  {
  
                                      if(Cancelresults==null)
                                      {
  
                                 
  console.log(Cancelresults,'cancellation rewsulttttt')
                                 
                     
                             
                            Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                          
                                             
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                                  if(Total_Count>Totalday_old)
                                                  { 

                                                    let allDaysBookedZero = getDaysBetweenDates(start_Date_New,end_Date_New);

                                                    let arrayofBookZero = []  

                                                    allDaysBookedZero.map((date)=> arrayofBookZero.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));

                                                    Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:arrayofBookZero}).then(results=>
  
                                                     // Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},

                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                 
                                                     
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {
                                                          
                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
       
       var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
       var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
       var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
      console.log(x)
    
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
    
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
  
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                         
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
      })
                                    }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {

                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                              //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                     
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count)//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
                                                          
                                                           var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
                                                           var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
                                                           console.log(x)
                                                            
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
   WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)        
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
     
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
                                  }
                                  else
                                  {


                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;


                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                  
                                                     
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {

                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(async(element)=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
 //partial cancellation
 const getyear = new Date(Start_final);
 const Cancellationyear=getyear.getFullYear();
 var Noofcancellation=Totalday_old-Total_Count;
 let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
     console.log(error)  
     console.log(TotalCancellation)  
 })
 //partial cancellation

 var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
})

var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
})
if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
{
      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
      //update allocated cancellation days
              //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })


  if(GetCancellationNumber.No_PartialCancellation){

      console.log("insde check status 3 in back to back 0")

      console.log(Start_final,"Start_final",End_final,"End_final");


  let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)

      console.log(reAssignedWeekDaysCount,reAssignedWeekendCount,"reAssignedWeekDaysCount","reAssignedWeekendCount")

        //update allocated cancellation days

      //reassigning
    

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;  
  console.log(SS_day,SE_day,'summer ss and se days') 
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-reAssignedWeekDaysCount,
  Summer_WeekEndDays:SE_day-reAssignedWeekendCount,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  {
      new:true
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  console.log(data,'updated owner booking')
  });
  })
  
  //reassigning
  }
      if(No_Of_LOA> 0){

          //automatically approve cancellation
  
          DoApproveCancellation(req.body._id,No_Of_LOA,1,No_Of_LOA,WeekDay_Count_edits,WeekEnd_Count_edits,req.body.start,req.body.end)
  
      }
   //get days and weeks 
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
  
       //update Summer
                       
  }
  else
  {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-WeekdayCancelled,
  Summer_WeekEndDays:SE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
    
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
          WeekDay_Count:WeekDay_Count,
          WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
  
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)            
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
      })
                                    }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(async(element)=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
//partial cancellation
const getyear = new Date(Start_final);
const Cancellationyear=getyear.getFullYear();
var Noofcancellation=Totalday_old-Total_Count;
let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
    console.log(error)  
    console.log(TotalCancellation)  
})
//partial cancellation
console.log("Boat::"+Boat_id);console.log("OWn::"+Owner_id);

var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{
})
var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
console.log("GetCancellationNumber11",GetCancellationNumber.No_PartialCancellation,"GetCancellationNumber11")
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
});
console.log("TestCancelCnt::"+Noofcancellation+"@");
if((Noofcancellation)>(GetCancellationNumber.No_PartialCancellation)||(GetYearOfCancellation.Noofcancellation)<(GetAllocatedNumber.No_PartialCancellation))
{
    console.log("ENTEREDIF");
   
      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
            //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })
  
  if(GetCancellationNumber.No_PartialCancellation){

   

      let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
  
  
            //update allocated cancellation days
  
          //reassigning
        
  
  OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
      {
      //console.log(result)
     
      var WS_day=result.Winter_WeekDays;
      var WE_day=result.Winter_WeekEndDays;   
      
      OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
      { 
      
      Boat_Id:Boat_id,
      Owner_Id:Owner_id,
      Winter_WeekDays:WS_day-reAssignedWeekDaysCount,
      Winter_WeekEndDays:WE_day-reAssignedWeekendCount,
      IsActive:true,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
      });
      })
      
      //reassigning
      }


      if(No_Of_LOA> 0){

          //automatically approve cancellation
  
          DoApproveCancellation(req.body._id,No_Of_LOA,1,No_Of_LOA,WeekDay_Count_edits,WeekEnd_Count_edits,req.body.start,req.body.end)
  
      }

  
      

   //get days and weeks 
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
      
  }

  else
  { console.log("STEP2");
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var WS_day=result.Winter_WeekDays;
  var WE_day=result.Winter_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Winter_WeekDays:WS_day-WeekdayCancelled,
  Winter_WeekEndDays:WE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }  
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
       WeekDay_Count:WeekDay_Count,
       WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
   //mail
 
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink) 
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
     
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })


                                  }
                                  })
                              
                             
                      
                           
                              });//else inside function owner
  
  
                          
  
                          });
                      }
                      else
                      {
  
                          //
                      
                      console.log(Start_final_withoutTime)
                      console.log(End_final_withoutTime)
                      console.log(Cancelresults.Updated_time,'thissssssssss')
                      var todaysdate=moment();
                      console.log(todaysdate)
                      var canceldate =moment(Cancelresults.Updated_time)
                      var dif=moment.duration(todaysdate.diff(canceldate));
                      console.log(dif.asHours());
                      var Hrdif=Math.round(dif.asHours());
                  
                      console.log(Hrdif);
  
  
                      if(Hrdif>24)
  
                      {
                          Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                 
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                           
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             if(Total_Count>Totalday_old)
                                             {
  
                                              Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                               
                                                     
                                              if(Boatresults!=null)//check Date Between Summer Dates
                                              {
  
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
      
  
       var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
       var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
       var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
      console.log(x)
      
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
         
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
          WeekDay_Count:WeekDay_Count,
          WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays
  
  },
   
  function(err, data) {
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
                                   }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {

                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                                //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                     
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
                                                          
                                                           var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
                                                           var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
                                                           console.log(x)
                                                           
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      WeekDay_Count:WeekDay_Count,
      WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
function(err, data)
{
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
})
      
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
                                  }
                                  else
                                  {

                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                               
                                                     
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {

                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(async(element)=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  //partial cancellation
   const getyear = new Date(Start_final);
   const Cancellationyear=getyear.getFullYear();
   var Noofcancellation=Totalday_old-Total_Count;
   let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
       console.log(error)  
       console.log(TotalCancellation)  
   })
   //partial cancellation
  

   var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
  })
 var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
  })
  var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
  })
  if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
  {
   var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
//get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })


  if(GetCancellationNumber.No_PartialCancellation){


  let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)

    
        //update allocated cancellation days

      //reassigning
    

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-reAssignedWeekDaysCount,
  Summer_WeekEndDays:SE_day-reAssignedWeekendCount,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }


   //get days and weeks 
                                                  //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
       
       //update Summer
                       
      }
      else
      {
          var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
          //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
         //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var SS_day=result.Summer_WeekDays;
  var SE_day=result.Summer_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Summer_WeekDays:SS_day-WeekdayCancelled,
  Summer_WeekEndDays:SE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
      }  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
         
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
          Total_DaysBooked:Total_Count,
          WeekDay_Count:WeekDay_Count,
          WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
                                   }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {

                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                      //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return          
                                                  
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(async(element)=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count)//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
//partial cancellation
const getyear = new Date(Start_final);
const Cancellationyear=getyear.getFullYear();
var Noofcancellation=Totalday_old-Total_Count;
let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
    console.log(error)  
    console.log(TotalCancellation)  
})
//partial cancellation


var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
})
var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
})
var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
})
if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
{
      var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
            //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })

  if(GetCancellationNumber.No_PartialCancellation){



      let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
  
  
            //update allocated cancellation days
  
          //reassigning
        
  
  OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
      {
      console.log(result)
     
      var WS_day=result.Winter_WeekDays;
      var WE_day=result.Winter_WeekEndDays;   
      
      OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
      { 
      
      Boat_Id:Boat_id,
      Owner_Id:Owner_id,
      Winter_WeekDays:WS_day-reAssignedWeekDaysCount,
     Winter_WeekEndDays:WE_day-reAssignedWeekendCount,
      IsActive:true,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
      });
      })
      
      //reassigning
      }


   //get days and weeks 
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
       
  }
  else
  {
      var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
      //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
      //reassigning
      var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
      var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
  {
  console.log(result)
  var WS_day=result.Winter_WeekDays;
  var WE_day=result.Winter_WeekEndDays;   
  
  OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
  { 
  
  Boat_Id:Boat_id,
  Owner_Id:Owner_id,
  Winter_WeekDays:WS_day-WeekdayCancelled,
  Winter_WeekEndDays:WE_day-WeekEndCancelled,
  IsActive:true,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  },
  
  function(err, data) {
  
  console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
  });
  })
  
  //reassigning
  }  
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      WeekDay_Count:WeekDay_Count,
      WeekEnd_Count: WeekEnd_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
          Booking_Type:bookingType,
          cancaledDays,
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
function(err, data)
{
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
})
      
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })

                                  }
                                  })
                             
                      
                           
                              });//else inside function owner
  
  
                         
  
                          });
  
                      }
                         else
                         {
                              res.json({
                              status:false,
                              message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                          })
                         } //
  
                          // res.json({
                          //     status:false,
                          //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                          // })
  
                      }
                  })
              })
                          }
  
                        
                          
                      }
  
                if(check_Status="4" && User_role=="Maintenance" )
                {
                console.log(Start_final_withoutTime+"@"+End_final_withoutTime);
  
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                        
                          console.log(result.length,'lengthEDIT');

                         
                            Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true,isBookingPending:false}).then(result2=>
                                {
                                
                            Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true,isBookingPending:false}).then(results=>
                                {
                               if(Total_Count>Totalday_old)
                               {

                                let allDaysBooked = getDaysBetweenDates(start_Date_New,end_Date_New);

                                let arrayofBook = []  

                                allDaysBooked.map((date)=> arrayofBook.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));

                                //Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>

                                 Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:arrayofBook}).then(results=>
                                        {
                                            
                                        if(results==null)
                                        {
                                        
                                     
 //Add 
 console.log('Admin')
 Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
 {
                         
        
                    
 Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
 Booking_ID:globalbookingid,
 Boat_Name:req.body.Boat_Name,
 Total_DaysBooked:Total_Count,
 WeekDay_Count:WeekDay_Count,
 WeekEnd_Count: WeekEnd_Count,
 calendarId:mongoose.Types.ObjectId(req.body.calendarId),
 title:req.body.title,
 body:req.body.body,
 start:req.body.start,
 end:req.body.end,
 start_NoTime:Start_final_withoutTime,
 end_NoTime:Start_final_withoutTime,
 goingDuration:req.body.goingDuration,
 comingDuration:req.body.comingDuration,
 isAllDay:req.body.isAllDay,
 category:req.body.category,
 dueDateClass:req.body.dueDateClass,
 location:req.body.location,
 attendees:req.body.attendees,
 recurrenceRule:req.body.recurrenceRule,
 isPending:req.body.isPending,
 isFocused:req.body.isFocused,
 isVisible:req.body.isVisible,
 isReadOnly:req.body.isReadOnly,
 isPrivate:req.body.isPrivate,
 color:req.body.color,
 Is_StandByBooking:req.body.Is_StandByBooking,
 Check_Status:req.body.Check_Status,
 commends:req.body.commends,
 bgColor:req.body.bgColor,
 dragBgColor:req.body.dragBgColor,
 borderColor:req.body.borderColor,
 customStyle:req.body.customStyle,
 raw:req.body.raw,
 state:req.body.state, 
 User_RoleType:req.body.User_RoleType,
 User_Id:mongoose.Types.ObjectId(req.body.User_Id),
 Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
 Status:Module_status,
 IsActive: req.body.IsActive,
 Current_Time:moment(Date.now()),
 Updated_time: moment(Date.now()),
 start_CancelledDate:StartDate_Cancelled,
 end_CancelledDate:end_date_old,
 Booking_Type:bookingType,
 cancaledDays
 
 },
 
function(err, data)
{
  //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
         
 
 var mailOptionsAdmin = {   
     from:"noreply.smartboatbooking@gmail.com",
      to: "admin@smartboating.com.au",
      subject: 'Maintainance Edited',
      html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
 };
 
 transporter.sendMail(mailOptionsAdmin, function (error, info) {
 
    
     
 }); 
 //mail
 
 
 res.json({
 
 status:true,
 message: 'The boat maintenance booking has been successfully Updated'
 })
 })

 }
 else
 {
 res.json({
 
 status:true,
 message: 'An existing booking already exists for this date. A new booking cannot be created.'
 })
 
 }
 
 
 
 })
 //Add
}
else
{
 console.log('Admin')
 Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
 {
                         
        
                    
 Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
 Booking_ID:globalbookingid,
 Boat_Name:req.body.Boat_Name,
 Total_DaysBooked:Total_Count,
 WeekDay_Count:WeekDay_Count,
 WeekEnd_Count: WeekEnd_Count,
 calendarId:mongoose.Types.ObjectId(req.body.calendarId),
 title:req.body.title,
 body:req.body.body,
 start:req.body.start,
 end:req.body.end,
 start_NoTime:Start_final_withoutTime,
 end_NoTime:Start_final_withoutTime,
 goingDuration:req.body.goingDuration,
 comingDuration:req.body.comingDuration,
 isAllDay:req.body.isAllDay,
 category:req.body.category,
 dueDateClass:req.body.dueDateClass,
 location:req.body.location,
 attendees:req.body.attendees,
 recurrenceRule:req.body.recurrenceRule,
 isPending:req.body.isPending,
 isFocused:req.body.isFocused,
 isVisible:req.body.isVisible,
 isReadOnly:req.body.isReadOnly,
 isPrivate:req.body.isPrivate,
 color:req.body.color,
 Is_StandByBooking:req.body.Is_StandByBooking,
 Check_Status:req.body.Check_Status,
 commends:req.body.commends,
 bgColor:req.body.bgColor,
 dragBgColor:req.body.dragBgColor,
 borderColor:req.body.borderColor,
 customStyle:req.body.customStyle,
 raw:req.body.raw,
 state:req.body.state, 
 User_RoleType:req.body.User_RoleType,
 User_Id:mongoose.Types.ObjectId(req.body.User_Id),
 Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
 Status:Module_status,
 IsActive: req.body.IsActive,
 Current_Time:moment(Date.now()),
 Updated_time: moment(Date.now()),
 start_CancelledDate:StartDate_Cancelled,
 end_CancelledDate:end_date_old,
 Booking_Type:bookingType,
 cancaledDays
 
 },
 
function(err, data)
{
  //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
 
         
 
 var mailOptionsAdmin = {   
     from:"noreply.smartboatbooking@gmail.com",
      to: "admin@smartboating.com.au",
      subject: 'Maintainance Edited',
      html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
 };
 
 transporter.sendMail(mailOptionsAdmin, function (error, info) {
 
    
     
 }); 
 //mail
 
 
 res.json({
 
 status:true,
 message: 'The boat maintenance booking has been successfully Updated'
 })
 })

}
}) 
                        
                        
                    })
                    
                        //  var _Length=result.length;
                         
  })
                 
  
                }
  
  // special Day
  if(specialDayCheck==1)
  {
    console.log("EditSchedule Special Day");
   const Specialday_id=req.body.Specialday_id;
   const obj=req.body.Special_Day;
     
                  
                     
                     if(User_role=='Admin')//for Admin
                     {
                       Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                             
                               console.log(result.length,'length')
                              // var _Length=result.length;
                             
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                      {
                                      
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      if(Total_Count>Totalday_old)
                                      {
                                          Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                              
                                           
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                               
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays
  
  },
  
function(err,data)
{
  res.json({
   
   status:true,
   message: 'The admin booking has been successfully created'
  })
  })
  
  
  }
  else
  {
  res.json({
      
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
}
else
{

  
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                               
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays
  
  },
  
function(err,data)
{
  res.json({
   
   status:true,
   message: 'The admin booking has been successfully created'
  })
  })
}
  //Add
   }) 
                             
                          })
                             
  })
  }
  
                  else//For Owner
                  {
  
                      NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                      .then(OwnerDetails=> {
                     
                    Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
                                          if(Total_Count>Totalday_old)
                                          {
                                              Schedule.findOne({isBookingPending:false,_id:{$ne:scheduleid},Boat_Id:Boat_id,IsActive:true,$or:[{$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]},{$and:[{start:{$lte:Start_final_withoutTime_New}},{end:{$gte:Start_final_withoutTime_New}}]},{start_NoTime:Start_final_withoutTime_New},{start_NoTime:End_final_withoutTime}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                                 
                                                 
                                     
                                     
                                 
  
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                          
                                             
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {

                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                                
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
  },
  {new: true},
  function(err, data) {
   
   
  });
  
  
  var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
  var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit)
  console.log(x)
 
  //update Summer
     // special Day
     
       CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
          
         
          
  if(myflag==0)
  {
      console.log('In the SpecialdayChek Block Backto Backid 0')
  
          obj.map(function(objs) {   
          var specialday=objs.special_date;
          var Specialdayid=objs._id;
          var Start_final=moment(specialday);
          var Start_final_withoutTime=Start_final.startOf('day');
          console.log(Start_final_withoutTime)
          var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
      if( addspecial == true)
          {
          console.log('successs')
          }
          else{
              console.log('fail')
          }
  })
  
     // special Day
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
       
  
  }//special day
  else
  {
      res.json({
      
          status:true,
          message: 'You Have Already Booked Special Day'
      })
  }
  })
  
  }//weekday,weekend
  
  
  
                                  else
                                      {
  
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
  
  
                                       }
                              }
                              else
                              {
  
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
  
  
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                              })
  
                          }
                              })
                          
                                  }
                              
  
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                                                  //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
  
                                                   var WeekDay_Count_edit=WeekDay_Count-Weekdays_prev;
                                                   var WeekEnd_Count_edit=WeekEnd_Count-WeekEndDays_prev;
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count_edit,WeekEnd_Count_edit);
                                                  
                                                   CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {

                                                    if(myflag==0)
                                                    {

                                                        obj.map(function(objs) {   
                                                            var specialday=objs.special_date;
                                                            var Specialdayid=objs._id;
                                                            var Start_final=moment(specialday);
                                                            var Start_final_withoutTime=Start_final.startOf('day');
                                                            console.log(Start_final_withoutTime)
                                                            var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                                        if( addspecial == true)
                                                            {
                                                            console.log('successs')
                                                            }
                                                            else{
                                                                console.log('fail')
                                                            }
                                                    });

                                                      //Add Winter Section
  
                                                    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
                                                    {
                                                                                
                                                                                
                                                                            
                                                    Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
                                                    Booking_ID:globalbookingid,
                                                    Boat_Name:req.body.Boat_Name,
                                                    Total_DaysBooked:Total_Count,
                                                    WeekDay_Count:WeekDay_Count,
                                                    WeekEnd_Count: WeekEnd_Count,
                                                    calendarId:mongoose.Types.ObjectId(req.body.calendarId),
                                                    title:req.body.title,
                                                    body:req.body.body,
                                                    start:req.body.start,
                                                    end:req.body.end,
                                                    start_NoTime:Start_final,
                                                    end_NoTime:End_final,
                                                    goingDuration:req.body.goingDuration,
                                                    comingDuration:req.body.comingDuration,
                                                    isAllDay:req.body.isAllDay,
                                                    category:req.body.category,
                                                    dueDateClass:req.body.dueDateClass,
                                                    location:req.body.location,
                                                    attendees:req.body.attendees,
                                                    recurrenceRule:req.body.recurrenceRule,
                                                    isPending:req.body.isPending,
                                                    isFocused:req.body.isFocused,
                                                    isVisible:req.body.isVisible,
                                                    isReadOnly:req.body.isReadOnly,
                                                    isPrivate:req.body.isPrivate,
                                                    Is_StandByBooking:req.body.Is_StandByBooking,
                                                    Check_Status:req.body.Check_Status,
                                                    commends:req.body.commends,
                                                    color:req.body.color,
                                                    bgColor:req.body.bgColor,
                                                    dragBgColor:req.body.dragBgColor,
                                                    borderColor:req.body.borderColor,
                                                    customStyle:req.body.customStyle,
                                                    raw:req.body.raw,
                                                    state:req.body.state, 
                                                    User_RoleType:req.body.User_RoleType,
                                                    User_Id:mongoose.Types.ObjectId(req.body.User_Id),
                                                    Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
                                                    Status:Module_status,
                                                    IsActive: req.body.IsActive,
                                                    Current_Time:moment(Date.now()),
                                                    Updated_time: moment(Date.now()),
                                                    start_CancelledDate:StartDate_Cancelled,
                                                    end_CancelledDate:end_date_old,
                                                    Booking_Type:bookingType,
                                                    cancaledDays,
                                                    isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                    isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
                                                    
                                                    },
                                                    
                                                    function(err,data)
                                                    {
                                                    res.json({
                                                        
                                                        status:true,
                                                        message: 'The booking has been successfully created'
                                                    })
                                                    })
                                                    .catch(error => {
                                                    res.json({
                                                        message: error
                                                    })
                                                    })

                                                    }else{

                                                        res.json({
      
                                                            status:true,
                                                            message: 'You Have Already Booked Special Day'
                                                        })

                                                    }


                                                   });
                                                   
                                                   
  
  
                                              }//weekday weekend count
                                              else{
  
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
  //Add Winter Section
  }
                                        
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                      })
                                                  }
  })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
  
  
                                      
                                  });
                              })
  
  
  
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
  
                 
                          
                                            
                              })
                             
                          }
                          else
                          {

                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                         
                                             
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {
                                                  
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(async(element)=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                                
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
  },
  {new: true},
  function(err, data) {
   
   
  });
  //partial cancellation
   const getyear = new Date(Start_final);
   const Cancellationyear=getyear.getFullYear();
   var Noofcancellation=Totalday_old-Total_Count;
   let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
       console.log(error)  
       console.log(TotalCancellation)  
   })
   //partial cancellation
  
   var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
  })

 var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
  })
  var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
  })
  if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
  {
                                                  var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
                                                        //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })

  if(GetCancellationNumber.No_PartialCancellation){


      let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
  
        
            //update allocated cancellation days
  
          //reassigning
        
  
  OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
      {
      console.log(result)
      var SS_day=result.Summer_WeekDays;
      var SE_day=result.Summer_WeekEndDays;   
      
      OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
      { 
      
      Boat_Id:Boat_id,
      Owner_Id:Owner_id,
      Summer_WeekDays:SS_day-reAssignedWeekDaysCount,
      Summer_WeekEndDays:SE_day-reAssignedWeekendCount,
      IsActive:true,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
      });
      })
      
      //reassigning
      }
  

   //get days and weeks 
                                                  //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
}
else
{
  var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
  //update allocated cancellation days
        
  manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
      { 
      No_PartialCancellation:No_Of_LOA,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      });

      //update allocated cancellation days
    //reassigning
    var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
    var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;

OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
{
console.log(result)
var SS_day=result.Summer_WeekDays;
var SE_day=result.Summer_WeekEndDays;   

OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
{ 

Boat_Id:Boat_id,
Owner_Id:Owner_id,
Summer_WeekDays:SS_day-WeekdayCancelled,
Summer_WeekEndDays:SE_day-WeekEndCancelled,
IsActive:true,
Current_Time:moment(Date.now()),
Updated_time: moment(Date.now())
},

function(err, data) {

console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
});
})

//reassigning
}  
  //update Summer
     // special Day
     
       CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
          
          console.log(myflag,'Orginal value')
          console.log(hello,'Orginal Value22222')
          
  if(myflag==0)
  {
      console.log('inside if jibin')
  
          obj.map(function(objs) {   
          var specialday=objs.special_date;
          var Specialdayid=objs._id;
          var Start_final=moment(specialday);
          var Start_final_withoutTime=Start_final.startOf('day');
          console.log(Start_final_withoutTime)
          var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
      if( addspecial == true)
          {
          console.log('successs')
          }
          else{
              console.log('fail')
          }
  })
  
     // special Day
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
       
  
  }//special day
  else
  {
      res.json({
      
          status:true,
          message: 'You Have Already Booked Special Day'
      })
  }
  })
  
  }//weekday,weekend
  
  
  
                                  else
                                      {
  
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
  
  
                                       }
                              }
                              else
                              {
  
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
  
  
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                              })
  
                          }
                              })
                          
                                  }
                              
  
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                             
                                                                  //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(async(element)=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
                                               //partial cancellation
   const getyear = new Date(Start_final);
   const Cancellationyear=getyear.getFullYear();
   var Noofcancellation=Totalday_old-Total_Count;
   let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
       console.log(error)  
       console.log(TotalCancellation)  
   })
   //partial cancellation
  

   var GetAllocatedNumber=await partialCancel.findOne({IsActive:true}).catch((error)=>{ 
  })
 var GetCancellationNumber=await manageBoat.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true}).catch((error)=>{ 
  })
  var GetYearOfCancellation=await TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).catch((error)=>{ 
  })
  if(Noofcancellation>GetCancellationNumber.No_PartialCancellation||GetYearOfCancellation.Noofcancellation<GetAllocatedNumber.No_PartialCancellation)
  {
          var No_Of_LOA=Noofcancellation-GetCancellationNumber.No_PartialCancellation;
                                                         //get days and weeks 
var obj = Object();
obj.start =Start_final;
obj.end = End_final;

var datas =  getDaysInMonth_Sheduler(obj);
console.log(datas)
             var arr=[];
           
            datas.forEach(function(item) {
              Object.keys(item).forEach(function(key) {
                  arr.push(item[key]);
                console.log( item[key]);
              });
            });
console.log(arr)
var index=arr.length - 1;
var Loa_Length=No_Of_LOA;
var WeekDay_Count_edit=0;
var   WeekEnd_Count_edit=0;
while(Loa_Length>0)
{

  
  console.log(arr[index]);
  let day = arr[index];

  if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
      WeekDay_Count_edit=WeekDay_Count_edit+1;
    
  }
  else
  {
      WeekEnd_Count_edit= WeekEnd_Count_edit+1;

  }

  Loa_Length--;
  index--;
}
var WeekDay_Count_edits=WeekDay_Count_edit;
var WeekEnd_Count_edits=WeekEnd_Count_edit;

Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
{ 

  WeekDay_Count_Edit:WeekDay_Count_edits,
  WeekEnd_Count_Edit:WeekEnd_Count_edits,
  Total_Edit_Loa:No_Of_LOA,
  PartialCancellation_Status:1,
  Updated_time: moment(Date.now()),

},

  function(err, data) {
  })

  if(GetCancellationNumber.No_PartialCancellation){



      let {reAssignedWeekDaysCount,reAssignedWeekendCount} = getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner(Start_final,end_date_old,Noofcancellation)
  
  
            //update allocated cancellation days
  
          //reassigning
        
  
  OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
      {
      console.log(result)
     
      var WS_day=result.Winter_WeekDays;
      var WE_day=result.Winter_WeekEndDays;   
      
      OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
      { 
      
      Boat_Id:Boat_id,
      Owner_Id:Owner_id,
      Winter_WeekDays:WS_day-reAssignedWeekDaysCount,
  Winter_WeekEndDays:WE_day-reAssignedWeekendCount,
      IsActive:true,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now())
      },
      
      function(err, data) {
      
      console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
      });
      })
      
      //reassigning
      }


   //get days and weeks 
                                                   //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:0,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
                                            
                                          }
                                          else
                                          {
                                              var No_Of_LOA=GetCancellationNumber.No_PartialCancellation-Noofcancellation;
                                              //update allocated cancellation days
        
      manageBoat.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,IsActive:true},
          { 
          No_PartialCancellation:No_Of_LOA,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now())
          },
          
          function(err, data) {
          
          });
  
          //update allocated cancellation days
                                              //reassigning
                                              var WeekdayCancelled=Weekdays_prev-WeekDay_Count;
                                              var WeekEndCancelled=WeekEndDays_prev-WeekEnd_Count;
                                      
                                      OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                                          {
                                          console.log(result)
                                          var WS_day=result.Winter_WeekDays;
                                          var WE_day=result.Winter_WeekEndDays;   
                                          
                                          OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
                                          { 
                                          
                                          Boat_Id:Boat_id,
                                          Owner_Id:Owner_id,
                                          Winter_WeekDays:WS_day-WeekdayCancelled,
                                          Winter_WeekEndDays:WE_day-WeekEndCancelled,
                                          IsActive:true,
                                          Current_Time:moment(Date.now()),
                                          Updated_time: moment(Date.now())
                                          },
                                          
                                          function(err, data) {
                                          
                                          console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                                          });
                                          })
                                          
                                          //reassigning
                                          }  
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  WeekDay_Count:WeekDay_Count,
  WeekEnd_Count: WeekEnd_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  start_CancelledDate:StartDate_Cancelled,
  end_CancelledDate:end_date_old,
  Booking_Type:bookingType,
  cancaledDays,
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err,data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
  .catch(error => {
  res.json({
      message: error
  })
  })
  
                                              }//weekday weekend count
                                              else{
  
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
  //Add Winter Section
  }
                                        
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                      })
                                                  }
  })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
  
  
                                      
                                  });
                              })

                          }
                          })
                    
              
                   
                      });//else inside function owner
  
  
                  
  
                  });
              })
                  }
  
                
                  
              }
  
  //special Day
  
              
          }
          else
          {
            res.json({
                  status:false,
                  message: 'Cannot Edit Previous Day Bookings'
              })
          }
      }
          else
          {
  
              res.json({
                  status:false,
                  message: 'Boat Selected is not Active'
              })
  
          }
     
      });
  
         
          })
} 
if(Back_to_Back_id=="1")
{
  console.log(Back_to_Back_id,'bcktobck1')
       Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(BookingResponse=>
          { 
              console.log(BookingResponse)
              var globalbookingid=BookingResponse.Booking_ID;
              var Startdate_old=BookingResponse.start;
              var start_Date=Startdate_old;   
              console.log(start_Date)
              var Start_final=moment(start_Date);
              console.log(Start_final,'checkkkk4')
              var Start_final_withoutTime=Start_final.startOf('day');
              var Totalday_old=BookingResponse. Total_DaysBooked;
              var Total_Count=Totalday_old+Total_Count_New;
              var end_Date=end_Date_New;
              var End_final=moment(end_Date);
              var End_final_withoutTime=End_final.startOf('day');
              const Getmonth = new Date(Startdate_old);
             var LaunchPreMonth=Getmonth.toLocaleString('default', { month: 'long' });
       
       Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
          .then(boatDetails=> {
            
       if(boatDetails.Boat_Status=="1")//check whether boat is Active or not
       {
           //between Launch And PreLuanch
           if(dif>=0)
           {
           
           if(check_Status=="1" && specialDayCheck==0)
           { 
              
               NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
               .then(OwnerDetails=> {    
             
              Schedule.find({Boat_Id:Boat_id,IsActive:true,User_Id:Owner_id,Check_Status:check_Status,Check_Month:LaunchPreMonth}).then(Checkresult=>
                  {
                      console.log(Checkresult.length,'length')
                      // var _LengthCheck=Checkresult.length;                           
                      
               console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh') 
              PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id}).then(bookingDays=>
                  
                  {
                     
                     var b_days=bookingDays.Booking_Days;
                     console.log(b_days)
                     console.log(Total_Count)
               if(Total_Count<=b_days)
               {
              console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii')
               
              
                Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                    {
                      
                        console.log(result.length,'length')
                       // var _Length=result.length;
                       
                           Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                
                           console.log('hi1')
                           Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                               {
                               
                                  console.log('hi2')
                                   Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                       {
                                          console.log(Start_final_withoutTime);
                                          console.log(End_final_withoutTime);
                                       if(results==null)
                                       {
                                          console.log('hi3')    
                                    
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state,
  Check_Status:req.body.Check_Status, 
  commends:req.body.commends,
  Check_Month:LaunchPreMonth,
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
},
    
async function(err, data) {

   /* console.log("PartialEntry Back to back id 1::::::::check status::1");

  // Raga partial cancellation
  const getyear = new Date(Start_final);
  const Cancellationyear=getyear.getFullYear();
  
  var Noofcancellation=Totalday_old-Total_Count;
 
  let TotalCancellation =await TotalCancellations(Boat_id,Owner_id,Noofcancellation,Cancellationyear).catch((error)=>{
      console.log(error)  
      console.log(TotalCancellation)  
  })*/
  // Raga partial cancellation
 



  console.log(data,'successs')
  
      //mail
   
      const emailState =  'Successfully Edited.';
      const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
      const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
      const emailDetailName = 'Booking Details'
      const emailDetails = [
        { key: 'Boat Name', value:  boatDetails.Boat_Name},
        { key: 'Booking Date', value: getCurrentTimeFormatted() },
      ];
      const emailNameAndLink = {
        name:'Login Link',
        link:`${process.env.CLIENT_URL}/boat-bookings`
      }
      
      var mailOptions = {
         
          from:"noreply.smartboatbooking@gmail.com",
          to: OwnerDetails.Email,
          //to: "bjibin3@gmail.com",
          subject: 'Successfully Edited',
          html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
          
      };
      
      transporter.sendMail(mailOptions, function (error, info) {
         
      });           
      
      var mailOptionsAdmin = {
         
          from:"noreply.smartboatbooking@gmail.com",
           to: "admin@smartboating.com.au",
           subject: 'Successfully Edited',
           html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
      };
      
      transporter.sendMail(mailOptionsAdmin, function (error, info) {
      
         
          
      }); 
      //mail
  
  res.json({
     
  status:true,
  message: 'The booking has been successfully Updated'
  })
 
})  
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
  

     
}) 
                       
                      
                   })
                       
                      
  })
  
           }
           else
           {
              res.json({
  
                  status:true,
                  message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date'
              })
           }
          })
      
      
  })
})
              
              
           }
  
           //between Launch And PreLaunch
  
  
           //After Launch before current date
  
           if(check_Status=="2" && specialDayCheck==0)
           {
              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
  
                  Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                      {
  
                          if(Cancelresults==null)
                          {
                       
  
              Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                  {
                                         
                      console.log(result.length,'length')
                     // var _Length=result.length;
                     
                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                              {
                              
                                 
                              Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                  {
                                  
  
                                 Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                          {
                                              
                                          if(results==null)
                                          {
                                      
                             
  
                          Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                              {  
                                  var SummerWeekdays=response.Summer_WeekDays;
                                  var SummerWeekendDays=response.Summer_WeekEndDays;
                                  var  WinterWeekDays=response.Winter_WeekDays;
                                  var WinterweekendDays=response.Winter_WeekEndDays;

                                  //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                  
                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                      {
                                     
                                         
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {
                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return

  console.log('inside Summerrrrrrrrrrrrrrrrrrrrrrrrr')
                                                                        
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                              
  
                                              if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                              {
  
                                           
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                            
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
  
  },
  {new: true},
  function(err, data) {
  
  
  });
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  console.log(x)
   
           
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
 
   //mail
 
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)             
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
                                }//weekday,weekend
                              else
                                  {
  
                                   res.json({
                                  status:false,
                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                            })
  
  
                                   }
                          }
                          else
                          {
  
                              res.json({
                                  status:false,
                                  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                              })
  
  
                          }
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'Consecutive days for this boat is Empty'
                          })
  
                      }
                          })
                      
                              }
                          
  
                  
                                  else
                                  {
                                      //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                          {
                                         console.log(BoatresultsWinter);
  
                                   //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {

                                                              //check if next booking included

                                                              let isNextDaysError = false
                                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                                   isNextDaysError = true
                                                                   return res.json(error)
                                                              })
                      
                                                              
                                                               if(isNextDaysError) return

                                          console.log('inside Winterrrrrrrrrrrrrrrrrrrrrrrrrr')
                                      
                                  
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                      if(element.Winter_ConsecutiveDays>=Total_Count)
                                      {
                                   
                                          if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                          {
                                          
                                               // for updating Summer days
                                               Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                               {   
                                                                                
                                                  Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                  Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                   
                                               },
                                               {new: true},
                                               function(err, data) {
                                                   
                                                   
                                               });
                                          
                                               var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                               console.log(x)
                                                
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
 
  
                                          }//weekday weekend count
                                          else{
  
                                              res.json({
                                                  status:false,
                                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                      })
      
      
                                                   
                                          }
  //Add Winter Section
  }
                                    
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                              }
                                              else
                                              {
                                                res.json({
                                                      status:false,
                                                      message: 'Consecutive days for this boat is Empty'
                                                  })
                                              }
  })                                     }
                                else
                                {
                                  res.json({
                                      status:false,
                                      message: 'These Dates Are not Allowed for Booking'
                                  })
                                }
                              })
                              }//else
  
  
                                  
                              });
                          })
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
                                        
                          })
                          
                          
  
                      })
                  
                 
          
               
                  });//else inside function owner
  
  
              
             
  
              });
  
          }
          else
          {
    
              console.log(Start_final_withoutTime)
              console.log(End_final_withoutTime)
              console.log(Cancelresults.Updated_time,'thissssssssss')
              var todaysdate=moment();
              console.log(todaysdate)
              var canceldate =moment(Cancelresults.Updated_time)
              var dif=moment.duration(todaysdate.diff(canceldate));
              console.log(dif.asHours());
              var Hrdif=Math.round(dif.asHours());
          
              console.log(Hrdif);
  
  
              if(Hrdif>24)
  
              {
                 
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                     
      
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                          
                                 
      
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                         
                                             
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {
      
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
      {
      
      // for updating Summer days
      Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
      {   
                                
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
      
      },
      {new: true},
      function(err, data) {
      
      
      });
      
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
     
               
      
      
      //Add Summer Section
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
  },
  
  function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
                                 }//weekday,weekend
                                  else
                                      {
      
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
      
      
                                       }
                              }
                              else
                              {
      
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
      
      
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'Consecutive days for this boat is Empty'
                              })
      
                          }
                              })
                          
                                  }
                              
      
                      
                                      else
                                      {

                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
      
                                        //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                             
                                                                  //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   console.log(x)
                                                  
      //Add Winter Section
      
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
      end:req.body.end,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
      },
      
      function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
      
      
                                              }//weekday weekend count
                                              else{
      
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
      //Add Winter Section
      }
                                        
      else
      {
      
      res.json({
      status:false,
      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
      
      }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'Consecutive days for this boat is Empty'
                                                      })
                                                  }
      })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
      
      
                                      
                                  });
                              })
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
                                            
                              })
                             
      
                          })
                      
              
                   
                      });//else inside function owner
      
      
                 
      
                  });
              }
                 else
                 {
                      res.json({
                      status:false,
                      message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                  })
                 } 
  
          }
      })
  })
  
         
           }
           
  
  
          //between Launch And PreLuanch
          if(check_Status=="3" && specialDayCheck==0)
          {
            
                          
                             
                             if(User_role=='Admin')//for Admin
                             {
                               Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                                   {
                                     
                                       console.log(result.length,'length')
                                       var _Length=result.length;
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                              {
                                              
                                          
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
                                                  Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                                                      
                                                   
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                      
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
       end:req.body.end,
       start_NoTime:Start_final_withoutTime,
       end_NoTime:End_final_withoutTime,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now())
  
  },
  
  function(err, data) {
  
  //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }     
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
       res.json({
           
           status:true,
           message: 'The admin booking has been successfully Updated'
       })
   })
   
        
  }
  else
  {
      res.json({
              
          status:true,
          message: 'An existing booking already exists for this date. A new booking cannot be created.'
      })
  
  }
  
  
  
  })
  //Add
  
   
}) 
                                      
                                    
                                  })
                                      
                                      
   })
  }
  
                          else//For Owner
                          {
                              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
                              Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                                  {
  
                                      if(Cancelresults==null)
                                      {
  
                                 
  console.log(Cancelresults,'cancellation rewsulttttt')
                                 
                     
                             
                            Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                          
                                             
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
  
                                             Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
     
                                                     
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {
                                                          
                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
    
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
  
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
      })
                                    }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                                 //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                     
                                                                          //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                            
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)           
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
     
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                              
                             
                      
                           
                              });//else inside function owner
  
  
                          
  
                          });
                      }
                      else
                      {
  
                          //
                      
                      console.log(Start_final_withoutTime)
                      console.log(End_final_withoutTime)
                      console.log(Cancelresults.Updated_time,'thissssssssss')
                      var todaysdate=moment();
                      console.log(todaysdate)
                      var canceldate =moment(Cancelresults.Updated_time)
                      var dif=moment.duration(todaysdate.diff(canceldate));
                      console.log(dif.asHours());
                      var Hrdif=Math.round(dif.asHours());
                  
                      console.log(Hrdif);
  
  
                      if(Hrdif>24)
  
                      {
                          Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                 
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                           
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
  
                                             Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                 
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {
                                                          
                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
         
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
                                   }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                                //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                     
                                                                          //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                          
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
          end:req.body.end,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
function(err, data)
{
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
})
      
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                             
                      
                           
                              });//else inside function owner
  
  
                         
  
                          });
  
                      }
                         else
                         {
                              res.json({
                              status:false,
                              message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                          })
                         } //
  
                          // res.json({
                          //     status:false,
                          //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                          // })
  
                      }
                  })
              })
                          }
  
                        
                          
                      }
  
                if(check_Status="4" && User_role=="Maintenance" )
                {
                 
  
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                        
                          console.log(result.length,'length')
                        //  var _Length=result.length;
                         
                             Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                 {
                                 
                             Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                 {
                                
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                         {
                                         if(results==null)
                                         {
                                         
                                      
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                          
         
                     
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:Start_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err, data)
{
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
          
  
  var mailOptionsAdmin = {   
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Maintainance Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
  res.json({
  
  status:true,
  message: 'The boat maintenance booking has been successfully Updated'
  })
  })
 
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
 
}) 
                         
                         
                     })
                         
  })
                 
  
                }
  
  // special Day
  if(specialDayCheck==1)
  {
    console.log("special day check Back to back 1");
   const Specialday_id=req.body.Specialday_id;
   const obj=req.body.Special_Day;
     
                  
                     
                     if(User_role=='Admin')//for Admin
                     {
                       Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                             
                               console.log(result.length,'length')
                              // var _Length=result.length;
                             
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                      {
                                      
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                              
                                           
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                               
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err,data)
{
  res.json({
   
   status:true,
   message: 'The admin booking has been successfully created'
  })
  })
  
  
  }
  else
  {
  res.json({
      
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
   }) 
                             
                          })
                             
  })
  }
  
                  else//For Owner
                  {
  
                      NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                      .then(OwnerDetails=> {
                     
                    Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
  
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                                 
                                                 
                                     
                                     
                                 
  
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;
                                      
                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},

                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                         
                                             
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {
                                                  
                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                                
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
  },
  {new: true},
  function(err, data) {
   
   
  });
  
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  console.log(x)
 
  //update Summer
     // special Day
     
       CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
          
         
          
  if(myflag==0)
  {
      console.log('Inside of Specilalday check Backto Backid 1')
  
          obj.map(function(objs) {   
          var specialday=objs.special_date;
          var Specialdayid=objs._id;
          var Start_final=moment(specialday);
          var Start_final_withoutTime=Start_final.startOf('day');
          console.log(Start_final_withoutTime)
          var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
      if( addspecial == true)
          {
          console.log('successs')
          }
          else{
              console.log('fail')
          }
  })
  
     // special Day
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
       
  
  }//special day
  else
  {
      res.json({
      
          status:true,
          message: 'You Have Already Booked Special Day'
      })
  }
  })
  
  }//weekday,weekend
  
  
  
                                  else
                                      {
  
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
  
  
                                       }
                              }
                              else
                              {
  
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
  
  
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                              })
  
                          }
                              })
                          
                                  }
                              
  
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
  
                                         //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                             
                                                                  //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(Startdate_old,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays>=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
  
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {

                                                    if(myflag==0){

                                                        obj.map(function(objs) {   
                                                            var specialday=objs.special_date;
                                                            var Specialdayid=objs._id;
                                                            var Start_final=moment(specialday);
                                                            var Start_final_withoutTime=Start_final.startOf('day');
                                                            console.log(Start_final_withoutTime)
                                                            var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                                        if( addspecial == true)
                                                            {
                                                            console.log('successs')
                                                            }
                                                            else{
                                                                console.log('fail')
                                                            }
                                                    });

                                                     //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:req.body.end,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err,data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
  .catch(error => {
  res.json({
      message: error
  })
  })


                                                    }else{
                                                        res.json({
      
                                                            status:true,
                                                            message: 'You Have Already Booked Special Day'
                                                        })
                                                    }


                                                   });
                                                   
  
  
                                              }//weekday weekend count
                                              else{
  
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
  //Add Winter Section
  }
                                        
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                      })
                                                  }
  })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
  
  
                                      
                                  });
                              })
  
  
  
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
  
                 
                          
                                            
                              })
                             
  
                          })
                    
              
                   
                      });//else inside function owner
  
  
                  
  
                  });
              })
                  }
  
                
                  
              }
  
  //special Day
  
              
          }
          else
          {
              res.json({
                  status:false,
                  message: 'A booking cannot be created for a previous day'
              })
          }
      }
          else
          {
  
              res.json({
                  status:false,
                  message: 'Boat Selected is not Active'
              })
  
          }
     
      });
  
         
          })
}    
if(Back_to_Back_id=="2")
{
  console.log(Back_to_Back_id,'bcktobck2')
       Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(BookingResponse=>
          { 
              console.log(BookingResponse)
              var globalbookingid=BookingResponse.Booking_ID;
              var Startdate_old=BookingResponse.start;
              var Enddate_old=BookingResponse.end;
              var start_Date=start_Date_New;   
              var Start_final=moment(start_Date);
              console.log(Start_final,'checkkkk3')
              var Start_final_withoutTime=Start_final.startOf('day');
              var Totalday_old=BookingResponse. Total_DaysBooked;
              var Total_Count=Totalday_old+Total_Count_New;
              var end_Date=Enddate_old;
              var End_final=moment(end_Date_New);
              var End_final_withoutTime=End_final.startOf('day');
              const Getmonth = new Date(start_Date_New);
             var  LaunchPreMonth=Getmonth.toLocaleString('default', { month: 'long' });
       Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
          .then(boatDetails=> {
            
       if(boatDetails.Boat_Status=="1")//check whether boat is Active or not
       {
           //between Launch And PreLuanch
         if(dif>=0)
         {
         
           if(check_Status=="1" && specialDayCheck==0)
           { 
              
               NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
               .then(OwnerDetails=> {    
             
              Schedule.find({Boat_Id:Boat_id,IsActive:true,User_Id:Owner_id,Check_Status:check_Status,Check_Month:LaunchPreMonth}).then(Checkresult=>
                  {
                      console.log(Checkresult.length,'length')
                      // var _LengthCheck=Checkresult.length;                           
                      
               console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh') 
              PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id}).then(bookingDays=>
                  
                  {
                     
                     var b_days=bookingDays.Booking_Days;
                     console.log(b_days)
                     console.log(Total_Count)
               if(Total_Count<=b_days)
               {
              console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii')
               
              
                Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                    {
                      
                        console.log(result.length,'length')
                       // var _Length=result.length;
                       
                           Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                
                           console.log('hi1')
                           Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                               {
                               
                                  console.log('hi2')
                                   Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                       {
                                          console.log(Start_final_withoutTime);
                                          console.log(End_final_withoutTime);
                                       if(results==null)
                                       {
                                          console.log('hi3')    
                                    
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state,
  Check_Status:req.body.Check_Status, 
  commends:req.body.commends,
  Check_Month:LaunchPreMonth,
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
},
    
function(err, data) {
  console.log(data,'successs')
  
      //mail

      const emailState =  'Successfully Edited.';
      const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
      const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
      const emailDetailName = 'Booking Details'
      const emailDetails = [
        { key: 'Boat Name', value:  boatDetails.Boat_Name},
        { key: 'Booking Date', value: getCurrentTimeFormatted() },
      ];
      const emailNameAndLink = {
        name:'Login Link',
        link:`${process.env.CLIENT_URL}/boat-bookings`
      }

      var mailOptions = {
         
          from:"noreply.smartboatbooking@gmail.com",
          to: OwnerDetails.Email,
          //to: "bjibin3@gmail.com",
          subject: 'Successfully Edited',
          html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)            
          
          
      };
      
      transporter.sendMail(mailOptions, function (error, info) {
         
      });           
      
      var mailOptionsAdmin = {
         
          from:"noreply.smartboatbooking@gmail.com",
           to: "admin@smartboating.com.au",
           subject: 'Successfully Edited',
           html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
      };
      
      transporter.sendMail(mailOptionsAdmin, function (error, info) {
      
         
          
      }); 
      //mail
  
  res.json({
     
  status:true,
  message: 'The booking has been successfully Updated'
  })
 
})  
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
  

     
}) 
                       
                      
                   })
                       
                      
  })
  
           }
           else
           {
              res.json({
  
                  status:true,
                  message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date'
              })
           }
          })
      
      
  })
})
              
              
           }
  
           //between Launch And PreLaunch
  
  
           //After Launch before current date
  
           if(check_Status=="2" && specialDayCheck==0)
           {
              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
  
                  Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                      {
  
                          if(Cancelresults==null)
                          {
                       
  
              Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                  {
                                         
                      console.log(result.length,'length')
                     // var _Length=result.length;
                     
                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                              {
                              
                                 
                              Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                  {
                                  
  
                                 Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                          {
                                              
                                          if(results==null)
                                          {
                                      
                             
  
                          Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                              {  
                                  var SummerWeekdays=response.Summer_WeekDays;
                                  var SummerWeekendDays=response.Summer_WeekEndDays;
                                  var  WinterWeekDays=response.Winter_WeekDays;
                                  var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                  
                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                      {
                                      
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {
                                              
                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                        
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                              
  
                                              if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                              {
  
                                           
  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                            
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
  
  },
  {new: true},
  function(err, data) {
  
  
  });
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  console.log(x)
 
           
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
 
   //mail
 
          const emailState =  'Successfully Edited.';
          const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
          const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
          const emailDetailName = 'Booking Details'
          const emailDetails = [
            { key: 'Boat Name', value:  boatDetails.Boat_Name},
            { key: 'Booking Date', value: getCurrentTimeFormatted() },
          ];
          const emailNameAndLink = {
            name:'Login Link',
            link:`${process.env.CLIENT_URL}/boat-bookings`
          }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)          
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
                                }//weekday,weekend
                              else
                                  {
  
                                   res.json({
                                  status:false,
                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                            })
  
  
                                   }
                          }
                          else
                          {
  
                              res.json({
                                  status:false,
                                  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                              })
  
  
                          }
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'Consecutive days for this boat is Empty'
                          })
  
                      }
                          })
                      
                              }
                          
  
                  
                                  else
                                  {
                                      //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                          {
                                         console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                                              //check if next booking included

                                                              let isNextDaysError = false
                                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                                   isNextDaysError = true
                                                                   return res.json(error)
                                                              })
                      
                                                              
                                                               if(isNextDaysError) return
                                  
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                      if(element.Winter_ConsecutiveDays>=Total_Count)
                                      {
                                   
                                          if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                          {
                                          
                                               // for updating Summer days
                                               Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                               {   
                                                                                
                                                  Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                  Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                   
                                               },
                                               {new: true},
                                               function(err, data) {
                                                   
                                                   
                                               });
                                          
                                               var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                               console.log(x)
                                               
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)             
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
 
  
                                          }//weekday weekend count
                                          else{
  
                                              res.json({
                                                  status:false,
                                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                      })
      
      
                                                   
                                          }
  //Add Winter Section
  }
                                    
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                              }
                                              else
                                              {
                                                res.json({
                                                      status:false,
                                                      message: 'Consecutive days for this boat is Empty'
                                                  })
                                              }
  })                                     }
                                else
                                {
                                  res.json({
                                      status:false,
                                      message: 'These Dates Are not Allowed for Booking'
                                  })
                                }
                              })
                              }//else
  
  
                                  
                              });
                          })
                      }
                      else
                      {
                          res.json({
                              status:false,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
                                        
                          })
                          
                          
  
                      })
                  
                 
          
               
                  });//else inside function owner
  
  
              
             
  
              });
  
          }
          else
          {
    
              console.log(Start_final_withoutTime)
              console.log(End_final_withoutTime)
              console.log(Cancelresults.Updated_time,'thissssssssss')
              var todaysdate=moment();
              console.log(todaysdate)
              var canceldate =moment(Cancelresults.Updated_time)
              var dif=moment.duration(todaysdate.diff(canceldate));
              console.log(dif.asHours());
              var Hrdif=Math.round(dif.asHours());
          
              console.log(Hrdif);
  
  
              if(Hrdif>24)
  
              {
                 
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                     
      
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                          
                                 
      
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                          console.log(Boatresults)
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {
                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
      {
      
      // for updating Summer days
      Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
      {   
                                
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
      
      },
      {new: true},
      function(err, data) {
      
      
      });
      
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
               
      
      
      //Add Summer Section
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:Enddate_old,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
  },
  
  function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
                                 }//weekday,weekend
                                  else
                                      {
      
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
      
      
                                       }
                              }
                              else
                              {
      
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
      
      
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'Consecutive days for this boat is Empty'
                              })
      
                          }
                              })
                          
                                  }
                              
      
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
       //list all winter start and end date of  owne  based on owner duration  duration which include all year

       let stopExecution = {stop:false}
       let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
         console.log(error)
         stopExecution = error
     })

     if(stopExecution.stop){
         return res.json({status:true,message:stopExecution.error})
     }
               

   
                     if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                     {
                                        
                                              //check if next booking included

                                              let isNextDaysError = false
                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                   isNextDaysError = true
                                                   return res.json(error)
                                              })
      
                                              
                                               if(isNextDaysError) return
                                          
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   console.log(x)
                                                 
      //Add Winter Section
      
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:Enddate_old,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
      },
      
      function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
      
      
                                              }//weekday weekend count
                                              else{
      
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
      //Add Winter Section
      }
                                        
      else
      {
      
      res.json({
      status:false,
      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
      
      }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'Consecutive days for this boat is Empty'
                                                      })
                                                  }
      })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
      
      
                                      
                                  });
                              })
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
                                            
                              })
                             
      
                          })
                      
              
                   
                      });//else inside function owner
      
      
                 
      
                  });
              }
                 else
                 {
                      res.json({
                      status:false,
                      message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                  })
                 } 
  
          }
      })
  })
  
         
           }
           
  
  
          //between Launch And PreLuanch
          if(check_Status=="3" && specialDayCheck==0)
          {
            
                          
                             
                             if(User_role=='Admin')//for Admin
                             {
                               Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                                   {
                                     
                                       console.log(result.length,'length')
                                       var _Length=result.length;
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                              {
                                              
                                          
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
                                                  Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                                                      
                                                   
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                      
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:req.body.start,
      end:Enddate_old,
       start_NoTime:Start_final_withoutTime,
       end_NoTime:End_final_withoutTime,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now())
  
  },
  
  function(err, data) {
  
  //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
            
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
       res.json({
           
           status:true,
           message: 'The admin booking has been successfully Updated'
       })
   })
   
        
  }
  else
  {
      res.json({
              
          status:true,
          message: 'An existing booking already exists for this date. A new booking cannot be created.'
      })
  
  }
  
  
  
  })
  //Add
  
   
}) 
                                      
                                    
                                  })
                                      
                                      
   })
  }
  
                          else//For Owner
                          {
                              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
                              Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                                  {
  
                                      if(Cancelresults==null)
                                      {
  
                                 
  console.log(Cancelresults,'cancellation rewsulttttt')
                                 
                     
                             
                            Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                          
                                             
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
  
                                             Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                  console.log(Boatresults)
                                                  let stopExecution = {stop:false}
                                                  let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                      console.log(error)
                                                      stopExecution = error
                                                  })
                          
                          
                                                  if(stopExecution.stop){
                                                      return res.json({status:true,message:stopExecution.error})
                                                  }
                          
                                                  if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                  {

                                                       //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
  
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
    
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
         end:Enddate_old,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
  
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)           
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
      })
                                    }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                               //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                              //check if next booking included

                                                              let isNextDaysError = false
                                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                                   isNextDaysError = true
                                                                   return res.json(error)
                                                              })
                      
                                                              
                                                               if(isNextDaysError) return
                                                     
                                                  
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                           
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
         end:Enddate_old,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
   //mail
 
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)             
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
     
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                              
                             
                      
                           
                              });//else inside function owner
  
  
                          
  
                          });
                      }
                      else
                      {
  
                          //
                      
                      console.log(Start_final_withoutTime)
                      console.log(End_final_withoutTime)
                      console.log(Cancelresults.Updated_time,'thissssssssss')
                      var todaysdate=moment();
                      console.log(todaysdate)
                      var canceldate =moment(Cancelresults.Updated_time)
                      var dif=moment.duration(todaysdate.diff(canceldate));
                      console.log(dif.asHours());
                      var Hrdif=Math.round(dif.asHours());
                  
                      console.log(Hrdif);
  
  
                      if(Hrdif>24)
  
                      {
                          Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                 
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                           
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
  
                                             Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                  
                                                     
                                                      let stopExecution = {stop:false}
                                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                          console.log(error)
                                                          stopExecution = error
                                                      })
                              
                              
                                                      if(stopExecution.stop){
                                                          return res.json({status:true,message:stopExecution.error})
                                                      }
                              
                                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                      {
  
                                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
       //update Summer
                       
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
         
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
         end:Enddate_old,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
                                   }//weekday,weekend
                                          else
                                              {
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
   //list all winter start and end date of  owne  based on owner duration  duration which include all year

   let stopExecution = {stop:false}
   let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
     console.log(error)
     stopExecution = error
 })

 if(stopExecution.stop){
     return res.json({status:true,message:stopExecution.error})
 }
           


                 if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                 {
                                                 
                                          //check if next booking included

                                          let isNextDaysError = false
                                          let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                               isNextDaysError = true
                                               return res.json(error)
                                          })
  
                                          
                                           if(isNextDaysError) return
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                           
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:req.body.start,
         end:Enddate_old,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
function(err, data)
{
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
})
      
  
                                                      }//weekday weekend count
                                                      else{
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                             
                      
                           
                              });//else inside function owner
  
  
                         
  
                          });
  
                      }
                         else
                         {
                              res.json({
                              status:false,
                              message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                          })
                         } //
  
                          // res.json({
                          //     status:false,
                          //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                          // })
  
                      }
                  })
              })
                          }
  
                        
                          
                      }
  
                if(check_Status="4" && User_role=="Maintenance" )
                {
                 
  
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                        
                          console.log(result.length,'length')
                        //  var _Length=result.length;
                         
                             Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                 {
                                 
                             Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                 {
                                
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$gte:Start_final_withoutTime_New}},{end:{$lte:End_final_withoutTime_New}}]}).then(results=>
                                         {
                                         if(results==null)
                                         {
                                         
                                      
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                          
         
                     
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:Start_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err, data)
{
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
          
  
  var mailOptionsAdmin = {   
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Maintainance Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
  res.json({
  
  status:true,
  message: 'The boat maintenance booking has been successfully Updated'
  })
  })
 
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
 
}) 
                         
                         
                     })
                         
  })
                 
  
                }
  
  // special Day
  if(specialDayCheck==1)
  {
    console.log("special day check back to back id 2");
   const Specialday_id=req.body.Specialday_id;
   const obj=req.body.Special_Day;
     
                  
                     
                     if(User_role=='Admin')//for Admin
                     {
                       Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                             
                               console.log(result.length,'length')
                              // var _Length=result.length;
                             
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                      {
                                      
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                              
                                           
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                               
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err,data)
{
  res.json({
   
   status:true,
   message: 'The admin booking has been successfully created'
  })
  })
  
  
  }
  else
  {
  res.json({
      
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
   }) 
                             
                          })
                             
  })
  }
  
                  else//For Owner
                  {
  
                      NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                      .then(OwnerDetails=> {
                     
                    Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
  
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                                 
                                                 
                                     
                                     
                                 
  
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                          
                                              let stopExecution = {stop:false}
                                              let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                  console.log(error)
                                                  stopExecution = error
                                              })
                      
                      
                                              if(stopExecution.stop){
                                                  return res.json({status:true,message:stopExecution.error})
                                              }
                      
                                              if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                              {

                                                   //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
  
if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                                
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
  },
  {new: true},
  function(err, data) {
   
   
  });
  
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  
 
  //update Summer
     // special Day
     
       CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
          
          
          
  if(myflag==0)
  {
      console.log('inside OF Special day check back to back 2')
  
          obj.map(function(objs) {   
          var specialday=objs.special_date;
          var Specialdayid=objs._id;
          var Start_final=moment(specialday);
          var Start_final_withoutTime=Start_final.startOf('day');
          console.log(Start_final_withoutTime)
          var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
      if( addspecial == true)
          {
          console.log('successs')
          }
          else{
              console.log('fail')
          }
  })
  
     // special Day
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
       
  
  }//special day
  else
  {
      res.json({
      
          status:true,
          message: 'You Have Already Booked Special Day'
      })
  }
  })
  
  }//weekday,weekend
  
  
  
                                  else
                                      {
  
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
  
  
                                       }
                              }
                              else
                              {
  
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
  
  
                              }
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                              })
  
                          }
                              })
                          
                                  }
                              
  
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
  
                                          //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                                     //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                          
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
  
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag){

                                                    if(myflag==0){

                                                        obj.map(function(objs) {   
                                                            var specialday=objs.special_date;
                                                            var Specialdayid=objs._id;
                                                            var Start_final=moment(specialday);
                                                            var Start_final_withoutTime=Start_final.startOf('day');
                                                            console.log(Start_final_withoutTime)
                                                            var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                                        if( addspecial == true)
                                                            {
                                                            console.log('successs')
                                                            }
                                                            else{
                                                                console.log('fail')
                                                            }
                                                        });
                                                        

                                                    }else{

                                                        res.json({
      
                                                            status:true,
                                                            message: 'You Have Already Booked Special Day'
                                                        })

                                                    }

                                                   });

                                                    //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:req.body.start,
  end:Enddate_old,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err,data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
  .catch(error => {
  res.json({
      message: error
  })
  })
  
                                                   
  
                                              }//weekday weekend count
                                              else{
  
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
  //Add Winter Section
  }
                                        
  else
  {
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                                  }
                                                  else
                                                  {
                                                    res.json({
                                                          status:false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                      })
                                                  }
  })                                     }
                                    else
                                    {
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
  
  
                                      
                                  });
                              })
  
  
  
                          }
                          else
                          {
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
  
                 
                          
                                            
                              })
                             
  
                          })
                    
              
                   
                      });//else inside function owner
  
  
                  
  
                  });
              })
                  }
  
                
                  
              }
  
  //special Day
  
              
          }
          else
          {
              res.json({
                  status:false,
                  message: 'A booking cannot be created for a previous day'
              })
          }
      }
          else
          {
  
              res.json({
                  status:false,
                  message: 'Boat Selected is not Active'
              })
  
          }
     
      });
  
         
          })
} 
if(Back_to_Back_id=="3")
{console.log("RAAAAAAAAAA");
  console.log(Back_to_Back_id,'bcktobck3')

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:false,
  delStatus:1,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
       Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(BookingResponse=>
          { 
              Schedule.findById({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}).then(BacktoResponse=>
                  { 
              var BacktoTotal=BacktoResponse.Total_DaysBooked;
                 

              console.log(BookingResponse)
              var globalbookingid=BookingResponse.Booking_ID;
              var Startdate_old=BookingResponse.start;
              var Enddate_old=BookingResponse.end;
              var start_Date=Startdate_old;   
              console.log(start_Date)
              var Start_final=moment(start_Date);
              console.log(Start_final,'checkkkk2')
              var Start_final_withoutTime=Start_final.startOf('day');
              var Totalday_old=BookingResponse.Total_DaysBooked;
              var Total_Count=Totalday_old+Total_Count_New+BacktoTotal;
              var end_Date=end_Date_New;
              var End_final=moment(end_Date);
              var End_final_withoutTime=End_final.startOf('day');
              const Getmonth = new Date(Startdate_old);
             var  LaunchPreMonth=Getmonth.toLocaleString('default', { month: 'long' });

                      console.log(Total_Count,"Total_Count")

                      console.log(Totalday_old,"Totalday_old")

                      console.log(Total_Count_New,"Total_Count_New")

                      console.log(BacktoTotal,"BacktoTotal")


       Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
          .then(boatDetails=> {
            
       if(boatDetails.Boat_Status=="1")//check whether boat is Active or not
       {
           //between Launch And PreLuanch
  if(dif>=0)
  {

           if(check_Status=="1" && specialDayCheck==0)
           { 
              
               NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
               .then(OwnerDetails=> {    
             
              Schedule.find({Boat_Id:Boat_id,IsActive:true,User_Id:Owner_id,Check_Status:check_Status,Check_Month:LaunchPreMonth}).then(Checkresult=>
                  {
                      console.log(Checkresult.length,'length')
                      // var _LengthCheck=Checkresult.length;                           
                      
               console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh') 
              PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id}).then(bookingDays=>
                  
                  {
                     
                     var b_days=bookingDays.Booking_Days;
                     console.log("Booking_Days::"+b_days)
                     console.log("Total_Count:::"+Total_Count)
                     /* Edited By RAGA 29-10-21 repalce if(Total_Count<=b_days)*/
               if(Total_Count_New<=b_days)
               {
              console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii')
               
              
                Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                    {
                      
                        console.log(result.length,'length')
                       // var _Length=result.length;
                       
                           Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                               {
                                
                         
                           Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                               {
                               
                                /*let allDaysBookedThree = getDaysBetweenDates(start_Date_New,end_Date_New);

                                let arrayofBookThree = [];

                                arrayofBookThree.map((date)=> arrayofBookThree.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));*/


                                  //Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$or:arrayofBookThree}).then(results=>
                                    Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                       {
                                          console.log(Start_final_withoutTime);
                                          console.log(End_final_withoutTime);
                                       if(results==null)
                                       {
                                          
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state,
  Check_Status:req.body.Check_Status, 
  commends:req.body.commends,
  Check_Month:LaunchPreMonth,
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
},
    
function(err, data) {
  console.log(data,'successs')
  
      //mail
 
      const emailState =  'Successfully Edited.';
      const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
      const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
      const emailDetailName = 'Booking Details'
      const emailDetails = [
        { key: 'Boat Name', value:  boatDetails.Boat_Name},
        { key: 'Booking Date', value: getCurrentTimeFormatted() },
      ];
      const emailNameAndLink = {
        name:'Login Link',
        link:`${process.env.CLIENT_URL}/boat-bookings`
      }
      
      var mailOptions = {
         
          from:"noreply.smartboatbooking@gmail.com",
          to: OwnerDetails.Email,
          //to: "bjibin3@gmail.com",
          subject: 'Successfully Edited',
          html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)            
          
          
      };
      
      transporter.sendMail(mailOptions, function (error, info) {
         
      });           
      
      var mailOptionsAdmin = {
         
          from:"noreply.smartboatbooking@gmail.com",
           to: "admin@smartboating.com.au",
           subject: 'Successfully Edited',
           html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
      };
      
      transporter.sendMail(mailOptionsAdmin, function (error, info) {
      
         
          
      }); 
      //mail
  
  res.json({
     
  status:true,
  message: 'The booking has been successfully Updated'
  })
 
})  
  }
  else
  {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 

  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
  

     
}) 
                       
                      
                   })
                       
                      
  })
  
           }
           else
           {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 

              res.json({
  
                  status:true,
                  message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date'
              })
           }
          })
      
      
  })
})
              
              
           }
  
           //between Launch And PreLaunch
  
  
           //After Launch before current date
  
           if(check_Status=="2" && specialDayCheck==0)
           {
              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
  
                  Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                      {
  
                          if(Cancelresults==null)
                          {
                       
  
              Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                  {
                                         
                      console.log(result.length,'length')
                     // var _Length=result.length;
                     
                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                              {
                              
                                 
                              Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                  {
                                    let allDaysBookedZero = getDaysBetweenDates(start_Date_New,end_Date_New);
  
                                 Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                          {
                                              
                                          if(results==null)
                                          {
                                      
                             
  
                          Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                              {  
                                  var SummerWeekdays=response.Summer_WeekDays;
                                  var SummerWeekendDays=response.Summer_WeekEndDays;
                                  var  WinterWeekDays=response.Winter_WeekDays;
                                  var WinterweekendDays=response.Winter_WeekEndDays;

                                  //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                  
                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                      {
                                      console.log(Boatresults)
                                      let stopExecution = {stop:false}
                                      let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                          console.log(error)
                                          stopExecution = error
                                      })
              
              
                                      if(stopExecution.stop){
                                          return res.json({status:true,message:stopExecution.error})
                                      }
              
                                      if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                      {

                                           //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                        
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                              
  
                                              if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                              {
  
                                           
                                                  if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                            
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
  
  },
  {new: true},
  function(err, data) {
  
  
  });
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  console.log(x)
  
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
 
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)          
      
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
                                }//weekday,weekend
                              else
                                  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
                                   res.json({
                                  status:false,
                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                            })
  
  
                                   }
                          }
                          else
                          {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
                              res.json({
                                  status:false,
                                  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                              })
  
  
                          }
                      }
                      else
                      {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                          res.json({
                              status:false,
                              message: 'Consecutive days for this boat is Empty'
                          })
  
                      }
                          })
                      
                              }
                          
  
                  
                                  else
                                  {
                                      //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                          {
                                         console.log(BoatresultsWinter);
  
                                     //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                         
                                                              //check if next booking included

                                                              let isNextDaysError = false
                                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                                   isNextDaysError = true
                                                                   return res.json(error)
                                                              })
                      
                                                              
                                                               if(isNextDaysError) return
                                  
                                      consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                      .then(element=> 
                                          
                                          {
                                              if(element!=null)
                                              {
  
                                      if(element.Winter_ConsecutiveDays>=Total_Count)
                                      {
                                   
                                          if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                          {
                                          
                                               // for updating Summer days
                                               Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                               {   
                                                                                
                                                  Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                  Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                   
                                               },
                                               {new: true},
                                               function(err, data) {
                                                   
                                                   
                                               });
                                          
                                               var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                               console.log(x)
                                               
                                             
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                           
                        
                      
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data) {
  
   //mail
   
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  res.json({
  
  status:true,
  message: 'The booking has been successfully Updated'
  })
  })
 
  
                                          }//weekday weekend count
                                          else{
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
                                              res.json({
                                                  status:false,
                                                   message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                      })
      
      
                                                   
                                          }
  //Add Winter Section
  }
                                    
  else
  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                              }
                                              else
                                              {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                res.json({
                                                      status:false,
                                                      message: 'Consecutive days for this boat is Empty'
                                                  })
                                              }
  })                                     }
                                else
                                {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                  res.json({
                                      status:false,
                                      message: 'These Dates Are not Allowed for Booking'
                                  })
                                }
                              })
                              }//else
  
  
                                  
                              });
                          })
                      }
                      else
                      {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                          res.json({
                              status:false,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.'
                          })
                      }
                                        
                          })
                          
                          
  
                      })
                  
                 
          
               
                  });//else inside function owner
  
  
              
             
  
              });
  
          }
          else
          {
    
              console.log(Start_final_withoutTime)
              console.log(End_final_withoutTime)
              console.log(Cancelresults.Updated_time,'thissssssssss')
              var todaysdate=moment();
              console.log(todaysdate)
              var canceldate =moment(Cancelresults.Updated_time)
              var dif=moment.duration(todaysdate.diff(canceldate));
              console.log(dif.asHours());
              var Hrdif=Math.round(dif.asHours());
          
              console.log(Hrdif);
  
  
              if(Hrdif>24)
  
              {
                 
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                     
      
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                          
                                 
      
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                          console.log(Boatresults)
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {
      
                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return             
                                              
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
      {
      
      // for updating Summer days
      Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
      {   
                                
      Summer_WeekDays:SummerWeekdays-WeekDay_Count,
      Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
      
      },
      {new: true},
      function(err, data) {
      
      
      });
      
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
               
     
      //Add Summer Section
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
      end:end_Date_New,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
  },
  
  function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
                                 }//weekday,weekend
                                  else
                                      {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
      
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
      
      
                                       }
                              }
                              else
                              {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
      
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
      
      
                              }
                          }
                          else
                          {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                              res.json({
                                  status:false,
                                  message: 'Consecutive days for this boat is Empty'
                              })
      
                          }
                              })
                          
                                  }
                              
      
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},

                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
      
                                         //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                                     //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                          
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
      
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   console.log(x)
                                                  

                                            
      //Add Winter Section
      
      Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
      {
                               
                            
                          
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
      end:end_Date_New,
      start_NoTime:Start_final,
      end_NoTime:End_final,
      goingDuration:req.body.goingDuration,
      comingDuration:req.body.comingDuration,
      isAllDay:req.body.isAllDay,
      category:req.body.category,
      dueDateClass:req.body.dueDateClass,
      location:req.body.location,
      attendees:req.body.attendees,
      recurrenceRule:req.body.recurrenceRule,
      isPending:req.body.isPending,
      isFocused:req.body.isFocused,
      Is_StandByBooking:req.body.Is_StandByBooking,
      Check_Status:req.body.Check_Status,
      commends:req.body.commends,
      isVisible:req.body.isVisible,
      isReadOnly:req.body.isReadOnly,
      isPrivate:req.body.isPrivate,
      color:req.body.color,
      bgColor:req.body.bgColor,
      dragBgColor:req.body.dragBgColor,
      borderColor:req.body.borderColor,
      customStyle:req.body.customStyle,
      raw:req.body.raw,
      state:req.body.state, 
      User_RoleType:req.body.User_RoleType,
      User_Id:mongoose.Types.ObjectId(req.body.User_Id),
      Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
      Status:Module_status,
      IsActive: req.body.IsActive,
      Current_Time:moment(Date.now()),
      Updated_time: moment(Date.now()),
      isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
      
      },
      
      function(err, data) {
      res.json({
      
      status:true,
      message: 'The booking has been successfully Updated'
      })
      })
      
      
                                              }//weekday weekend count
                                              else{
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
      
                                                  res.json({
                                                      status:false,
                                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                          })
          
          
                                                       
                                              }
      //Add Winter Section
      }
                                        
      else
      {
          //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
      
      res.json({
      status:false,
      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
      
      }
                                                  }
                                                  else
                                                  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                    res.json({
                                                          status:false,
                                                          message: 'Consecutive days for this boat is Empty'
                                                      })
                                                  }
      })                                     }
                                    else
                                    {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
      
      
                                      
                                  });
                              })
                          }
                          else
                          {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
                                            
                              })
                             
      
                          })
                      
              
                   
                      });//else inside function owner
      
      
                 
      
                  });
              }
                 else
                 {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                      res.json({
                      status:false,
                      message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                  })
                 } 
  
          }
      })
  })
  
         
           }
           
  
  
          //between Launch And PreLuanch
          if(check_Status=="3" && specialDayCheck==0)
          {
            
                          
                             
                             if(User_role=='Admin')//for Admin
                             {
                               Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                                   {
                                     
                                       console.log(result.length,'length')
                                       var _Length=result.length;
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                              {
                                              
                                          
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                                

                                                Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                             
                                                  
                                                      {
                                                      if(results==null)
                                                      {
                                                   
                                                   
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                      
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
      calendarId:mongoose.Types.ObjectId(req.body.calendarId),
      title:req.body.title,
      body:req.body.body,
      start:Startdate_old,
      end:end_Date_New,
       start_NoTime:Start_final_withoutTime,
       end_NoTime:End_final_withoutTime,
       goingDuration:req.body.goingDuration,
       comingDuration:req.body.comingDuration,
       isAllDay:req.body.isAllDay,
       category:req.body.category,
       dueDateClass:req.body.dueDateClass,
       location:req.body.location,
       attendees:req.body.attendees,
       recurrenceRule:req.body.recurrenceRule,
       isPending:req.body.isPending,
       isFocused:req.body.isFocused,
       isVisible:req.body.isVisible,
       isReadOnly:req.body.isReadOnly,
       isPrivate:req.body.isPrivate,
       color:req.body.color,
       bgColor:req.body.bgColor,
       Is_StandByBooking:req.body.Is_StandByBooking,
       Check_Status:req.body.Check_Status,
       commends:req.body.commends,
       dragBgColor:req.body.dragBgColor,
       borderColor:req.body.borderColor,
       customStyle:req.body.customStyle,
       raw:req.body.raw,
       state:req.body.state, 
       User_RoleType:req.body.User_RoleType,
       User_Id:mongoose.Types.ObjectId(req.body.User_Id),
       Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
       Status:Module_status,
       IsActive: req.body.IsActive,
       Current_Time:moment(Date.now()),
       Updated_time: moment(Date.now())
  
  },
  
  function(err, data) {
  
  //mail

  const emailState =  'Successfully Edited.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value:  boatDetails.Boat_Name},
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Login Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
            
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
       res.json({
           
           status:true,
           message: 'The admin booking has been successfully Updated'
       })
   })
   
        
  }
  else
  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
      
      res.json({
              
          status:true,
          message: 'An existing booking already exists for this date. A new booking cannot be created.'
      })
  
  }
  
  
  
  })
  //Add
  
   
}) 
                                      
                                    
                                  })
                                      
                                      
   })
  }
  
                          else//For Owner
                          {
                              NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
       .then(OwnerDetails=> {
                              Schedule.findOne({Boat_Id:Boat_id,User_Id:Owner_id,IsActive:false,Cancelled_Status:1,$or:[{end_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:{$gte:Start_final_withoutTime,$lte:End_final_withoutTime}},{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime},{$and:[{start:{$gte:start_Date}},{end:{$lte:End_final_withoutTime}}]},{$and:[{start:{$lte:start_Date}},{end:{$gte:End_final_withoutTime}}]}]}).then(Cancelresults=>//for cancellation
                                  {
  
                                      if(Cancelresults==null)
                                      {
  
                                 
  console.log(Cancelresults,'cancellation rewsulttttt')
                                 
                     
                             
                            Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                          
                                             
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                                let allDaysBookedBacktoCheckThree = getDaysBetweenDates(start_Date_New,end_Date_New);

                                                let arrayofBookCheckThree = [];
                                                
                                                allDaysBookedBacktoCheckThree.map((date)=> arrayofBookCheckThree.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));

                                                Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$or:arrayofBookCheckThree}).then(results=>
  
                                               //Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                  console.log(Boatresults)
                                                  let stopExecution = {stop:false}
                                                  let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                      console.log(error)
                                                      stopExecution = error
                                                  })
                          
                          
                                                  if(stopExecution.stop){
                                                      return res.json({status:true,message:stopExecution.error})
                                                  }
                          
                                                  if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                  {

                                                       //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
  
       //update Summer
                       
 
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
    
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
         end:end_Date_New,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
  
   //mail
  
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
      })
                                    }//weekday,weekend
                                          else
                                              {
   //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
 //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking                                      
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                                 //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                                             //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                  
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                          

                                                         
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
         end:end_Date_New,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
  
   //mail
 
   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
  var mailOptions = {
     
      from:"noreply.smartboatbooking@gmail.com",
      to: OwnerDetails.Email,
      //to: "bjibin3@gmail.com",
      subject: 'Successfully Edited',
      html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
      
  };
  
  transporter.sendMail(mailOptions, function (error, info) {
     
  });           
  
  var mailOptionsAdmin = {
     
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Successfully Booked',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
     
  
                                                      }//weekday weekend count
                                                      else{
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
      //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                              
                             
                      
                           
                              });//else inside function owner
  
  
                          
  
                          });
                      }
                      else
                      {
  
                          //
                      
                      console.log(Start_final_withoutTime)
                      console.log(End_final_withoutTime)
                      console.log(Cancelresults.Updated_time,'thissssssssss')
                      var todaysdate=moment();
                      console.log(todaysdate)
                      var canceldate =moment(Cancelresults.Updated_time)
                      var dif=moment.duration(todaysdate.diff(canceldate));
                      console.log(dif.asHours());
                      var Hrdif=Math.round(dif.asHours());
                  
                      console.log(Hrdif);
  
  
                      if(Hrdif>24)
  
                      {
                          Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                              {
                                                     
                                  console.log(result.length,'length')
                                  var _Length=result.length;
                                 
                                      Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                          {
                                           
                                          Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                              {
                                             
  
                                             Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                                      {
                                                      if(results==null)
                                                      {
                             
                                         
  
                                      Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                          {  
                                              var SummerWeekdays=response.Summer_WeekDays;
                                              var SummerWeekendDays=response.Summer_WeekEndDays;
                                              var  WinterWeekDays=response.Winter_WeekDays;
                                              var WinterweekendDays=response.Winter_WeekEndDays;

                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                              
                                              Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                                  {
                                                  console.log(Boatresults)
                                                  let stopExecution = {stop:false}
                                                  let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                                      console.log(error)
                                                      stopExecution = error
                                                  })
                          
                          
                                                  if(stopExecution.stop){
                                                      return res.json({status:true,message:stopExecution.error})
                                                  }
                          
                                                  if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                                  {

                                                       //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
  
                                                                                    
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                          
              
                                                          if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                          {
              
                                                       
                                                              if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
       // for updating Summer days
       Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
       {   
                                        
         Summer_WeekDays:SummerWeekdays-WeekDay_Count,
         Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
           
       },
       {new: true},
       function(err, data) {
           
           
       });
       
  
      var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
      console.log(x)
      
       //update Summer
                       

  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
         
                                       
                                    
                                  
         Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
         Booking_ID:globalbookingid,
         Boat_Name:req.body.Boat_Name,
         Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
      end:end_Date_New,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
  function(err, data) {
          res.json({
              
              status:true,
              message: 'The booking has been successfully updated'
          })
      })
                                   }//weekday,weekend
                                          else
                                              {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
   
                                               res.json({
                                              status:false,
                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                        })
  
  
                                               }
                                      }
                                      else
                                      {
  //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                          res.json({
                                              status:false,
                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                          })
  
  
                                      }
                                  }
                                  else
                                  {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                      res.json({
                                          status:false,
                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                      })
  
                                  }
                                      })
                                  
                                          }
                                      
  
                              
                                              else
                                              {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                                      {
                                                     console.log(BoatresultsWinter);
  
                                                 //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {

                                                              //check if next booking included

                                                              let isNextDaysError = false
                                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                                                   isNextDaysError = true
                                                                   return res.json(error)
                                                              })
                      
                                                              
                                                               if(isNextDaysError) return
                                                     
                                                  
                                              
                                                  consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                                  .then(element=> 
                                                      
                                                      {
                                                          if(element!=null)
                                                          {
  
                                                  if(element.Winter_ConsecutiveDays>=Total_Count)
                                                  {
                                               
                                                      if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                                      {
                                                      
                                                           // for updating Summer days
                                                           Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                           {   
                                                                                            
                                                              Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                              Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                               
                                                           },
                                                           {new: true},
                                                           function(err, data) {
                                                               
                                                               
                                                           });
                                                      
  
                                                           var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                           console.log(x)
                                                           
                                                          
                                                
  //Add Winter Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                       
                                    
                                  
      Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
      Booking_ID:globalbookingid,
      Boat_Name:req.body.Boat_Name,
      Total_DaysBooked:Total_Count,
         calendarId:mongoose.Types.ObjectId(req.body.calendarId),
         title:req.body.title,
         body:req.body.body,
         start:Startdate_old,
         end:end_Date_New,
          start_NoTime:Start_final,
          end_NoTime:End_final,
          goingDuration:req.body.goingDuration,
          comingDuration:req.body.comingDuration,
          isAllDay:req.body.isAllDay,
          category:req.body.category,
          dueDateClass:req.body.dueDateClass,
          location:req.body.location,
          attendees:req.body.attendees,
          recurrenceRule:req.body.recurrenceRule,
          isPending:req.body.isPending,
          isFocused:req.body.isFocused,
          isVisible:req.body.isVisible,
          isReadOnly:req.body.isReadOnly,
          isPrivate:req.body.isPrivate,
          Is_StandByBooking:req.body.Is_StandByBooking,
          Check_Status:req.body.Check_Status,
          commends:req.body.commends,
          color:req.body.color,
          bgColor:req.body.bgColor,
          dragBgColor:req.body.dragBgColor,
          borderColor:req.body.borderColor,
          customStyle:req.body.customStyle,
          raw:req.body.raw,
          state:req.body.state, 
          User_RoleType:req.body.User_RoleType,
          User_Id:mongoose.Types.ObjectId(req.body.User_Id),
          Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
          Status:Module_status,
          IsActive: req.body.IsActive,
          Current_Time:moment(Date.now()),
          Updated_time: moment(Date.now()),
          isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
   
function(err, data)
{
          res.json({
              
              status:true,
              message: 'The booking has been successfully Updated'
          })
})
      
  
                                                      }//weekday weekend count
                                                      else{
  //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                          res.json({
                                                              status:false,
                                                               message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                  })
                  
                  
                                                               
                                                      }
  //Add Winter Section
  }
                                                
  else
  {
  //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
      res.json({
          status:false,
          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
      })
  
  }
                                                          }
                                                          else
                                                          {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                            res.json({
                                                                  status:false,
                                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                              })
                                                          }
  })                                     }
                                            else
                                            {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                              res.json({
                                                  status:false,
                                                  message: 'These Dates Are not Allowed for Booking'
                                              })
                                            }
                                          })
                                          }//else
  
  
                                              
                                          });
                                      })
                                  }
                                  else
                                  {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                      res.json({
                                          status:false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.'
                                      })
                                  }
                                                    
                                      })
                                     
  
                                  })
                             
                      
                           
                              });//else inside function owner
  
  
                         
  
                          });
  
                      }
                         else
                         {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking                     
                              res.json({
                              status:false,
                              message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again'
                          })
                         } //
  
                          // res.json({
                          //     status:false,
                          //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                          // })
  
                      }
                  })
              })
                          }
  
                        
                          
                      }
  
                if(check_Status="4" && User_role=="Maintenance" )
                {
                 
  
                  Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                        
                          console.log(result.length,'length')
                        //  var _Length=result.length;
                         
                             Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                 {
                                 
                             Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                 {
                                
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                         {
                                         if(results==null)
                                         {
                                    
                                      
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                          
         
                     
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:Start_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err, data)
{
   //mail

   const emailState =  'Successfully Edited.';
   const emailContent = `Dear ${OwnerDetails.First_Name} your booking for Boat ${boatDetails.Boat_Name} has been succesfully Edited on ${getCurrentTimeFormatted()}`;
   const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} booked by ${OwnerDetails.First_Name} has been successfully edited  on ${getCurrentTimeFormatted()}`
   const emailDetailName = 'Booking Details'
   const emailDetails = [
     { key: 'Boat Name', value:  boatDetails.Boat_Name},
     { key: 'Booking Date', value: getCurrentTimeFormatted() },
   ];
   const emailNameAndLink = {
     name:'Login Link',
     link:`${process.env.CLIENT_URL}/boat-bookings`
   }
  
          
  
  var mailOptionsAdmin = {   
      from:"noreply.smartboatbooking@gmail.com",
       to: "admin@smartboating.com.au",
       subject: 'Maintainance Edited',
       html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
  };
  
  transporter.sendMail(mailOptionsAdmin, function (error, info) {
  
     
      
  }); 
  //mail
  
  
  res.json({
  
  status:true,
  message: 'The boat maintenance booking has been successfully Updated'
  })
  })
 
  }
  else
  {
  res.json({
  
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
 
}) 
                         
                         
                     })
                         
  })
                 
  
                }
  
  // special Day
  if(specialDayCheck==1)
  {
    console.log("special day check back to back 3");
   const Specialday_id=req.body.Specialday_id;
   const obj=req.body.Special_Day;
     
                  
                     
                     if(User_role=='Admin')//for Admin
                     {
                       Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                           {
                             
                               console.log(result.length,'length')
                              // var _Length=result.length;
                             
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                      {
                                      
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
                                          Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                          
                                           
  //Add 
  console.log('Admin')
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                                               
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final_withoutTime,
  end_NoTime:End_final_withoutTime,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now())
  
  },
  
function(err,data)
{
  res.json({
   
   status:true,
   message: 'The admin booking has been successfully created'
  })
  })
  
  
  }
  else
  {


      //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  res.json({
      
  status:true,
  message: 'An existing booking already exists for this date. A new booking cannot be created.'
  })
  
  }
  
  
  
  })
  //Add
   }) 
                             
                          })
                             
  })
  }
  
                  else//For Owner
                  {
  
                      NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                      .then(OwnerDetails=> {
                     
                    Schedule.find({Boat_Id:Boat_id,IsActive:true,$or:[{start_NoTime:Start_final_withoutTime},{end_NoTime:End_final_withoutTime}]}).then(result=>
                      {
                                             
                          console.log(result.length,'length')
                          var _Length=result.length;
                         
                              Schedule.findOne({Boat_Id:Boat_id,start:{$gte:start_Date},end:{$lte:End_final_withoutTime},IsActive:true}).then(result2=>
                                  {
                                  
                                     
                                  Schedule.findOne({Boat_Id:Boat_id,start:{$lte:start_Date},end:{$gte:End_final_withoutTime},IsActive:true}).then(results=>
                                      {
                                      
  
                                     Schedule.findOne({Boat_Id:Boat_id,IsActive:true,isBookingPending:false,isBookingCancelled:false,$and:[{start:{$lte:End_final_withoutTime}},{end:{$gte:End_final_withoutTime}}]}).then(results=>
                                              {
                                              if(results==null)
                                              {
                                                 
                                                 
                                     
                                     
                                 
  
                              Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                                  {  
                                      var SummerWeekdays=response.Summer_WeekDays;
                                      var SummerWeekendDays=response.Summer_WeekEndDays;
                                      var  WinterWeekDays=response.Winter_WeekDays;
                                      var WinterweekendDays=response.Winter_WeekEndDays;

                                      //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
                                      
                                      Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                          {
                                          console.log(Boatresults)
                                          let stopExecution = {stop:false}
                                          let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                              console.log(error)
                                              stopExecution = error
                                          })
                  
                  
                                          if(stopExecution.stop){
                                              return res.json({status:true,message:stopExecution.error})
                                          }
                  
                                          if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                          {
                                               //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,true,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                                                            
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                                  
      
                                                  if(element.Summer_ConsecutiveDays>=Total_Count)//consecutive count
                                                  {
      
                                               
                                                      if(PendingSummerWeekdays>=WeekDay_Count && PendingSummerWeekEnddays>=WeekEnd_Count )//count of weekday and week end
  {
  
  // for updating Summer days
  Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
  {   
                                
  Summer_WeekDays:SummerWeekdays-WeekDay_Count,
  Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
   
  },
  {new: true},
  function(err, data) {
   
   
  });
  
  
  var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
  console.log(x)
 
  //update Summer
     // special Day
     
       CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
          
         
          
  if(myflag==0)
  {
      console.log('inside if Special day check back to back 3');
  
          obj.map(function(objs) {   
          var specialday=objs.special_date;
          var Specialdayid=objs._id;
          var Start_final=moment(specialday);
          var Start_final_withoutTime=Start_final.startOf('day');
          console.log(Start_final_withoutTime)
          var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
      if( addspecial == true)
          {
          console.log('successs')
          }
          else{
              console.log('fail')
          }
  })
  
     // special Day

 
  
  //Add Summer Section
  
  Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
  {
                               
                            
                          
  Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
  Booking_ID:globalbookingid,
  Boat_Name:req.body.Boat_Name,
  Total_DaysBooked:Total_Count,
  calendarId:mongoose.Types.ObjectId(req.body.calendarId),
  title:req.body.title,
  body:req.body.body,
  start:Startdate_old,
  end:end_Date_New,
  start_NoTime:Start_final,
  end_NoTime:End_final,
  goingDuration:req.body.goingDuration,
  comingDuration:req.body.comingDuration,
  isAllDay:req.body.isAllDay,
  category:req.body.category,
  dueDateClass:req.body.dueDateClass,
  location:req.body.location,
  attendees:req.body.attendees,
  recurrenceRule:req.body.recurrenceRule,
  Is_StandByBooking:req.body.Is_StandByBooking,
  Check_Status:req.body.Check_Status,
  commends:req.body.commends,
  isPending:req.body.isPending,
  isFocused:req.body.isFocused,
  isVisible:req.body.isVisible,
  isReadOnly:req.body.isReadOnly,
  isPrivate:req.body.isPrivate,
  color:req.body.color,
  bgColor:req.body.bgColor,
  dragBgColor:req.body.dragBgColor,
  borderColor:req.body.borderColor,
  customStyle:req.body.customStyle,
  raw:req.body.raw,
  state:req.body.state, 
  User_RoleType:req.body.User_RoleType,
  User_Id:mongoose.Types.ObjectId(req.body.User_Id),
  Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
  Status:Module_status,
  IsActive: req.body.IsActive,
  Current_Time:moment(Date.now()),
  Updated_time: moment(Date.now()),
  isBookingPending: isNextBookingDayIncluded.included ? true : false,
isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
  
  },
  
  function(err, data)
  {
  res.json({
      
      status:true,
      message: 'The booking has been successfully created'
  })
  })
       
  
  }//special day
  else
  {


      res.json({
      
          status:true,
          message: 'You Have Already Booked Special Day'
      })
  }
  })
  
  }//weekday,weekend
  
  
                             else
                                      {
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
                                       res.json({
                                      status:false,
                                       message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                })
  
  
                                       }
                              }
                              else
                              {
  
//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                  res.json({
                                      status:false,
                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
                                  })
  
  
                              }
                          }
                          else
                          {


//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking                                
                              res.json({
                                  status:false,
                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                              })
  
                          }
                              })
                          
                                  }
                              
  
                      
                                      else
                                      {
                                          //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime}
                                          Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsWinter)=>
                                              {
                                             console.log(BoatresultsWinter);
  
                                      //list all winter start and end date of  owne  based on owner duration  duration which include all year

                    let stopExecution = {stop:false}
                    let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsWinter.WinterSeason_SDate,BoatresultsWinter.WinterSeason_EDate,start_Date,end_Date).catch((error)=>{
                      console.log(error)
                      stopExecution = error
                  })

                  if(stopExecution.stop){
                      return res.json({status:true,message:stopExecution.error})
                  }
                            

                
                                  if(isAvailableDay && isAvailableDay.status)//check Date Between winter Dates
                                  {
                                                                     //check if next booking included

                                      let isNextDaysError = false
                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(req.body.start,req.body.end,req.body.Boat_Id,req.body.timeZone,false,req.body.User_Id,true).catch((error)=>{
                                           isNextDaysError = true
                                           return res.json(error)
                                      })

                                      
                                       if(isNextDaysError) return
                                          
                                      
                                          consecutive.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id)})
                                          .then(element=> 
                                              
                                              {
                                                  if(element!=null)
                                                  {
  
                                          if(element.Winter_ConsecutiveDays>=Total_Count)
                                          {
                                       
                                              if(PendingWinterWeekdays>=WeekDay_Count && PendingWinterWeekenddays >=WeekEnd_Count )//count of weekday and week end
                                              {
                                              
                                                   // for updating Summer days
                                                   Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                                   {   
                                                                                    
                                                      Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                                      Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                                       
                                                   },
                                                   {new: true},
                                                   function(err, data) {
                                                       
                                                       
                                                   });
                                              
  
                                                   var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                                   CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
                                                    if(myflag==0){

                                                        obj.map(function(objs) {   
                                                            var specialday=objs.special_date;
                                                            var Specialdayid=objs._id;
                                                            var Start_final=moment(specialday);
                                                            var Start_final_withoutTime=Start_final.startOf('day');
                                                            console.log(Start_final_withoutTime)
                                                            var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                                        if( addspecial == true)
                                                            {
                                                            console.log('successs')
                                                            }
                                                            else{
                                                                console.log('fail')
                                                            }
                                                        });

                                                         //Add Winter Section
  
                                        Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
                                        {
                                                                    
                                                                    
                                                                
                                        Boat_Id:mongoose.Types.ObjectId(req.body.Boat_Id),
                                        Booking_ID:globalbookingid,
                                        Boat_Name:req.body.Boat_Name,
                                        Total_DaysBooked:Total_Count,
                                        calendarId:mongoose.Types.ObjectId(req.body.calendarId),
                                        title:req.body.title,
                                        body:req.body.body,
                                        start:start_Date_New,
                                        end:end_Date_New,
                                        start_NoTime:Start_final,
                                        end_NoTime:End_final,
                                        goingDuration:req.body.goingDuration,
                                        comingDuration:req.body.comingDuration,
                                        isAllDay:req.body.isAllDay,
                                        category:req.body.category,
                                        dueDateClass:req.body.dueDateClass,
                                        location:req.body.location,
                                        attendees:req.body.attendees,
                                        recurrenceRule:req.body.recurrenceRule,
                                        isPending:req.body.isPending,
                                        isFocused:req.body.isFocused,
                                        isVisible:req.body.isVisible,
                                        isReadOnly:req.body.isReadOnly,
                                        isPrivate:req.body.isPrivate,
                                        Is_StandByBooking:req.body.Is_StandByBooking,
                                        Check_Status:req.body.Check_Status,
                                        commends:req.body.commends,
                                        color:req.body.color,
                                        bgColor:req.body.bgColor,
                                        dragBgColor:req.body.dragBgColor,
                                        borderColor:req.body.borderColor,
                                        customStyle:req.body.customStyle,
                                        raw:req.body.raw,
                                        state:req.body.state, 
                                        User_RoleType:req.body.User_RoleType,
                                        User_Id:mongoose.Types.ObjectId(req.body.User_Id),
                                        Admin_Id:mongoose.Types.ObjectId(req.body.Admin_Id),
                                        Status:Module_status,
                                        IsActive: req.body.IsActive,
                                        Current_Time:moment(Date.now()),
                                        Updated_time: moment(Date.now()),
                                        isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                        isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded
                                        
                                        },
                                        
                                        function(err,data)
                                        {
                                        res.json({
                                            
                                            status:true,
                                            message: 'The booking has been successfully created'
                                        })
                                        })
                                        .catch(error => {
                                        res.json({
                                            message: error
                                        })
                                        })

                                                    }else{

                                                        res.json({
      
                                                            status:true,
                                                            message: 'You Have Already Booked Special Day'
                                                        })

                                                    }
                                                   });
                                                 
                                                        
  
  
                                              }//weekday weekend count
                                              else{

 //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking                                                  
  
                                                        res.json({
                                                            status:false,
                                                            message: 'The booking exceeds your allocation limit. Please try to create a booking with fewer days'
                                                                })
          
          
                                                       
                                              }
  //Add Winter Section
  }
                                        
  else
  {
      //deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
  
  res.json({
  status:false,
  message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days'
  })
  
  }
                                                  }
                                                  else
                                                  {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                                                    res.json({
                                                          status:false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking'
                                                      })
                                                  }
  })                                     }
                                    else
                                    {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking                                       
                                      res.json({
                                          status:false,
                                          message: 'These Dates Are not Allowed for Booking'
                                      })
                                    }
                                  })
                                  }//else
  
  
                                      
                                  });
                              })
  
  
  
                          }
                          else
                          {

//deactivate  2nd booking 
Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Back_to_Back_Sheduler_id)}, 
{
  IsActive:true,
  Updated_time: moment(Date.now()),    
},                                             
function(err, data) {
  
 
});  
//deactivate  2nd booking 
                              res.json({
                                  status:false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.'
                              })
                          }
  
                 
                          
                                            
                              })
                             
  
                          })
                    
              
                   
                      });//else inside function owner
  
  
                  
  
                  });
              })
                  }
  
                
                  
              }
  
  //special Day
  
              
          }
          else
          {
              res.json({
                  status:false,
                  message: 'A booking cannot be created for a previous day'
              })
          }
      }
          else
          {
  
              res.json({
                  status:false,
                  message: 'Boat Selected is not Active'
              })
  
          }
     
      });
  
         
          })
      })
} 

  }catch(error){
      console.log(error)
      return res.json(error)
  }

};

 
//View
const ViewAllSchedule= (req, res) => {  


    return new Promise(async(resolve,reject)=>{

        let response = await Schedule.find({IsActive:true}).catch((error)=>{
            console.log(error)
            return reject({status:true,message:'Something went wrong try again.'})
        })

        let SpecialDays = await  Add_Special_Days.find({IsActive:true}).catch((error)=>{
            console.log(error)
            return reject({status:true,message:'Something went wrong try again.'})
            
        })
        
          /*

        check if any booking have isNextDayBookingIncluded which is not a isBookingPending 
        if any active booking found get that boat id and remove all pending booking from response

         */

         let documentIds = []

        response.map((booking)=>{

              /*

            if a booking's included in nexbookingday and not a pending booking then it is a active booking .
            if a boat have active booking that include next day booking  remove all pending and canceled booking
             also check if it is the same day as the pending or canceled bookig so it will make a conflict if there is muliple
            active nextday booking
            
         */
        
            if(!booking.isBookingPending && booking.isNextDayBookingIncluded){
                //"booking" is active booking
                
                
                 response.map((schedule)=>{
                
                    //"schedule" is pending or canceled booking

                    //checking if any of the active bookings day included in pending or canceled booking

                    let allActiveBookedDays = getDaysBetweenDates(booking.start,booking.end)
                    let allPendingOrCanceledBookedDays = getDaysBetweenDates(schedule.start,schedule.end)

                    let isActiveBookingIsSameAsPendingOrCanceledBooking = false

                    allActiveBookedDays.map((activeDay)=>{
                        if(allPendingOrCanceledBookedDays.includes(activeDay)){
                            isActiveBookingIsSameAsPendingOrCanceledBooking = true
                        }
                    })

                    //remove pending and canceled day from response only if the active booking day is include any of the pending or canceled booking

                    if(isActiveBookingIsSameAsPendingOrCanceledBooking){

                        if(schedule.Boat_Id.toString() === booking.Boat_Id.toString() && schedule.isBookingPending || schedule.Boat_Id.toString() === booking.Boat_Id.toString() && schedule.isBookingCancelled)  documentIds.push(schedule._id)
                    }

             })
            }
        })

        
        newResponse = response.filter((booking) => !documentIds.includes(booking._id))
        
        // get all standby booking and concat it to newresponse which include normal bookings and next day bookings
        let allStandByBookings = await AddStandByBooking.find({BookingStatus:{$ne:"Accepted"},showThisBookingInCalendar:true}).catch((error)=> {
            console.log(error);
            return reject({status:false,message:"Something went wrong."});
        });

        newResponse = newResponse.concat(allStandByBookings);

        

        //get all owner canceled stand by booking 

        let canceledStandByBookings = await OwnerStandByCancelModel.find().catch((error)=> {
            console.log(error);
            return reject({status:false,message:"Something went wrong."});
        });

        newResponse = newResponse.concat(canceledStandByBookings);


        return resolve({ status:true,response:newResponse,SpecialDays})



    }).then((response)=>{
        return res.json(response)
     }).catch((error)=>{
        return res.json(error)
     })

    // Schedule.find({IsActive:true})
    //     .then(response => {
    //         Add_Special_Days.find({IsActive:true})
    //         .then(SpecialDays => {                         
    //         res.json({
    //             status:true,
    //             response,SpecialDays
    //         })
    //     })
    // })
    //     .catch(error => {
    //         res.json({
    //             message: "No Data"
    //         })
    //     })
}
const ViewAllScheduleActiveAndNonActive= (req, res, next) => {  

    Schedule.find()
        .then(response => {
            Add_Special_Days.find()
            .then(SpecialDays => {                         
            res.json({
                status:true,
                response,SpecialDays
            })
        })
    })
        .catch(error => {
            res.json({
                message: "No Data"
            })
        })
}
//start......................

function getDaysInMonth_Sheduler(tmp1){

    var public_sheduler_totaldaysbased = [];
    var days = ['Su','Mo','Tu','We','Th','Fr','Sa'];
    var monthNames = [ "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December" ];
    var monthNames_Number = [ "1", "2", "3", "4", "5", "6",
        "7", "8", "9", "10", "11", "12" ];
  
    var tmp1_StartDate = new Date(tmp1.start);
    var tmp2_EndDate = new Date(tmp1.end);


    var tmp_month = tmp1_StartDate.getMonth();
    var tmp_year = tmp1_StartDate.getFullYear();
    var tmp_Date = tmp1_StartDate.getDate();

    var date = new Date(tmp_year, tmp_month, tmp_Date);        
    
    do
    {
      
       var obj = Object();
      var tmp_dt = new Date(date);
     // obj.fullofTheDate = tmp_dt;
    //   obj.day = tmp_dt.getDate();
    //   obj.month = monthNames[tmp_dt.getMonth()];
    //   obj.month_Number = monthNames_Number[tmp_dt.getMonth()];
    //   obj.year = tmp_dt.getFullYear(); 
      obj.days =  days[tmp_dt.getDay()]
      
      public_sheduler_totaldaysbased.push(obj);

       date.setDate(date.getDate() + 1);
       var tmp_Add_Date = new Date(date);

    }while(tmp_Add_Date <= tmp2_EndDate)     

   return public_sheduler_totaldaysbased;
 
};

///........................


//Function for Delete AdminBooking 
const DeleteSchedule = async(req, res, next) => {

   
    var Roles=req.body.User_RoleType;
    var scheduleid = req.body._id;
    const Validaterules =  await cancelrues(req.body);
    if(Validaterules.status == false){return res.json({ status: false, message:"Permission Denied" });}

   
    // cancel stand by booking in pending state

            // check if it is a stand by booking id is passed

            let standByBooking = await AddStandByBooking.findOne({_id:scheduleid}).catch((error)=> console.log(error));

            // if this exist that means user is trying to cancel a stand by booking its pending state

            if(standByBooking){ 

                console.log("entered first stanbook block");



                  //get total day saved in db and real total days differnce . differnce is how many stand booking done

            const totalDaysInDB = standByBooking.TotalDay_Count;
            const realTotalDays  = moment(new Date(standByBooking.end)).diff(moment(new Date(standByBooking.start)),"days") + 1;
            const standByBookingDaysCount = realTotalDays -totalDaysInDB;
            const allBookedDays = getDaysBetweenDates(standByBooking.start,standByBooking.end);

            console.log("betweenDates"+allBookedDays);

            const standByBookingDays = [];

            let standByBookingCounter = 0;
            while(standByBookingCounter < standByBookingDaysCount){
                standByBookingDays.push(allBookedDays[standByBookingCounter])
                standByBookingCounter++
            }

            console.log(standByBookingDays,"standByBookingDaysOnee")

            const ValidateStandby =  await cancelStandbyrules(Roles,standByBooking.User_Id,req.body.curntuser,standByBooking.BookingStatus);
            if(ValidateStandby.status == false){ return res.json({ status: false, message:"Permission Denied" });}

                // owner canceled data update


                /* check boat is active*/

            let checkactive = Boats.findOne({_id:mongoose.Types.ObjectId(standByBooking.Boat_Id),Boat_Status:1}).catch((error)=> console.log(error));
            if(!checkactive){

                return res.json({
                    status:false,
                    message: 'Boat is not active'
                    })

            }

            /* check boat is suspended */

            let suspendcheck = await manageBoat.findOne({Boat_Id:mongoose.Types.ObjectId(standByBooking.Boat_Id),Owner_Id:mongoose.Types.ObjectId(standByBooking.User_Id)}).catch((error) => console.log(error));
            if(suspendcheck.Block == false)
            return res.json({
            status:false,
            message: 'Suspended'
            })
               
               /* let standbyStart = new Date(standByBooking.start);
                let standbyEnd = standbyStart.setDate(standbyStart.getDate() +1);
                standbyEnd = new Date(standbyEnd).toISOString();*/

                if((standByBookingDays.length)==1){
                    var standbybookStart = standByBookingDays[0];
                    var standbyEnd = standByBookingDays[0];
                    }
                    else{

                        var standbybookStart = standByBookingDays[0];

                        if(standByBookingDays[1]!= undefined)
                         var standbyEnd = standByBookingDays[1];
                         else

                         var standbyEnd = standByBookingDays[0];

        
                    }
                    console.log("FirstOwnerCancel");
                   
                await new OwnerStandByCancelModel({
                    Boat_Name:standByBooking.Boat_Name,
                    calendarId:standByBooking.calendarId,
                    title:"Owner (Canceled stand by booking)",
                    body:standByBooking.body,
                    start:new Date(standbybookStart),
                    end:new Date(standbyEnd),
                    start_NoTime:new Date(new Date(standbybookStart).setUTCHours(00,00,00,00)),
                    end_NoTime:new Date(new Date(standbyEnd).setUTCHours(00,00,00,00)),
                    goingDuration:standByBooking.goingDuration,
                    comingDuration:standByBooking.comingDuration,
                    category:standByBooking.category,
                    dueDateClass:standByBooking.dueDateClass,
                    location:standByBooking.location,
                    attendees:standByBooking.attendees,
                    recurrenceRule:standByBooking.recurrenceRule,
                    color:standByBooking.color,
                    bgColor:standByBooking.bgColor,
                    dragBgColor:standByBooking.dragBgColor,
                    borderColor:standByBooking.borderColor,
                    customStyle:standByBooking.customStyle,
                    raw:standByBooking.raw,
                    User_RoleType:standByBooking.User_RoleType,
                    Status:standByBooking.Status,
                    Check_Status:standByBooking.Check_Status,
                    Check_Month:standByBooking.Check_Month,
                    Booking_ID:standByBooking.Booking_ID,
                    commends:standByBooking.commends,
                    LOA:standByBooking.LOA,
                    Approved_LOA:standByBooking.Approved_LOA,
                    BookingStatus:standByBooking.BookingStatus,
                    Cancelled_Status:standByBooking.Cancelled_Status,
                    Total_DaysBooked:standByBooking.TotalDay_Count,
                    WeekDay_Count:standByBooking.WeekDay_Count,
                    WeekEnd_Count:standByBooking.WeekEnd_Count,
                    Total_DaysBooked_Reassign:standByBooking.Total_DaysBooked_Reassign,
                    WeekDay_Count_Reassign:standByBooking.WeekDay_Count_Reassign,
                    WeekEnd_Count_Reassign:standByBooking.WeekEnd_Count_Reassign,
                    Booking_Type:standByBooking.Booking_Type,
                    WeekDay_Count_Edit:standByBooking.WeekDay_Count_Edit,
                    WeekEnd_Count_Edit:standByBooking.WeekEnd_Count_Edit,
                    Total_Edit_Loa:standByBooking.Total_Edit_Loa,
                    PartialCancellation_Status:standByBooking.PartialCancellation_Status,
                    start_CancelledDate:standByBooking.start_CancelledDate,
                    end_CancelledDate:standByBooking.end_CancelledDate,
                    cancaledDays:standByBooking.cancaledDays,
                    isBookingPending:standByBooking.isBookingPending,
                    isBookingCancelled:standByBooking.isBookingCancelled,
                    isBookingAccepted:standByBooking.isBookingAccepted,
                    isNextDayBookingIncluded:standByBooking.isNextDayBookingIncluded,
                    isStandByBookingIncluded:standByBooking.isStandByBookingIncluded,
                    Boat_Id:standByBooking.Boat_Id,
                    isAllDay:standByBooking.isAllDay,
                    isPending:standByBooking.isPending,
                    isFocused:standByBooking.isFocused,
                    isVisible:standByBooking.isVisible,
                    isReadOnly:standByBooking.isReadOnly,
                    isPrivate:standByBooking.isPrivate,
                    Is_StandByBooking:standByBooking.Is_StandByBooking,
                    User_Id:standByBooking.User_Id,
                    Admin_Id:standByBooking.Admin_Id,
                    IsActive:standByBooking.IsActive,
                    standByBookingId:standByBooking._id
                
                }).save().catch((error)=> console.log(error))

                

                    //update stand by booking cancel status
            await  AddStandByBooking.updateOne({_id:standByBooking._id},{isOrginalBookingCanceled:true,showThisBookingInCalendar:false}).catch((error)=> console.log(error));

                return res.json({
                    status:true,
                    Loa:0,
                    Weekday:0,
                    WeekEnd:0,
                    message: 'Schedule Details Deleted Successfully'
                })
            }

  
    Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(async(response)=>
        { 
           
            if(response){

            var Boat_id=response.Boat_Id;
            var Owner_id=response.User_Id;
            console.log(Owner_id,'hey')
            var start_Date=response.start;
            var Start_final=moment(start_Date);
            console.log(start_Date)
            console.log(Start_final)
            var Start_final_withoutTime=Start_final.startOf('day');
            var end_Date=response.end;
            var End_final=moment(end_Date);
            var End_final_withoutTime=End_final.startOf('day');
            console.log(Start_final_withoutTime)
            console.log(End_final_withoutTime)
            var RoleAssigned=response.User_RoleType;
            var Cancel_date=moment();
            console.log(Cancel_date)
            var dif=moment.duration(Start_final.diff(Cancel_date));
            console.log(dif.asHours());
            var Hrdif=Math.round(dif.asHours());
            var Totalday_prev=response.Total_DaysBooked_Reassign;

            //Jibin

            // var Weekdays_prev=response.WeekDay_Count_Reassign;
            // var WeekEndDays_prev=response.WeekEnd_Count_Reassign;

            //Jibin


            

            //Irfan

             let allBookingDaysBetweenStartAndEnd = getDaysBetweenDates(response.start,response.end);
             console.log(allBookingDaysBetweenStartAndEnd);

            let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(allBookingDaysBetweenStartAndEnd);

           

            var Weekdays_prev = numberOfWeekDays; 
            var WeekEndDays_prev = numberOfWeekEnds;
            // var Weekdays_prev = response.WeekDay_Count; 
            // var WeekEndDays_prev = response.WeekEnd_Count;

            if(response.isStandByBookingIncluded){

                //get stand by booking and get total weekday and weekend between start and end date and reduce it from weekday and weekend
                // of that field to get actual stand by booking week day and weekend

            let standByBooking = await AddStandByBooking.findOne({_id:response.standByBookingId}).catch((error)=> console.log(error));

            if(standByBooking){

                console.log("adminreject");

                let allBookingDatesOfStandByBooking = getDaysBetweenDates(standByBooking.start,standByBooking.end);

                let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(allBookingDatesOfStandByBooking);

                let standByBookingWeekDays = numberOfWeekDays - standByBooking.WeekDay_Count
                let standByBookingWeekendDays = numberOfWeekEnds - standByBooking.WeekEnd_Count

                Weekdays_prev -= standByBookingWeekDays;
                WeekEndDays_prev -= standByBookingWeekendDays;


                
            //create a document in ownerStandByCancel model

             //determine stand by booking days

            //get total day saved in db and real total days differnce . differnce is how many stand booking done

            const totalDaysInDB = response.Total_DaysBooked;
            const realTotalDays  = moment(new Date(end_Date)).diff(moment(new Date(start_Date)),"days") + 1;
            const standByBookingDaysCount = realTotalDays -totalDaysInDB;
            const allBookedDays = getDaysBetweenDates(start_Date,end_Date);

            const standByBookingDays = [];

            let standByBookingCounter = 0;
            while(standByBookingCounter < standByBookingDaysCount){
                standByBookingDays.push(allBookedDays[standByBookingCounter])
                standByBookingCounter++
            }

            console.log(standByBookingDays,"standByBookingDays")

            if((standByBookingDays.length)==1){
                var standbybookStart = standByBookingDays[0];
                var standbyEnd = standByBookingDays[0];
                }
                else{
    
                    var standbybookStart = standByBookingDays[0];
                    if(standByBookingDays[1]!= undefined)
                    var standbyEnd = standByBookingDays[1];
                    else
                    var standbyEnd = standByBookingDays[0];
    
                }

           /* let standbyStart = new Date(standByBooking.start);
            let standbyEnd = standbyStart.setDate(standbyStart.getDate() +1);
            standbyEnd = new Date(standbyEnd).toISOString();*/

            console.log("ownercancelSecond");

            await new OwnerStandByCancelModel({
                Boat_Name:response.Boat_Name,
                calendarId:response.calendarId,
                title:"Owner (Canceled stand by booking)",
                body:response.body,
                start:new Date(standbybookStart),
                end:new Date(standbyEnd),
                start_NoTime:new Date(new Date(standbybookStart).setUTCHours(00,00,00,00)),
                end_NoTime:new Date(new Date(standbyEnd).setUTCHours(00,00,00,00)),
                goingDuration:response.goingDuration,
                comingDuration:response.comingDuration,
                category:response.category,
                dueDateClass:response.dueDateClass,
                location:response.location,
                attendees:response.attendees,
                recurrenceRule:response.recurrenceRule,
                color:response.color,
                bgColor:response.bgColor,
                dragBgColor:response.dragBgColor,
                borderColor:response.borderColor,
                customStyle:response.customStyle,
                raw:response.raw,
                User_RoleType:response.User_RoleType,
                Status:response.Status,
                Check_Status:response.Check_Status,
                Check_Month:response.Check_Month,
                Booking_ID:response.Booking_ID,
                commends:response.commends,
                LOA:response.LOA,
                Approved_LOA:response.Approved_LOA,
                BookingStatus:response.BookingStatus,
                Cancelled_Status:response.Cancelled_Status,
                Total_DaysBooked:response.TotalDay_Count,
                WeekDay_Count:response.WeekDay_Count,
                WeekEnd_Count:response.WeekEnd_Count,
                Total_DaysBooked_Reassign:response.Total_DaysBooked_Reassign,
                WeekDay_Count_Reassign:response.WeekDay_Count_Reassign,
                WeekEnd_Count_Reassign:response.WeekEnd_Count_Reassign,
                Booking_Type:response.Booking_Type,
                WeekDay_Count_Edit:response.WeekDay_Count_Edit,
                WeekEnd_Count_Edit:response.WeekEnd_Count_Edit,
                Total_Edit_Loa:response.Total_Edit_Loa,
                PartialCancellation_Status:response.PartialCancellation_Status,
                start_CancelledDate:response.start_CancelledDate,
                end_CancelledDate:response.end_CancelledDate,
                cancaledDays:response.cancaledDays,
                isBookingPending:response.isBookingPending,
                isBookingCancelled:response.isBookingCancelled,
                isBookingAccepted:response.isBookingAccepted,
                isNextDayBookingIncluded:response.isNextDayBookingIncluded,
                isStandByBookingIncluded:response.isStandByBookingIncluded,
                Boat_Id:response.Boat_Id,
                isAllDay:response.isAllDay,
                isPending:response.isPending,
                isFocused:response.isFocused,
                isVisible:response.isVisible,
                isReadOnly:response.isReadOnly,
                isPrivate:response.isPrivate,
                Is_StandByBooking:response.Is_StandByBooking,
                User_Id:response.User_Id,
                Admin_Id:response.Admin_Id,
                IsActive:response.IsActive,
                standByBookingId:response._id
            
            }).save().catch((error)=> console.log(error))

            //update stand by booking cancel status

               

             
            

            await  AddStandByBooking.updateOne({_id:standByBooking._id},{isOrginalBookingCanceled:true,showThisBookingInCalendar:false}).catch((error)=> console.log(error));

          
            }




            }



              console.log(Weekdays_prev,"Weekdays_prev");
              console.log(WeekEndDays_prev,"WeekEndDays_prev")
            
            //irfan

        
            console.log(Hrdif,"Hr diffe");
          

            console.log(RoleAssigned);

            var dif=Start_final.diff(moment(),'days')
       console.log(Roles)    
if(Roles=="Owner")
{
/* check boat is active*/

let checkactive = Boats.findOne({_id:mongoose.Types.ObjectId(Boat_id),Boat_Status:1}).catch((error)=> console.log(error));
if(!checkactive){

    return res.json({
        status:false,
        message: 'Boat is not active'
        })

}

 /* check boat is suspended */

let suspendcheck = await manageBoat.findOne({Boat_Id:mongoose.Types.ObjectId(Boat_id),Owner_Id:mongoose.Types.ObjectId(Owner_id)}).catch((error) => console.log(error));
if(suspendcheck.Block == false)
return res.json({
status:false,
message: 'Suspended'
})
    

 
    //***** Reduce Numbeer Of Cleans  */
    let getCleanDays = await  No_OfCleans.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id), Owner_Id: mongoose.Types.ObjectId(Owner_id) }).catch((error)=> console.log(error));
    if(getCleanDays){
        let resultCleanday=(getCleanDays.Cleans)-1;
        const updateVals = { Cleans: resultCleanday};
        const updateCond = { Boat_Id: mongoose.Types.ObjectId(Boat_id), Owner_Id: mongoose.Types.ObjectId(Owner_id) };  
        let durationupdate = await No_OfCleans.findOneAndUpdate(updateCond,updateVals).catch((error) => console.log(error));

    }

     //***** Reduce Numbeer Of Cleans  *********//
    
            Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
            .then(boatDetails=> {

                var BoatName=boatDetails.Boat_Name 
                NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                .then(async(ownerDetails)=> {

                    var OwnerName=ownerDetails.First_Name
                    var Email_id=ownerDetails.Email
                    var date=ownerDetails.Current_Time

     console.log(BoatName,OwnerName,Email_id,date)         


     
if(dif>=0)
{
   

   
            if( Hrdif<=72){

                console.log("ENTERS IN LOA");


                //set pending days back to its value

                let allocatedDays = await  manageBoat.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id }).catch((error)=> console.log(error));

                console.log(allocatedDays)

 var Loa=Math.ceil((72-Hrdif)/24);
 var Loa_Pos = Math.abs(Loa);
 console.log(Loa);
 console.log(Loa_Pos,'positv');
 
   var  WeekDay_Count=0;
   var  WeekEnd_Count=0;       
            if(Roles==RoleAssigned )
            {


                ////.....................

                var obj = Object();
                obj.start =Start_final;
                obj.end = End_final;
           
               var datas =  getDaysInMonth_Sheduler(obj);
              
               var arr=[];
              ///.................
              datas.forEach(function(item) {
                Object.keys(item).forEach(function(key) {
                    arr.push(item[key]);
                  console.log( item[key]);
                });
              });
console.log(arr)

for (let index = 0; index <Loa_Pos; ++index) {
    console.log(arr[index]);
    let day = arr[index];

    if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
    
        WeekDay_Count=WeekDay_Count+1;
        console.log('Del1')
    }
    else
    {
        WeekEnd_Count= WeekEnd_Count+1;

    }

}
console.log(WeekDay_Count)
console.log( WeekEnd_Count)
  var Total_Count=0;
  Total_Count= WeekDay_Count+ WeekEnd_Count;
  console.log(Total_Count,'Del2')
  var WeekDay_Counts=WeekDay_Count;
  var WeekEnd_Counts=WeekEnd_Count; 

   ///////   Raga Set LOA FOR PRELAUNCH //////

  
  if(response.Booking_Type == "prelaunch and launch booking"){

    let getBetweenScheduleDates = getDaysBetweenDatesYearFirst(response.start,response.end);

    let DeletingCurntDate   = new Date();

    let threeDays72    = new Date();

     threeDays72.setDate(threeDays72.getDate() + 3);

    let betweenLoaDays        =  getDaysBetweenDatesYearFirst(DeletingCurntDate,threeDays72);

    const ResfilteredArray = betweenLoaDays.filter(value => getBetweenScheduleDates.includes(value));

    if(ResfilteredArray.length == 1){

        var newScheduleStartDate  = ResfilteredArray[0];

        var newScheduleEndDate  = ResfilteredArray[0];
        
    }else{

        var newScheduleStartDate  = ResfilteredArray[0];

        var newScheduleEndDate  = ResfilteredArray[(ResfilteredArray.length)-1];

    }


    await new Schedule({
        Boat_Name:response.Boat_Name,
        calendarId:response.calendarId,
        title:"Loas (Booking)",
        body:response.body,
        start:newScheduleStartDate,
        end:newScheduleEndDate,
      
        start_NoTime:new Date(new Date(newScheduleStartDate).setUTCHours(00,00,00,00)),
        end_NoTime:new Date(new Date(newScheduleEndDate).setUTCHours(00,00,00,00)),
        goingDuration:response.goingDuration,
        comingDuration:response.comingDuration,
        category:response.category,
        dueDateClass:response.dueDateClass,
        location:response.location,
        attendees:response.attendees,
        recurrenceRule:response.recurrenceRule,
        color:response.color,
        bgColor:response.bgColor,
        dragBgColor:response.dragBgColor,
        borderColor:response.borderColor,
        customStyle:response.customStyle,
        raw:response.raw,
        User_RoleType:"Owner",
        Status:response.Status,
        Check_Status:response.Check_Status,
        Check_Month:response.Check_Month,
        Booking_ID:response.Booking_ID,
        commends:response.commends,
        LOA:response.LOA,
        Approved_LOA:response.Approved_LOA,
        BookingStatus:"",
        Cancelled_Status:1,
        Total_DaysBooked:ResfilteredArray.length,
        WeekDay_Count:WeekDay_Count,
        WeekEnd_Count:WeekEnd_Count,
        Total_DaysBooked_Reassign:response.Total_DaysBooked_Reassign,
        WeekDay_Count_Reassign:response.WeekDay_Count_Reassign,
        WeekEnd_Count_Reassign:response.WeekEnd_Count_Reassign,
        Booking_Type:response.Booking_Type,
        WeekDay_Count_Edit:response.WeekDay_Count_Edit,
        WeekEnd_Count_Edit:response.WeekEnd_Count_Edit,
        Total_Edit_Loa:response.Total_Edit_Loa,
        PartialCancellation_Status:response.PartialCancellation_Status,
        start_CancelledDate:response.start_CancelledDate,
        end_CancelledDate:response.end_CancelledDate,
        cancaledDays:response.cancaledDays,
        isBookingPending:response.isBookingPending,
        isBookingCancelled:response.isBookingCancelled,
        isBookingAccepted:response.isBookingAccepted,
        isNextDayBookingIncluded:response.isNextDayBookingIncluded,
        isStandByBookingIncluded:response.isStandByBookingIncluded,
        Boat_Id:response.Boat_Id,
        isAllDay:response.isAllDay,
        isPending:response.isPending,
        isFocused:response.isFocused,
        isVisible:response.isVisible,
        isReadOnly:response.isReadOnly,
        isPrivate:response.isPrivate,
        Is_StandByBooking:response.Is_StandByBooking,
        User_Id:response.User_Id,
        Admin_Id:null,
        IsActive:false,
        standByBookingId:response._id,
        Booking_Type:response.Booking_Type
    
    }).save().catch((error)=> console.log(error))
    

  }
  
    ///////   Raga End LOA FOR PRELAUNCH //////

    //set pending days back to its value      
    
    //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
    //is active is not here before
  Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
    {
        let stopExecution = {stop:false}
        let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
            console.log(error)
             stopExecution = error
        })


        if(stopExecution.stop){
            return res.json({status:true,message:stopExecution.error})
        }

        if(isAvailableDay && isAvailableDay.status && response.Booking_Type!='prelaunch and launch booking')//check Date Between Summer Dates
        {

            //reassigning
          
            OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                {
                    console.log(result)
                    var S_day=result.Summer_WeekDays;
                    var E_day=result.Summer_WeekEndDays;

                    if(S_day >= Weekdays_prevWeekdays_prev)
                    var remSday = S_day-Weekdays_prevWeekdays_prev;
                    else
                    var remSday = S_day;

                    if((E_day >= Weekdays_prevWeekdays_prev))
                    var remEday = E_day-WeekEndDays_prev;
                    else
                    var remEday = E_day;
                 
            OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
                { 
                    
                    Boat_Id:Boat_id,
                    Owner_Id:Owner_id,
                    Summer_WeekDays:remSday,
                    Summer_WeekEndDays:remEday,
                    IsActive:true,
                    Current_Time:moment(Date.now()),
                    Updated_time: moment(Date.now())
                },
                  
                    function(err, data) {
                   
                        console.log('Deletion1')
                });
            })
        } 
        else
        {

             ///  Owner Booking Days Were allowed only for Season Booking
            if(response.Booking_Type!='prelaunch and launch booking'){

                OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                    {
                    
                    
                    var WS_day=result.Winter_WeekDays;
                    var WE_day=result.Winter_WeekEndDays;  
                    
                    if(WS_day >= Weekdays_prev)
                    var remWS_day = WS_day-Weekdays_prev;
                    else
                    var remWS_day = WS_day;
                    
                    if(WE_day >= WeekEndDays_prev)
                    var remWE_day = WE_day-WeekEndDays_prev;
                    else
                    var remWE_day = WE_day;
                    
                    
                    
                    OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
                    { 
                    
                    Boat_Id:Boat_id,
                    Owner_Id:Owner_id,
                    Winter_WeekDays:remWS_day,
                    Winter_WeekEndDays:remWE_day,
                    IsActive:true,
                    Current_Time:moment(Date.now()),
                    Updated_time: moment(Date.now())
                    },
                    
                    function(err, data) {
                    
                    console.log('Deletion2')
                    });
                    })
                    
            }

          
//reassigning


console.log("Saving to Ownerpartialcancel table ");
let getcaceldates_only=getDaysBetweenDatesFormat(response.start,response.end);
let ownerPartial = new OwnerPartialCancelation();
ownerPartial.Scheduleid = scheduleid;
 ownerPartial.Boat_Id = response.Boat_Id;
 ownerPartial.Owner_Id = response.User_Id;
 ownerPartial.Boat_Name=response.Boat_Name;
 ownerPartial.cancaledDays=getcaceldates_only;
 ownerPartial.StartDate = response.start;
 ownerPartial.Enddate = response.end;
 ownerPartial.Booking_ID = response.Booking_ID;
 ownerPartial.LOA=Loa_Pos;
 ownerPartial.WeekDay_Count=WeekDay_Counts;
 ownerPartial.WeekEnd_Count=WeekEnd_Counts;
 ownerPartial.WeekDay_Count_Edit=response.WeekDay_Count_Edit;
 ownerPartial.WeekEnd_Count_Edit=response.WeekEnd_Count_Edit;
 ownerPartial.Total_Edit_Loa=response.Total_Edit_Loa;
 ownerPartial.PartialCancellation_Status=response.PartialCancellation_Status;
 ownerPartial. BookingStatus="Accepted";
ownerPartial.save(function(err,saved){
 if(err){
   return;
 }

});

//reassigning

        }
    
})



 //set pending days back to its value

  
 
    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
        
      
        IsActive:false,
        Cancelled_Status:1,
        Updated_time: moment(Date.now()),
        LOA:Loa_Pos,
        WeekDay_Count:WeekDay_Counts,
        WeekEnd_Count:WeekEnd_Counts,
        delStatus:1
     
    },
      
       async function(err, data) {

        console.log("FENTER");

                
            //mail   


    const emailState =  'Booking Cancelled.';
    const emailContent = `Dear ${OwnerName} your booking on Boat ${BoatName} on ${date} has been successfully cancelled `;
    const emailContentAdmin = `Dear Administrator,The Boat ${BoatName}  on ${date} has been successfully cancelled `
    const emailDetailName = 'Cancellation Details'
    const emailDetails = [
      { key: 'Boat Name', value:  BoatName },
     
    ];
    const emailNameAndLink = {
      name:'Booking Link',
      link:`${process.env.CLIENT_URL}/boat-bookings`
    }
           
            
                var mailOptions = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                       
                };
            
                transporter.sendMail(mailOptions, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            message: 'Successfully send'
                        })
                    }
                });           
            
                var mailOptionsAdmin = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                     html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                        
              
                };

                transporter.sendMail(mailOptionsAdmin, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            message: 'Successfully send'
                        })
                    }
                }); 
            //mail


        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
            console.log("ENTERED LOA TABLE");

            res.json({
            
                status:true,
                Loa:Loa_Pos,
                Weekday:WeekDay_Counts,
                WeekEnd:WeekEnd_Counts,
                message:'Schedule details deleted successfully.' +'  ' +' '+' ' + 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
               })
        }
    }); 


}
else
{
    res.json({

        status:true,
        message: 'This booking is owned by an owner. Only an allowed user can delete this booking.'
       })


}
            }
            else
            {
       //set pending days back to its value
       //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
        //is active is not here before
                Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                    {
                        let stopExecution = {stop:false}
                        let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                            console.log(error)
                            stopExecution = error
                        })


                        if(stopExecution.stop){
                            return res.json({status:true,message:stopExecution.error})
                        }

                        if(isAvailableDay && isAvailableDay.status && response.Booking_Type!='prelaunch and launch booking')//check Date Between Summer Dates
                        {

                             //check if next booking included


                            //reassigning
                          
                            OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                                {
                                    console.log(result)
                                    var S_day=result.Summer_WeekDays;
                                    var E_day=result.Summer_WeekEndDays;

                                    if(S_day >= Weekdays_prev)
                                    var remS_day = S_day-Weekdays_prev;
                                    else
                                    var remS_day = S_day;

                                    if(E_day >= WeekEndDays_prev)
                                    var remE_day = E_day-WeekEndDays_prev;
                                    else
                                    var remE_day = E_day;
                                 
                            OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
                                { 
                                    
                                    Boat_Id:Boat_id,
                                    Owner_Id:Owner_id,
                                    Summer_WeekDays:remS_day,
                                    Summer_WeekEndDays:remE_day,
                                    IsActive:true,
                                    Current_Time:moment(Date.now()),
                                    Updated_time: moment(Date.now())
                                },
                                  
                                    function(err, data) {
                                   
                                        console.log('Deletion3')
                                });
                            })
                        } 
                        else
                        {

                            if(response.Booking_Type!='prelaunch and launch booking'){

                                OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                                    {
                                        console.log(result)
                                        var WS_day=result.Winter_WeekDays;
                                        var WE_day=result.Winter_WeekEndDays;
                                        
                                        if(WS_day >= Weekdays_prev)
                                        var remWS_day =WS_day-Weekdays_prev;
                                        else
                                        var remWS_day = WS_day;
                                
                                        if(WE_day >= WeekEndDays_prev)
                                        var remWE_day = WE_day-WeekEndDays_prev;
                                        else
                                        var remWE_day = WE_day;
                                     
                                OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
                                    { 
                                        
                                        Boat_Id:Boat_id,
                                        Owner_Id:Owner_id,
                                        Winter_WeekDays:remWS_day,
                                        Winter_WeekEndDays:remWE_day,
                                        IsActive:true,
                                        Current_Time:moment(Date.now()),
                                        Updated_time: moment(Date.now())
                                    },
                                      
                                        function(err, data) {
                                       
                                       console.log('Deletion4')
                                    });
                                })
                                

                            }
//reassigning


//reassigning

                        }
                    
                })
        //set pending days back to its value                              
                Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
                { 
                  
                    IsActive:false,
                    Cancelled_Status:1,
                    Updated_time: moment(Date.now()),
                    LOA:0,
                    WeekDay_Count:0,
                    WeekEnd_Count:0,
                    delStatus:1
                },
                  
                    function(err, data) {

                //mail           

                const emailState =  'Booking Cancelled.';
                const emailContent = `Dear ${OwnerName} your booking on Boat ${BoatName} on ${date} has been successfully cancelled `;
                const emailContentAdmin = `Dear Administrator,The Boat ${BoatName}  on ${date} has been successfully cancelled `
                const emailDetailName = 'Cancellation Details'
                const emailDetails = [
                  { key: 'Boat Name', value:  BoatName },
                 
                ];
                const emailNameAndLink = {
                  name:'Booking Link',
                  link:`${process.env.CLIENT_URL}/boat-bookings`
                }
            
                var mailOptions = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)



                };
            
                transporter.sendMail(mailOptions, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                });           
            
                var mailOptionsAdmin = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                };

                transporter.sendMail(mailOptionsAdmin, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                });  

            //mail


                    if(err){
                        res.json({ 
                            status:false,
                            message: 'AN ERROR OCCURED'
                        })
                    }
                    else{
                      console.log("ENTERD LOA @");
                        res.json({
                          
                            status:true,
                            Loa:0,
                            Weekday:0,
                            WeekEnd:0,
                            message:'Schedule details deleted successfully.' +'  ' +' '+' ' + 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                           })
                    }
                }); 

            }
        }

        else
        {
            res.json({ 
                status:false,
                message: 'Booking on a previous day cannot be cancelled'
            })

        }
})
})
}
else
{

    const boatDetails = await Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).catch((error)=> console.log(error)) || {}
            
    let BoatName = boatDetails.Boat_Name;
    let date = getCurrentTimeFormatted()


    if(dif>=0)
    {
      
    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        IsActive:false,
        Cancelled_Status:1,
        Updated_time: moment(Date.now()),
        LOA:0,
        Weekday:0,
        WeekEnd:0,
        delStatus:1
    },
      
        function(err, data) {

    //mail   
    

    const emailState =  'Booking Cancelled.';
    const emailContentAdmin = `Dear Administrator,The Boat ${BoatName}  on ${date} has been successfully cancelled `
    const emailDetailName = 'Cancellation Details'
    const emailDetails = [
      { key: 'Boat Name', value:  BoatName },
     
    ];
    const emailNameAndLink = {
      name:'Booking Link',
      link:`${process.env.CLIENT_URL}/boat-bookings`
    }
                    

    var mailOptionsAdmin = {
       
        from:"noreply.smartboatbooking@gmail.com",
        to: "bookingsystem@smartboating.com.au",
        subject: 'Booking Cancellation',
        html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
    };

    transporter.sendMail(mailOptionsAdmin, function (error, info) {
        if (error) {
            console.log(error);
        } else {
            res.json({
                status:true,
                info: 'Successfully send'
            })
        }
    });  

//mail


        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
            res.json({

                status:true,
                Loa:0,
                Weekday:0,
                WeekEnd:0,
                message: 'Schedule Details Deleted Successfully'
               })
        }
    }); 
}
else
{
    res.json({ 
        status:false,
        message: 'Booking on a previous day cannot be cancelled'
    })
}
}       
    } // if end check response
    else{
         return res.json({

            status:false,
            message:"Permission Denied"

         });
    }
})
 // flag for if
} 

/// END DeleteSchedule
const GetBoatNames = (req, res, next) => { 
    const searchletter=req.body.alphabet
    let re = new RegExp(searchletter,'i') 
    console.log(searchletter)
    Boats.find({IsActive:true,Boat_Status:1,"Boat_Name":re}).sort({Boat_Name:1}).select({_id:1,Boat_Name:1,Boattype_Name:1,Location_Id:1,Location_Name:1})
        .then(response => {
            res.send({
                response
            })
        })
        .catch(error => {
            res.json({
                message: error
            })
        })
}

//edit jibin 8/26/2021




const ViewBookingDetailsWithBoatAndOwner = async(req, res, next) => {

    let partialcancel = await OwnerPartialCancelation.find({}).catch((error)=> console.log(error));
    mongoose.model('Tb_Schedule').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        {
            "$match": { IsActive:true
            }
        }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,commends:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Is_StandByBooking:1,IsActive:1,Booking_ID:1,Booking_Type:1,WeekEnd_Count:1,WeekDay_Count:1,WeekDay_Count_Edit:1,WeekEnd_Count_Edit:1,WeekDay_Count_Reassign:1,WeekEnd_Count_Reassign:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "OwnerDetails.Sailing_Ability":1,
    "OwnerDetails.Last_Name":1,
    "OwnerDetails.Family_Name":1,
    "OwnerDetails.Emergency_Contact_Mobile":1,
    "OwnerDetails.Email":1,
    "OwnerDetails.Emergency_Contact_Name":1,
    "OwnerDetails.Home_Address":1,
    "OwnerDetails.Housekeeping":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.IsActive":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
     "BoatDetails.SummerSeason_SDate":1,
    "BoatDetails.SummerSeason_EDate":1,
    "BoatDetails.WinterSeason_SDate":1,
    "BoatDetails.WinterSeason_EDate":1,
    
    
          
    }
    }
    ]
    ).exec(function(err, response){

        // var response = responses.map(function(el){
        //     el.BoatDetails = el.BoatDetails.filter(function(x){ return x.IsActive ==true; });
        //     return el;
        // });
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
        //cancelled
        mongoose.model('Tb_Schedule').aggregate(
            [
            {
            "$lookup":{
            "from":"tb_addowners",
            "localField": "User_Id",
            "foreignField": "_id",
            "as": "OwnerDetails"
            }
           },
            {
                "$lookup": {
                    "from": "tb_boatmasters",
                    "localField": "Boat_Id",
                    "foreignField": "_id",
                    "as": "BoatDetails"
                }
            },
            
                {
                    "$match": { IsActive:false
                    }
                }, 
                {$sort: {"_id": -1}},
            
            {
            $project:{
                calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Booking_ID:1,LOA:1,BookingStatus:1,Approved_LOA:1,WeekEnd_Count:1,WeekDay_Count:1,WeekDay_Count_Edit:1,WeekEnd_Count_Edit:1,WeekDay_Count_Reassign:1,WeekEnd_Count_Reassign:1,

            "OwnerDetails.Profile_Image":1,
            "OwnerDetails.First_Name":1,
            "OwnerDetails.Mobile":1,
            "OwnerDetails.Parking_Ability":1,
            "BoatDetails.Location_Name":1,
            "BoatDetails.Boattype_Name":1,
            "BoatDetails.Location_Id":1,
            "BoatDetails._id":1, 
            "BoatDetails.Boattype_id":1,
            "BoatDetails.Boat_Name": 1,
            "BoatDetails.Boat_Number": 1,
            "BoatDetails.Boat_Facility":1,
            "BoatDetails.Boat_Description":1,
            "BoatDetails. Owners_Allowed": 1,
            "BoatDetails.Launch_Date": 1,
            "BoatDetails.PreLaunch_Date":1,
            "BoatDetails.Boat_Image": 1,
            "BoatDetails.Boat_HandBook":1,
            "BoatDetails.Boat_Status":1,
            "BoatDetails.Total_Days":1,
            "BoatDetails.Summer_WeekDays":1,
            "BoatDetails. Summer_WeekEndDays":1,
            "BoatDetails.Winter_WeekDays":1,
            "BoatDetails.Winter_WeekEndDays":1,
            
            
                  
            }
            }
            ]
            ).exec(function(err, Cancelledresponse){
        

        //cancelled
//standby


mongoose.model('Tb_AddStandByBooking').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        {
            "$match": { IsActive:true, showThisBookingInCalendar:true
            }
        }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Is_StandByBooking:1,IsActive:1,Booking_ID:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "OwnerDetails.Sailing_Ability":1,
    "OwnerDetails.Last_Name":1,
    "OwnerDetails.Family_Name":1,
    "OwnerDetails.Emergency_Contact_Mobile":1,
    "OwnerDetails.Email":1,
    "OwnerDetails.Emergency_Contact_Name":1,
    "OwnerDetails.Home_Address":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.IsActive":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    bookingType:"Stand by booking"
    
    
          
    }
    }
    ]
    ).exec(function(err, StandbyBooking){

//standby



            

        res.json({
            status:true,
            response,Cancelledresponse,StandbyBooking,partialcancel
        })
    })
})
    }

     })
}


//Cancelled Booking



const ViewCancelledBooking = (req, res, next) => { 

    mongoose.model('Tb_Schedule').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        // {
        //     "$match": { IsActive:false
        //     }
        // }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Booking_ID:1, LOA:1,BookingStatus:1,Approved_LOA:1,WeekEnd_Count:1,WeekDay_Count:1,WeekDay_Count_Edit:1,WeekEnd_Count_Edit:1,Total_Edit_Loa:1,PartialCancellation_Status:1,start_CancelledDate:1,end_CancelledDate:1,cancaledDays:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    
          
    }
    }
    ]
    ).exec(function(err, response){
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
        res.json({
            status:true,
            response
        })

    }
     })
}


const ViewCancelledBookingNew = (req, res, next) => { 

    mongoose.model('owner_partialcancelations').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "Owner_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        // {
        //     "$match": { IsActive:false
        //     }
        // }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        Scheduleid:1,Booking_ID:1, LOA:1,BookingStatus:1,Approved_LOA:1,WeekEnd_Count:1,WeekDay_Count:1,WeekDay_Count_Edit:1,WeekEnd_Count_Edit:1,Total_Edit_Loa:1,PartialCancellation_Status:1,start_CancelledDate:1,end_CancelledDate:1,cancaledDays:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    
          
    }
    }
    ]
    ).exec(function(err, response){
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
        res.json({
            status:true,
            response
        })

    }
     })
}




//Get Booking By Boat Id

//Add Booking Days For Owner



function AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
{

    console.log("Inside AddBookingDays_Owner");
    console.log(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
    console.log('hey hey heyy');
  
    console.log(WeekDay_Count,"WeekDay_Count")
    console.log(WeekEnd_Count,"WeekEnd_Count")

var Start_final=moment(start_Date);
var Start_final_withoutTime=Start_final.startOf('day');

var End_final=moment(end_Date);
var End_final_withoutTime=End_final.startOf('day');

//SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},

    Boats.findOne({_id:Boat_id,IsActive:true}).then(async(BoatresultsSummer)=>
        {          

            let stopExecution = {stop:false}
            let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,BoatresultsSummer.SummerSeason_SDate,BoatresultsSummer.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                console.log(error)
                stopExecution = error
            })


            if(stopExecution.stop){
                return res.json({status:true,message:stopExecution.error})
            }

            if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
            {

  
         

    OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
        {

                 
        if(result==null)
        {

                  
             let AddBookingDays_Owner= new OwnerBooking_Days({                  
            
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                Summer_WeekDays:WeekDay_Count,
                Summer_WeekEndDays:WeekEnd_Count,
                IsActive:true,
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
    
            });
             
            AddBookingDays_Owner.save()
                .then(response => {
                    return true;
                })
                .catch(error => {
                    console.log(error)
                    return  false;
                })
            
        }

        else
        {
            console.log('updation1')
            OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                {
                    
                    var S_day=result.Summer_WeekDays;
                    var E_day=result.Summer_WeekEndDays;
                 
                    console.log(S_day,"S_day")
                    console.log(E_day,"E_day")
            OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
            { 
                
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                Summer_WeekDays:WeekDay_Count+S_day,
                Summer_WeekEndDays:WeekEnd_Count+E_day,
                IsActive:true,
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
            },
              
                function(err, data) {
                if(err){
                    console.log('fail')
                    return false
                  
                }
                else{
                  console.log('success')
                    return true
                    
                }

            });
        })
        }
     
    });
}
else
{
//winter
console.log('iam here')
OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
    {
       

        console.log(result,"check if exist")
      
    if(result==null)
    {
console.log('iam here')
    
      
         let  AddBookingDays_Owner= new OwnerBooking_Days({                  
        
            Boat_Id:Boat_id,
            Owner_Id:Owner_id,
            Winter_WeekDays:WeekDay_Count,
            Winter_WeekEndDays:WeekEnd_Count,
            IsActive:true,
            Current_Time:moment(Date.now()),
            Updated_time: moment(Date.now())

        });
         
        AddBookingDays_Owner.save()
            .then(response => {

                return true
            })
            .catch(error => {
                console.log(error)
               return false
            })
        
    }

    else
    {
        OwnerBooking_Days.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
            {
                console.log(result)
                var WS_day=result.Winter_WeekDays;
                var WE_day=result.Winter_WeekEndDays;      

                console.log(result,"existing booked data")  

                console.log(WS_day,WE_day, "WS AND WE DAYS");

                console.log("WeekDay_Count+WS_day",WeekDay_Count+WS_day);

                console.log("WeekEnd_Count+WE_day",WeekEnd_Count+WE_day);

                console.log({Boat_Id:Boat_id,Owner_Id:Owner_id});

console.log('in Updation winter');
OwnerBooking_Days.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
        { 
            
            Boat_Id:Boat_id,
            Owner_Id:Owner_id,
            Winter_WeekDays:WeekDay_Count+WS_day,
            Winter_WeekEndDays:WeekEnd_Count+WE_day,
            IsActive:true,
            Current_Time:moment(Date.now()),
            Updated_time: moment(Date.now())
        },

        {new:true},
          
            function(err, data) {
            if(err){
                console.log(err,"error in updateing pending days")
                return false
            }
            else{
                console.log(data,"updated data")
                console.log('sucesssss')
                return true
             
            }

        });
    })
    }
 
});


//winter
}
})
   
};


//Add Booking Days For Owner

//get Owner Pending Days
//get Owner Pending Days
const GetAllPendingDaysOfOwner = async (req, res, next) => {
    var Owner_id = mongoose.Types.ObjectId(req.body.Owner_Id);
    var Boat_id = mongoose.Types.ObjectId(req.body.Boat_Id);
    var arr = [];
   
  //reset start
    //Check duration and current year and lastly reseted year then if it is not matched reset reset booked dates to allocated dates
  
   

    let currentTime = new Date().getTime();

    
   
  
   let durationData = await Duration.findOne({ Boat_Id: Boat_id, IsActive: true, Owner_Id: Owner_id }).catch((error)=> console.log(error))
   
   var ExpiryDateDuration="";
   
   if(durationData){

    var ExpiryDateDuration =  durationData.Duration_EDate;

       console.log(new Date(currentTime));

       console.log(new Date(durationData.lastResetedAnniversary));

       console.log(currentTime);
       console.log(durationData.lastResetedAnniversary)


    if(currentTime >= durationData.lastResetedAnniversary){

       console.log("inside grrater anivers")
        
        let allocatedDays = await  manageBoat.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id }).catch((error)=> console.log(error));
        let bookedDays = await OwnerBooking_Days.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id }).catch((error) => console.log(error))
        
        //if there is no booked day create one


        if(!bookedDays){

          

            bookedDays = await new OwnerBooking_Days({
                Summer_WeekDays:0,
                Summer_WeekDays:0,
                Winter_WeekDays:0,
                Winter_WeekDays:0,
                IsActive:true,
                Boat_Id:Boat_id,
                Owner_Id:Owner_id
            }).save().catch(error => console.log(error))


          
        }

        
        //reset 
        if(allocatedDays && bookedDays){

            
                //taking backup of pending days and saving it to array 

            let currentYear = moment(new Date()).format('YYYY');

            let pendingDaysData = {}
            pendingDaysData[currentYear] = {
                Summer_WeekDays:bookedDays.Summer_WeekDays,
                Summer_WeekEndDays:bookedDays.Summer_WeekEndDays,
                Winter_WeekDays:bookedDays.Winter_WeekDays,
                Winter_WeekEndDays:bookedDays.Winter_WeekEndDays

            }
            bookedDays.previousYearsPendingDaysData = bookedDays.previousYearsPendingDaysData.concat([pendingDaysData]) 


      
        bookedDays.Summer_WeekDays = 0;
        bookedDays.Summer_WeekEndDays = 0;
        bookedDays.Winter_WeekDays = 0;
        bookedDays.Winter_WeekEndDays = 0;
      
        await bookedDays.save().catch((error)=> console.log(error))
        let currentAnniversary = new Date(durationData.lastResetedAnniversary)
        console.log(new Date(currentAnniversary))
        let nextAnniversary = currentAnniversary.setFullYear(currentAnniversary.getFullYear() + 1)
        console.log(new Date(nextAnniversary))
        durationData.lastResetedAnniversary = nextAnniversary;
        await durationData.save().catch((error)=> console.log(error))
        }
        } 
   }
  
   
  
  //reset end
   
  
    mongoose
      .model("Tb_OwnerBookingDays")
      .aggregate([
        {
          $lookup: {
            from: "tb_boatmasters",
            localField: "Boat_Id",
            foreignField: "_id",
            as: "BoatDetails",
          },
        },
        {
          $match: { Owner_Id: Owner_id, Boat_Id: Boat_id },
        },
        {
          $project: {
            Summer_WeekDays: 1,
            Summer_WeekEndDays: 1,
            Winter_WeekDays: 1,
            Winter_WeekEndDays: 1,
  
            "BoatDetails.Launch_Date": 1,
            "BoatDetails.PreLaunch_Date": 1,
            // "BoatDetails.Winter_WeekDays": 1,
            // "BoatDetails.Winter_WeekEndDays": 1,
          },
        },
      ])
      .exec(function (err, BookedDays) {
        manageBoat.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id }).then((OwnerAllocationDays) => {
          Boats.findOne({ _id: Boat_id }).then((LaunchPreLaunch) => {
            console.log(LaunchPreLaunch.Launch_Date);
            var AllocatedDays = [];
            AllocatedDays.push({
              Summer_WeekDays: OwnerAllocationDays.Summer_WeekDays,
              Summer_WeekEndDays: OwnerAllocationDays.Summer_WeekEndDays,
              Winter_WeekDays: OwnerAllocationDays.Winter_WeekDays,
              Winter_WeekEndDays: OwnerAllocationDays.Winter_WeekEndDays,
              Launch_Date: LaunchPreLaunch.Launch_Date,
              PreLaunch_Date: LaunchPreLaunch.PreLaunch_Date,
            });
  
            res.json({
              status: true,
              Response: { BookedDays, AllocatedDays,"ExpiryDate": ExpiryDateDuration.replace(/-/g, "/")},
            });
          });
        });
      });
  };
  



//get Owner Pending Days

// Accept reject



const StandByBooking_AcceptReject = (req, res, next) => {
    const bookingid = req.body._id
    const actions=req.body.action_todo;
    
    AddStandByBooking.findById({_id:mongoose.Types.ObjectId(bookingid)}).then(async(response)=>
        { 
          var ownerid=response.User_Id;
          var boatname=response.Boat_Name;
          var  starttime=response.start;
          var  endtime=response.end;
          var Booked_time= response.Current_Time;
          console.log("fff");
          let suspendcheck = await manageBoat.findOne({Boat_Id:mongoose.Types.ObjectId(response.Boat_Id),Owner_Id:mongoose.Types.ObjectId(ownerid)}).catch((error) => console.log(error));
          if(suspendcheck.Block == false)
          return res.json({
          status:false,
          message: 'Suspended'
          })
          
    if(actions=="Accept")
{
 
        const ogWeekendDaysCount = response.WeekEnd_Count;
        const ogWeekDaysCount = response.WeekDay_Count;
        const ogTotalDaysCount = response.TotalDay_Count;
          
            console.log(response,'response in StandByBooking_AcceptReject')
            // check if stand by booking need to be merged

            const dayBeforeIncomingStartDate = new Date(new Date(new Date(starttime).setDate(new Date(starttime).getDate() -1)).setUTCHours(00,00,00,00));
            const dayAfterIncomingEndDate = new Date(new Date(new Date(endtime).setDate(new Date(endtime).getDate() +1)).setUTCHours(00,00,00,00));

            console.log(dayBeforeIncomingStartDate,"dayBeforeIncomingStartDate")
            console.log(dayAfterIncomingEndDate,"dayAfterIncomingEndDate")


            const bookingBeforeStandByBooking = await Schedule.findOne({Boat_Id:response.Boat_Id,User_Id:response.User_Id,IsActive:true,$and:[{start_NoTime:{$lte:dayBeforeIncomingStartDate}},{end_NoTime:{$gte:dayBeforeIncomingStartDate}}]}).catch((error)=> console.log(error))
            const bookingAfterStandByBooking = await Schedule.findOne({Boat_Id:response.Boat_Id,User_Id:response.User_Id,IsActive:true,$and:[{start_NoTime:{$lte:dayAfterIncomingEndDate}},{end_NoTime:{$gte:dayAfterIncomingEndDate}}]}).catch((error)=> console.log(error))
            
            bookingBeforeStandByBooking &&   console.log("bookingBeforeStandByBooking found")
            bookingAfterStandByBooking &&   console.log("bookingAfterStandByBooking found")
            
            // if bookingBeforeStandByBooking and bookingAfterStandByBooking found change start and end date and also change totalday count weekday count weekend count

            if(bookingBeforeStandByBooking && bookingAfterStandByBooking){
                response.start = bookingBeforeStandByBooking.start
                response.end = bookingAfterStandByBooking.end
                response.start_NoTime = bookingBeforeStandByBooking.start_NoTime
                response.end_NoTime = bookingAfterStandByBooking.end_NoTime

                response.TotalDay_Count = response.TotalDay_Count + bookingBeforeStandByBooking.Total_DaysBooked + bookingAfterStandByBooking.Total_DaysBooked;
                response.WeekDay_Count = response.WeekDay_Count + bookingBeforeStandByBooking.WeekDay_Count + bookingAfterStandByBooking.WeekDay_Count;
                response.WeekEnd_Count = response.WeekEnd_Count + bookingBeforeStandByBooking.WeekEnd_Count + bookingAfterStandByBooking.WeekEnd_Count;

                //now delete both bookingBeforeStandByBooking and bookingAfterStandByBooking by that i mean update it IsActive:false

               await Schedule.updateMany({$or:[{_id:bookingBeforeStandByBooking._id},{_id:bookingAfterStandByBooking._id}]},{IsActive:false}).catch((error)=> console.log(error))
            }else if(bookingBeforeStandByBooking){
                response.start = bookingBeforeStandByBooking.start
                response.start_NoTime = bookingBeforeStandByBooking.start_NoTime

                response.TotalDay_Count = response.TotalDay_Count + bookingBeforeStandByBooking.Total_DaysBooked;
                response.WeekDay_Count = response.WeekDay_Count + bookingBeforeStandByBooking.WeekDay_Count;
                response.WeekEnd_Count = response.WeekEnd_Count + bookingBeforeStandByBooking.WeekEnd_Count;

                //now delete bookingBeforeStandByBooking

                await Schedule.updateOne({_id:bookingBeforeStandByBooking._id},{IsActive:false}).catch((error)=> console.log(error))

            }else if(bookingAfterStandByBooking){
                response.end = bookingAfterStandByBooking.end
                response.end_NoTime = bookingAfterStandByBooking.end_NoTime

                response.TotalDay_Count = response.TotalDay_Count +  bookingAfterStandByBooking.Total_DaysBooked;
                response.WeekDay_Count = response.WeekDay_Count +  bookingAfterStandByBooking.WeekDay_Count;
                response.WeekEnd_Count = response.WeekEnd_Count +  bookingAfterStandByBooking.WeekEnd_Count;

                //now delete bookingAfterStandByBooking

                await Schedule.updateOne({_id:bookingAfterStandByBooking._id},{IsActive:false}).catch((error)=> console.log(error))
    
            }


            
            var obj=Object();
            obj.body=response;
            jsonObject =obj;

            console.log(jsonObject,'json object passed to AddScheduleStandByBooking')

           

            AddScheduleStandByBooking(jsonObject,ogWeekendDaysCount,ogWeekDaysCount,ogTotalDaysCount).then(()=>{

                AddStandByBooking.findByIdAndUpdate({_id:mongoose.Types.ObjectId(bookingid)}, 
                { 
                  
                    BookingStatus :"Accepted",
                    IsActive:false,
                    Updated_time: moment(Date.now())
                 
                },
                  
                    function(err, data) {
                    if(err){
                        
                    }
                    else{
            //mail   
            NewOwners.findById({_id:mongoose.Types.ObjectId(ownerid)}).then(Ownerresponse=>
                { 
                var Email_id=Ownerresponse.Email;
                //mail
                  
           const emailState =  'StandBy Booking Accepted.';
           const emailContent = `Dear ${Ownerresponse.First_Name} the StandBybooking for Boat ${boatname} has accepted by smartBoating on ${getCurrentTimeFormatted()}`;
           const emailContentAdmin = `Dear Adminsistrator you have accepted the standby booking for the owner ${Ownerresponse.First_Name} the StandBybooking for Boat ${boatname} has accepted by smartBoating on ${getCurrentTimeFormatted()}`;
           const emailDetailName = 'Booking Details'
           const emailDetails = [
             { key: 'Boat Name', value: boatname  },
             { key: 'Booking Date', value: Booked_time },
           ];
           const emailNameAndLink = {
             name:'Booking  Link',
             link:`${process.env.CLIENT_URL}/boat-bookings`
           }
            
            var mailOptions = {
               
                from:"noreply.smartboatbooking@gmail.com",
                to: Email_id,
                subject: 'Standby Booking Accepted',
                html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                   
                
            };
            
            transporter.sendMail(mailOptions, function (error, info) {
               
            });           
            
            var mailOptionsAdmin = {
               
                from:"noreply.smartboatbooking@gmail.com",
                 to: "admin@smartboating.com.au",
                subject: 'Standby Booking Accepted',
                 html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                    
               
            };
            
            transporter.sendMail(mailOptionsAdmin, function (error, info) {
            
               
                
            }); 
            //mail
            res.json({
                status:true,
                message: 'Booking Accepted Successfully'
               })
            
            })  
                    }
                });

            }).catch((error)=>{
                res.json(error)
            })


}     
else
{
    NewOwners.findById({_id:mongoose.Types.ObjectId(ownerid)}).then(Ownerresponse=>
        { 
        var Email_id=Ownerresponse.Email;

    AddStandByBooking.findByIdAndUpdate({_id:mongoose.Types.ObjectId(bookingid)}, 
    { 
      
        BookingStatus:"Rejected",
        IsActive:false,
        Updated_time: moment(Date.now()),
        showThisBookingInCalendar:false
     
    },
      
       async function(err, data) {
           console.log("Rag::"+data);
        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
        


            //set stand by booking days to a dummy user because no one else can make this booking and every owners will see it as a red booking

            //determine stand by booking days

            //get total day saved in db and real total days differnce . differnce is how many stand booking done

            const totalDaysInDB = response.TotalDay_Count;
            const realTotalDays  = moment(new Date(endtime)).diff(moment(new Date(starttime)),"days") + 1;
            const standByBookingDaysCount = realTotalDays -totalDaysInDB;
            const allBookedDays = getDaysBetweenDates(starttime,endtime);

            const standByBookingDays = [];

            let standByBookingCounter = 0;
            while(standByBookingCounter < standByBookingDaysCount){
                standByBookingDays.push(allBookedDays[standByBookingCounter])
                standByBookingCounter++
            }

            console.log(standByBookingDays,"standByBookingDays");
            console.log(standByBookingDays[0]);
            console.log("leng:::"+standByBookingDays.length);

            if((standByBookingDays.length)==1){
            var standbybookStart = standByBookingDays[0];
            var standbyEnd = standByBookingDays[0];
            }
            else{

                var standbybookStart = standByBookingDays[0];
                var standbyEnd = standByBookingDays[1];

            }


            // generate dummy data

            /*let standbyStart = new Date(starttime);
            let crndat = new Date();
            console.log("OKK::"+crndat);
            if(crndat.getHours()<12){
                var standbyEnd = standbyStart.setDate(standbyStart.getDate() +1);
                standbyEnd = new Date(standbyEnd).toISOString();
            }else{console.log("ENN");
                var standbyEnd = new Date(starttime);
            }
            
          console.log(standbyStart+"@"+standbyEnd);*/
            await new Schedule({
                Boat_Name:response.Boat_Name,
                calendarId:response.calendarId,
                title:"Admin (Rejected Booking)",
                body:response.body,
                start:standbybookStart,
                end:standbyEnd,
                //start_NoTime:new Date(new Date(standByBookingDays[0]).setUTCHours(00,00,00,00)),
                //end_NoTime:new Date(new Date(standByBookingDays[standByBookingDays.length - 1]).setUTCHours(00,00,00,00)),
                start_NoTime:new Date(new Date(standbybookStart).setUTCHours(00,00,00,00)),
                end_NoTime:new Date(new Date(standbyEnd).setUTCHours(00,00,00,00)),
                goingDuration:response.goingDuration,
                comingDuration:response.comingDuration,
                category:response.category,
                dueDateClass:response.dueDateClass,
                location:response.location,
                attendees:response.attendees,
                recurrenceRule:response.recurrenceRule,
                color:response.color,
                bgColor:response.bgColor,
                dragBgColor:response.dragBgColor,
                borderColor:response.borderColor,
                customStyle:response.customStyle,
                raw:response.raw,
                User_RoleType:"Admin",
                Status:response.Status,
                Check_Status:response.Check_Status,
                Check_Month:response.Check_Month,
                Booking_ID:response.Booking_ID,
                commends:response.commends,
                LOA:response.LOA,
                Approved_LOA:response.Approved_LOA,
                BookingStatus:"Rejected",
                Cancelled_Status:response.Cancelled_Status,
                Total_DaysBooked:response.TotalDay_Count,
                WeekDay_Count:response.WeekDay_Count,
                WeekEnd_Count:response.WeekEnd_Count,
                Total_DaysBooked_Reassign:response.Total_DaysBooked_Reassign,
                WeekDay_Count_Reassign:response.WeekDay_Count_Reassign,
                WeekEnd_Count_Reassign:response.WeekEnd_Count_Reassign,
                Booking_Type:response.Booking_Type,
                WeekDay_Count_Edit:response.WeekDay_Count_Edit,
                WeekEnd_Count_Edit:response.WeekEnd_Count_Edit,
                Total_Edit_Loa:response.Total_Edit_Loa,
                PartialCancellation_Status:response.PartialCancellation_Status,
                start_CancelledDate:response.start_CancelledDate,
                end_CancelledDate:response.end_CancelledDate,
                cancaledDays:response.cancaledDays,
                isBookingPending:response.isBookingPending,
                isBookingCancelled:response.isBookingCancelled,
                isBookingAccepted:response.isBookingAccepted,
                isNextDayBookingIncluded:response.isNextDayBookingIncluded,
                isStandByBookingIncluded:response.isStandByBookingIncluded,
                Boat_Id:response.Boat_Id,
                isAllDay:response.isAllDay,
                isPending:response.isPending,
                isFocused:response.isFocused,
                isVisible:response.isVisible,
                isReadOnly:response.isReadOnly,
                isPrivate:response.isPrivate,
                Is_StandByBooking:response.Is_StandByBooking,
                User_Id:null,
                Admin_Id:null,
                IsActive:response.IsActive,
                standByBookingId:response._id
            
            }).save().catch((error)=> console.log(error))
        

            //


          
  //mail

  const emailState =  'StandBy Booking Rejected.';
  const emailContent = `Dear ${Ownerresponse.First_Name} the StandBybooking for Boat ${boatname} has Rejected by smartBoating on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator you have accepted the standby booking for the owner ${Ownerresponse.First_Name} the StandBybooking for Boat ${boatname} has rejected by smartBoating on ${getCurrentTimeFormatted()}`;
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value: boatname  },
    { key: 'Booking Date', value: Booked_time },
  ];
  const emailNameAndLink = {
    name:'Booking  Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }

var mailOptions = {
   
    from:"noreply.smartboatbooking@gmail.com",
    to: Email_id,
    subject: 'Standby Booking Rejected',
    html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
    
    
};

transporter.sendMail(mailOptions, function (error, info) {
    
});           

var mailOptionsAdmin = {
   
    from:"noreply.smartboatbooking@gmail.com",
    to: "admin@smartboating.com.au",
    subject: 'Standby Booking Rejected',
     html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
        
};

transporter.sendMail(mailOptionsAdmin, function (error, info) {

   
    
}); 
//mail
res.json({
    status:true,
    message: 'Booking Rejected'
   })


           
        }
    });
})
}
})  
}


//filter by Date

const ViewBookingDetailsFilterByDates= (req, res, next) =>
 { 
    var Date1 =new Date(req.body.Launch_Date1);
    var Date2 =new Date(req.body.Launch_Date2);
    var Datetype=req.body.DateType

    mongoose.model('Tb_Schedule').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        {
            "$match": { IsActive:true
            }
        }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Is_StandByBooking:1,IsActive:1,Booking_ID:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "OwnerDetails.Sailing_Ability":1,
    "OwnerDetails.Last_Name":1,
    "OwnerDetails.Family_Name":1,
    "OwnerDetails.Emergency_Contact_Mobile":1,
    "OwnerDetails.Email":1,
    "OwnerDetails.Emergency_Contact_Name":1,
    "OwnerDetails.Home_Address":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.IsActive":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    
    
          
    }
    }
    ]
    ).exec(function(err, responses){
        // var response = responses.map(function(el){
        //     el.BoatDetails = el.BoatDetails.filter(function(x){ return x.IsActive ==true; });
        //     return el;
        // });
        if(Datetype=="Launch_Date")
        {
        var response = responses.map(function(el){
            el.BoatDetails = el.BoatDetails.filter(function(x){ return (x.Launch_Date>=Date1 && x.Launch_Date<=Date2);});
            return el;
        });
    }
    else
    {
        var response = responses.map(function(el){
            el.BoatDetails = el.BoatDetails.filter(function(x){ return (x.PreLaunch_Date>=Date1 && x.PreLaunch_Date<=Date2);});
            return el;
        });

    }
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
       //cancelled
       mongoose.model('Tb_Schedule').aggregate(
        [
        {
        "$lookup":{
        "from":"tb_addowners",
        "localField": "User_Id",
        "foreignField": "_id",
        "as": "OwnerDetails"
        }
       },
        {
            "$lookup": {
                "from": "tb_boatmasters",
                "localField": "Boat_Id",
                "foreignField": "_id",
                "as": "BoatDetails"
            }
        },
        
            {
                "$match": { IsActive:false
                }
            }, 
            {$sort: {"_id": -1}},
        
        {
        $project:{
            calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Booking_ID:1,

        "OwnerDetails.Profile_Image":1,
        "OwnerDetails.First_Name":1,
        "OwnerDetails.Mobile":1,
        "OwnerDetails.Parking_Ability":1,
        "BoatDetails.Location_Name":1,
        "BoatDetails.Boattype_Name":1,
        "BoatDetails.Location_Id":1,
        "BoatDetails._id":1, 
        "BoatDetails.Boattype_id":1,
        "BoatDetails.Boat_Name": 1,
        "BoatDetails.Boat_Number": 1,
        "BoatDetails.Boat_Facility":1,
        "BoatDetails.Boat_Description":1,
        "BoatDetails. Owners_Allowed": 1,
        "BoatDetails.Launch_Date": 1,
        "BoatDetails.PreLaunch_Date":1,
        "BoatDetails.Boat_Image": 1,
        "BoatDetails.Boat_HandBook":1,
        "BoatDetails.Boat_Status":1,
        "BoatDetails.Total_Days":1,
        "BoatDetails.Summer_WeekDays":1,
        "BoatDetails. Summer_WeekEndDays":1,
        "BoatDetails.Winter_WeekDays":1,
        "BoatDetails.Winter_WeekEndDays":1,
        
              
        }
        }
        ]
        ).exec(function(err, Cancelledresponses){
    
            if(Datetype=="Launch_Date")
            {
            var Cancelledresponse = Cancelledresponses.map(function(el){
                el.BoatDetails = el.BoatDetails.filter(function(x){ return (x.Launch_Date>=Date1 && x.Launch_Date<=Date2);});
                return el;
            });
        }
        else
        {
            var Cancelledresponse = Cancelledresponses.map(function(el){
                el.BoatDetails = el.BoatDetails.filter(function(x){ return (x.PreLaunch_Date>=Date1 && x.PreLaunch_Date<=Date2);});
                return el;
            });
    
        }
    //cancelled


        res.json({
            status:true,
            response,Cancelledresponse
        })
    })
 
    }

     })

    }
//filterby Date

//approve

const ApproveCancellation = (req, res, next) => {

    var scheduleid = req.body._id;
    var Loa=req.body.LOA;
    var PartialStatus=req.body.PartialCancellation_Status;
    var TotalLoa_Edit=req.body.Total_Edit_Loa;
    var partialcnacelationid = req.body.partialcnacelationid;
   
                            
   

    Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(response=>
        { 
            

            var Boat_id=response.Boat_Id;
            var Owner_id=response.User_Id;
            var start_Date=response.start;
            var Start_final=moment(start_Date);
            console.log(start_Date)
            console.log(Start_final)
            var Start_final_withoutTime=Start_final.startOf('day');
            var end_Date=response.end;
            var End_final=moment(end_Date);
            var End_final_withoutTime=End_final.startOf('day');
            console.log(Start_final_withoutTime)
            console.log(End_final_withoutTime)
            var RoleAssigned=response.User_RoleType;
            var Cancel_date=moment();
            console.log(Cancel_date)
            var dif=moment.duration(Start_final.diff(Cancel_date));
            console.log(dif.asHours());
            var Hrdif=Math.round(dif.asHours());
        var Totalday_prev=response.Total_DaysBooked_Reassign;
        var Weekdays_prev=response.WeekDay_Count_Reassign;
        var WeekEndDays_prev=response.WeekEnd_Count_Reassign;
        console.log(Weekdays_prev,'hiiiii')
        console.log(WeekEndDays_prev,'hiiiii')
if(PartialStatus==1)
    {
        var  WeekDay_Count=req.body.WeekDay_Count_Edit;
        var  WeekEnd_Count=req.body.WeekEnd_Count_Edit;       
        var Total_Count=0;
        Total_Count= WeekDay_Count+ WeekEnd_Count;       
     
       if(TotalLoa_Edit>=Total_Count)
       {
                     Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                         {  
                             var SummerWeekdays=response.Summer_WeekDays;
                             var SummerWeekendDays=response.Summer_WeekEndDays;
                             var  WinterWeekDays=response.Winter_WeekDays;
                             var WinterweekendDays=response.Winter_WeekEndDays;

               //  SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                 //is active is not here before
                             
                             Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                 {
                                 //console.log(Boatresults)
                                    
                                 let stopExecution = {stop:false}
                                 let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                     console.log(error)
                                     stopExecution = error
                                 })
                     
                     
                                 if(stopExecution.stop){
                                     return res.json({status:true,message:stopExecution.error})
                                 }
                     
                                 if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                 {

                                     //check if next booking included

                                    
                               
                                 Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                           
                                 Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                                 Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                                 
                                 },
                                 {new: true},
                                 function(err, data) {
                                 
                                     console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                                 });
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x)
                               
                                   
                             }
                             else
                             {
         
     
                                 Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                                  
                                    Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                    Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                     
                                 },
                                 {new: true},
                                 function(err, data) {                                     
                                     console.log('Winter sucesss')
                                 });
                            
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x,'thisssss')
                                
                                 
                                        
                             }
                         })
                     })
     
     
         Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
         { 
           
             Updated_time: moment(Date.now()),
             BookingStatus:"PartiallyAccepted",
             PartialCancellation_Status:0,
             Approved_LOA:Total_Count,
          
         },
           
             function(err, data) {
             if(err){
                 res.json({ 
                     status:false,
                     message: 'AN ERROR OCCURED'
                 })
             }
             else{
                 res.json({
     
                     status:true,
                     message: 'Cancelled Successfully'
                    })
             }
         }); 
        }
        else
        {
            res.json({
     
                status:true,
                message: 'WeekDay and WeekEnd LOA must not be greater than Total LOA '
               })
        
        }
    }
    else
    {
           
   var  WeekDay_Count=req.body.WeekDay_Count;
   var  WeekEnd_Count=req.body.WeekEnd_Count;       
   var Total_Count=0;
   Total_Count= WeekDay_Count+ WeekEnd_Count;       

   if(Loa>=Total_Count)
       {
                Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                    {  
                        var SummerWeekdays=response.Summer_WeekDays;
                        var SummerWeekendDays=response.Summer_WeekEndDays;
                        var  WinterWeekDays=response.Winter_WeekDays;
                        var WinterweekendDays=response.Winter_WeekEndDays;

                        //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                         //is active is not here before
                        
                        Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                            {
                            //console.log(Boatresults)
                               
                            let stopExecution = {stop:false}
                            let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                console.log(error)
                                stopExecution = error
                            })
    
    
                            if(stopExecution.stop){
                                return res.json({status:true,message:stopExecution.error})
                            }
    
                            if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                            {

                          
                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                            {   
                                                      
                            Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                            Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                            
                            },
                            {new: true},
                            function(err, data) {
                            
                                console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                            });
                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                            console.log(x)
                          
                               

                        }
                        else
                        {


                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                            {   
                                                             
                               Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                               Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                
                            },
                            {new: true},
                            function(err, data) {
                                
                                console.log('Winter sucesss')
                            });
                       
                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                            console.log(x,'thisssss')
 

                        }
                    })
                })


    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        IsActive:false,
        Updated_time: moment(Date.now()),
        Approved_LOA:Loa,
        BookingStatus:"Accepted",

     
    },
      
        function(err, data) {
        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
            res.json({

                status:true,
                message: 'Cancelled Successfully'
               })
        }
    }); 
       }
       else
       {
        res.json({
     
            status:true,
            message: 'WeekDay and WeekEnd LOA must not be greater than Total LOA '
           })
       }
}         
})

}

//approve


const ApproveCancellationNew = async(req, res, next) => {

    var scheduleid = req.body._id;
    var Loa=req.body.LOA;
    var PartialStatus=req.body.PartialCancellation_Status;
    var TotalLoa_Edit=req.body.Total_Edit_Loa;
    var partialcancelationid = req.body.partialcancelationid;
   const condition = { _id: mongoose.Types.ObjectId(partialcancelationid)};
   const update = { LOA: 0,Approved_LOA:Loa};                      
   

    Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(response=>
        { 
            

            var Boat_id=response.Boat_Id;
            var Owner_id=response.User_Id;
            var start_Date=response.start;
            var Start_final=moment(start_Date);
            console.log(start_Date)
            console.log(Start_final)
            var Start_final_withoutTime=Start_final.startOf('day');
            var end_Date=response.end;
            var End_final=moment(end_Date);
            var End_final_withoutTime=End_final.startOf('day');
            console.log(Start_final_withoutTime)
            console.log(End_final_withoutTime)
            var RoleAssigned=response.User_RoleType;
            var Cancel_date=moment();
            console.log(Cancel_date)
            var dif=moment.duration(Start_final.diff(Cancel_date));
            console.log(dif.asHours());
            var Hrdif=Math.round(dif.asHours());
        var Totalday_prev=response.Total_DaysBooked_Reassign;
        var Weekdays_prev=response.WeekDay_Count_Reassign;
        var WeekEndDays_prev=response.WeekEnd_Count_Reassign;
        console.log(Weekdays_prev,'hiiiii')
        console.log(WeekEndDays_prev,'hiiiii')
        let booktype = response.Booking_Type;
if(PartialStatus==1)
    {
        var  WeekDay_Count=req.body.WeekDay_Count_Edit;
        var  WeekEnd_Count=req.body.WeekEnd_Count_Edit;       
        var Total_Count=0;
        Total_Count= WeekDay_Count+ WeekEnd_Count;       
     
       if((TotalLoa_Edit>=Total_Count))
       {
                     Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                         {  
                             var SummerWeekdays=response.Summer_WeekDays;
                             var SummerWeekendDays=response.Summer_WeekEndDays;
                             var  WinterWeekDays=response.Winter_WeekDays;
                             var WinterweekendDays=response.Winter_WeekEndDays;

               //  SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                 //is active is not here before
                             
                             Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                 {
                                 //console.log(Boatresults)
                                    
                                 let stopExecution = {stop:false}
                                 let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                     console.log(error)
                                     stopExecution = error
                                 })
                     
                     
                                 if(stopExecution.stop){
                                     return res.json({status:true,message:stopExecution.error})
                                 }
                     
                                 if(isAvailableDay && isAvailableDay.status && booktype!='prelaunch and launch booking')//check Date Between Summer Dates
                                 {

                                     //check if next booking included

                                    
                               
                                 Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                           
                                 Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                                 Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                                 
                                 },
                                 {new: true},
                                 function(err, data) {
                                 
                                     console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                                 });
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x)
                               
                                   
                             }
                             else
                             {

                                if(booktype!='prelaunch and launch booking'){

                                    Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                                  
                                    Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                    Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                     
                                 },
                                 {new: true},
                                 function(err, data) {                                     
                                     console.log('Winter sucesss')
                                 });
                            
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x,'thisssss')
                                
                                 

                                }
         
     
                                 
                                        
                             }
                         })
                     })
     
     
         Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
         { 
           
             Updated_time: moment(Date.now()),
             BookingStatus:"PartiallyAccepted",
             PartialCancellation_Status:0,
             Approved_LOA:Total_Count,
          
         },
           
             function(err, data) {
             if(err){
                 res.json({ 
                     status:false,
                     message: 'AN ERROR OCCURED'
                 })
             }
             else{
                let partialupdate =  OwnerPartialCancelation.findOneAndUpdate(condition,update).catch((error) => console.log(error));
                 res.json({
     
                     status:true,
                     message: 'Cancelled Successfully'
                    })
             }
         }); 
        }
        else
        {
            res.json({
     
                status:true,
                message: 'WeekDay and WeekEnd LOA must not be greater than Total LOA '
               })
        
        }

        
    }
    else
    {
           
   var  WeekDay_Count=req.body.WeekDay_Count;
   var  WeekEnd_Count=req.body.WeekEnd_Count;       
   var Total_Count=0;
   Total_Count= WeekDay_Count+ WeekEnd_Count;       

   if(Loa>=Total_Count)
       {
                Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                    {  
                        var SummerWeekdays=response.Summer_WeekDays;
                        var SummerWeekendDays=response.Summer_WeekEndDays;
                        var  WinterWeekDays=response.Winter_WeekDays;
                        var WinterweekendDays=response.Winter_WeekEndDays;

                        //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                         //is active is not here before
                        
                        Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                            {
                            //console.log(Boatresults)
                               
                            let stopExecution = {stop:false}
                            let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                console.log(error)
                                stopExecution = error
                            })
    
    
                            if(stopExecution.stop){
                                return res.json({status:true,message:stopExecution.error})
                            }
    
                            if(isAvailableDay && isAvailableDay.status && booktype!='prelaunch and launch booking')//check Date Between Summer Dates
                            {

                          
                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                            {   
                                                      
                            Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                            Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                            
                            },
                            {new: true},
                            function(err, data) {
                            
                                console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                            });
                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                            console.log(x)
                          
                               

                        }
                        else
                        {

                             if(booktype!='prelaunch and launch booking'){

                                Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                {   
                                                                 
                                   Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                   Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                    
                                },
                                {new: true},
                                function(err, data) {
                                    
                                    console.log('Winter sucesss')
                                });
                           
                                var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                console.log(x,'thisssss')
                                 
                             }

                         
 

                        }
                    })
                })


    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        IsActive:false,
        Updated_time: moment(Date.now()),
        Approved_LOA:Loa,
        BookingStatus:"Accepted",

     
    },
      
        function(err, data) {
        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
            let partialupdate = OwnerPartialCancelation.findOneAndUpdate(condition,update).catch((error) => console.log(error));
            res.json({

                status:true,
                message: 'Cancelled Successfully'
               })
        }
    }); 
       }
       else
       {
        res.json({
     
            status:true,
            message: 'WeekDay and WeekEnd LOA must not be greater than Total LOA '
           })
       }
       
}         
})

}





//save Special Day
async function AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
{
  
    console.log('Add Special Day Function');

    let OwnerDuration = await Duration.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).catch((error) => console.log(error));
    
    let AddSpecialDays_Owner= new Booking_Special_Days({                  
            
        Boat_Id:Boat_id,
        Owner_Id:Owner_id,
        SpecialDay_Id:Specialdayid,
        start:specialday,
        start_NoTime:Start_final,
        IsActive:true,
        OwnerDurationStart:OwnerDuration.From_Date,
        OwnerDurationEnd:OwnerDuration.To_Date,
        Current_Time:moment(Date.now()),
        Updated_time: moment(Date.now())

    });
     
    AddSpecialDays_Owner.save()
        .then(response => {
            return true;
        })
        .catch(error => {
            console.log(error)
            return  false;
        })

}


 async function CheckSpecialDaysExist(Boat_id,Owner_id,obj)
{

        console.log('im here in Special Day Checking');

        let OwnerDurationDays = await Duration.findOne({Owner_Id:Owner_id,IsActive:true,Boat_Id:Boat_id}).catch((error)=>console.log(error));

        let getSpecialdayDays = await Add_Special_Days.findById({_id:mongoose.Types.ObjectId(obj[0]._id)}).catch((error)=> console.log(error));

        console.log("getSpecialdayDays:::"+getSpecialdayDays);
        
        let getAllSpecialDays = getDaysBetweenDates(getSpecialdayDays.Start_Date,getSpecialdayDays.End_Date);

        var flag = 0;  

        const specialbooking = await Booking_Special_Days.find({Owner_Id:Owner_id,IsActive:true,Boat_Id:Boat_id,OwnerDurationStart:OwnerDurationDays.From_Date,OwnerDurationEnd:OwnerDurationDays.To_Date}).catch((error)=> console.log(error));

        let AllBookedSpecialDays = [];

        let AllBookedSpecialIDS = [];

        if(specialbooking.length){
            specialbooking.map((specialBooking)=>{

                AllBookedSpecialDays.push(specialBooking.start);

                AllBookedSpecialIDS.push(specialBooking.SpecialDay_Id);

            });

            console.log("AllBookedSpecialDays:::"+AllBookedSpecialDays);

             if(AllBookedSpecialIDS[0] == obj[0]._id){

                if(getAllSpecialDays.length==AllBookedSpecialDays.length)

                   flag = 1;
               
             }else{

             
                flag =1;
             }   

          
        }




        /*const data=obj;
        var flag = 0;       
        data.map(async function(objs) {   
        var specialday=objs.special_date;
        var Specialdayid=objs._id;

        var Start_final=moment(specialday);
        var Start_final_withoutTime=Start_final.startOf('day');
        console.log(Start_final_withoutTime);

        

        

        /*await Booking_Special_Days.findOne({Owner_Id:Owner_id,IsActive:true,start_NoTime:Start_final_withoutTime,SpecialDay_Id:Specialdayid}).then(results=>
                            {
                                
                                if(results!=null)
                                {
                                    
                                   flag=1                                                                   
                            
                                }
                               
                               
                            })                      
                        });*/
     return flag;

}

//check Special Day Exist

//vinayak 7/20/2021


const ViewCancelledBookingById = (req, res, next) => { 
    const User_Id = mongoose.Types.ObjectId(req.body.User_Id);
    mongoose.model('Tb_Schedule').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        {
            "$match": { User_Id:User_Id,IsActive:false
            }
        }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Booking_ID:1, LOA:1,BookingStatus:1,Approved_LOA:1,WeekEnd_Count:1,WeekDay_Count:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    
          
    }
    }
    ]
    ).exec(function(err, response){
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
        res.json({
            status:true,
            response
        })

    }
     })
}


//


//
const ViewBookingById = (req, res, next) => { 
    const User_Id = mongoose.Types.ObjectId(req.body.User_Id);
    mongoose.model('Tb_Schedule').aggregate(
    [
    {
    "$lookup":{
    "from":"tb_addowners",
    "localField": "User_Id",
    "foreignField": "_id",
    "as": "OwnerDetails"
    }
   },
    {
        "$lookup": {
            "from": "tb_boatmasters",
            "localField": "Boat_Id",
            "foreignField": "_id",
            "as": "BoatDetails"
        }
    },
    
        {
            "$match": { User_Id:User_Id,IsActive:true
            }
        }, 
        {$sort: {"_id": -1}},
    
    {
    $project:{
        calendarId:1,start:1,end:1,start_NoTime:1,end_NoTime:1,category:1,dueDateClass:1,User_RoleType:1,Current_Time:1,Updated_time:1,Booking_ID:1, LOA:1,BookingStatus:1,Approved_LOA:1,
    "OwnerDetails.Profile_Image":1,
    "OwnerDetails.First_Name":1,
    "OwnerDetails.Mobile":1,
    "OwnerDetails.Parking_Ability":1,
    "BoatDetails._id":1, 
    "BoatDetails.Location_Name":1,
    "BoatDetails.Boattype_Name":1,
    "BoatDetails.Location_Id":1,
    "BoatDetails.Boattype_id":1,
    "BoatDetails.Boat_Name": 1,
    "BoatDetails.Boat_Number": 1,
    "BoatDetails.Boat_Facility":1,
    "BoatDetails.Boat_Description":1,
    "BoatDetails. Owners_Allowed": 1,
    "BoatDetails.Launch_Date": 1,
    "BoatDetails.PreLaunch_Date":1,
    "BoatDetails.Boat_Image": 1,
    "BoatDetails.Boat_HandBook":1,
    "BoatDetails.Boat_Status":1,
    "BoatDetails.Total_Days":1,
    "BoatDetails.Summer_WeekDays":1,
    "BoatDetails. Summer_WeekEndDays":1,
    "BoatDetails.Winter_WeekDays":1,
    "BoatDetails.Winter_WeekEndDays":1,
    
          
    }
    }
    ]
    ).exec(function(err, response){
    if (err)
    {
        res.json({
            status:false,
            message: 'AN ERROR OCCURED'
        })
    }
    else
    {
        res.json({
            status:true,
            response
        })

    }
     })
}

//vinayak 7/20/2021

//Delete OwnerBookings
const DeleteScheduleForOwner = (req, res, next) => {

    
    var scheduleid = req.body._id;


    Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(response=>
        { 
            

            var Boat_id=response.Boat_Id;
            var Owner_id=response.User_Id;
            var start_Date=response.start;
            var Start_final=moment(start_Date);
            console.log(start_Date)
            console.log(Start_final)
            var Start_final_withoutTime=Start_final.startOf('day');
            var end_Date=response.end;
            var End_final=moment(end_Date);
            var End_final_withoutTime=End_final.startOf('day');
            console.log(Start_final_withoutTime)
            console.log(End_final_withoutTime)
            var RoleAssigned=response.User_RoleType;
            var Cancel_date=moment();
            console.log(Cancel_date)
            var dif=moment.duration(Start_final.diff(Cancel_date));
            console.log(dif.asHours());
            var Hrdif=Math.round(dif.asHours());
        
            console.log(Hrdif);

            console.log(RoleAssigned);

            var dif=Start_final.diff(moment(),'days')
            console.log(dif)

            Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)})
            .then(boatDetails=> {

                var BoatName=boatDetails.Boat_Name
                NewOwners.findById({_id:mongoose.Types.ObjectId(Owner_id)})
                .then(ownerDetails=> {

                    var OwnerName=ownerDetails.First_Name
                    var Email_id=ownerDetails.Email
                    var date=ownerDetails.Current_Time

     console.log(BoatName,OwnerName,Email_id,date)         

if(dif>=0)
{

            if( Hrdif<=72)
            {
 var Loa=Math.round((Hrdif-72)/24);
 var Loa_Pos = Math.abs(Loa);
 console.log(Loa);
 console.log(Loa_Pos,'positv');
 
   var  WeekDay_Count=0;
   var  WeekEnd_Count=0;       
            
               ////.....................

                var obj = Object();
                obj.start =Start_final;
                obj.end = End_final;
            
               var datas =  getDaysInMonth_Sheduler(obj);
               console.log(datas)
               var arr=[];
              ///.................
              datas.forEach(function(item) {
                Object.keys(item).forEach(function(key) {
                    arr.push(item[key]);
                  console.log( item[key]);
                });
              });
console.log(arr)

for (let index = 0; index <Loa_Pos; ++index) {
    console.log(arr[index]);
    let day = arr[index];

    if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
        WeekDay_Count=WeekDay_Count+1;
        console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiii')
    }
    else
    {
        WeekEnd_Count= WeekEnd_Count+1;

    }

}
  console.log(WeekDay_Count)
  console.log(WeekEnd_Count)
  var Total_Count=0;
  Total_Count= WeekDay_Count+ WeekEnd_Count;
  var WeekDay_Counts=WeekDay_Count;
  var WeekEnd_Counts=WeekEnd_Count;

  console.log(Total_Count,'hiiiiiiiiiiiiiiiiiiiiiiiiiiiiii')
          
               


    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        IsActive:false,
        Cancelled_Status:1,
        Updated_time: moment(Date.now()),
        LOA:Loa_Pos
     
    },
      
        function(err, data) {

                
            //mail   

            const emailState =  'Booking Cancelled.';
            const emailContent = `Dear ${OwnerName} your booking on Boat ${BoatName} on ${date} has been successfully cancelled.`;
            const emailContentAdmin = `Dear Administrator The Boat ${BoatName} on ${date} has been successfully cancelled.`;
            const emailDetailName = 'Cancellation Details'
            const emailDetails = [
              { key: 'Boat Name', value: BoatName  }
            ];
            const emailNameAndLink = {
              name:'Booking  Link',
              link:`${process.env.CLIENT_URL}/boat-bookings`
            }

            
                var mailOptions = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                       
                };
            
                transporter.sendMail(mailOptions, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                });           
            
                var mailOptionsAdmin = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                        
                  
                };

                transporter.sendMail(mailOptionsAdmin, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                }); 
            //mail


        if(err){
            res.json({ 
                status:false,
                message: 'AN ERROR OCCURED'
            })
        }
        else{
            res.json({
            
                status:true,
                Loa:Loa_Pos,
                Weekday:WeekDay_Counts,
                WeekEnd:WeekEnd_Counts,
                message: 'If you proceed with this cancellation,'+' '+Loa_Pos +' ' +' LOA will be applicable for you. Please click OK to confirm your cancellation'
               })
        }
    }); 


            }
            else
            {
                Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
                { 
                  
                    IsActive:false,
                    Cancelled_Status:1,
                    Updated_time: moment(Date.now()),
                    LOA:0
                },
                  
                    function(err, data) {

                //mail           

            const emailState =  'Booking Cancelled.';
            const emailContent = `Dear ${OwnerName} your booking on Boat ${BoatName} on ${date} has been successfully cancelled.`;
            const emailContentAdmin = `Dear Administrator The Boat ${BoatName} on ${date} has been successfully cancelled.`;
            const emailDetailName = 'Cancellation Details'
            const emailDetails = [
              { key: 'Boat Name', value: BoatName  }
            ];
            const emailNameAndLink = {
              name:'Booking  Link',
              link:`${process.env.CLIENT_URL}/boat-bookings`
            }
            
                var mailOptions = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                    html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                        

                };
            
                transporter.sendMail(mailOptions, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                });           
            
                var mailOptionsAdmin = {
                   
                    from:"noreply.smartboatbooking@gmail.com",
                    to: Email_id,
                    subject: 'Booking Cancellation',
                     html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                };

                transporter.sendMail(mailOptionsAdmin, function (error, info) {
                    if (error) {
                        console.log(error);
                    } else {
                        res.json({
                            status:true,
                            info: 'Successfully send'
                        })
                    }
                });  

            //mail


                    if(err){
                        res.json({ 
                            status:false,
                            message: 'AN ERROR OCCURED'
                        })
                    }
                    else{
                        res.json({
            
                            status:true,
                            Loa:0,
                            Weekday:0,
                            WeekEnd:0,
                            message:'If you proceed with this cancellation,'+' ' +0 +' '+' LOA will be applicable for you. Please click OK to confirm your cancellation'
                           })
                    }
                }); 

            }
        }

        else
        {
            res.json({ 
                status:false,
                message: 'Booking on a previous day cannot be cancelled'
            })

        }
})
})
     

})
}


//Delete OwnerBookings

//StandbyBooking Adding
//StandbyBooking Adding
const AddScheduleStandByBooking = async (req,ogWeekendDaysCount,ogWeekDaysCount,ogTotalDaysCount) => {
    return new Promise(async (resolve, reject) => {
      console.log(req.body, 'AddScheduleStandByBooking');
      const globalbookingid = await GetNextBookingID();
      console.log(globalbookingid);
      var check_Status = req.body.Check_Status;
      console.log("CHKST::"+check_Status);
      var Total_Count = Number(req.body.TotalDay_Count);
      var WeekDay_Count = Number(req.body.WeekDay_Count);
      var WeekEnd_Count = Number(req.body.WeekEnd_Count);
      var User_role = req.body.User_RoleType;
      var Boat_id = req.body.Boat_Id;
      var Owner_id = req.body.User_Id;
      var start_Date = req.body.start;
      let standByBookingId = req.body._id
      //var specialDayCheck=0;//special day
      var specialDayCheck = req.body.specialDayCheck; //special day
      console.log(specialDayCheck, 'check here');
      console.log(start_Date);
      var end_Date = req.body.end;
      var TodaysDate = moment();
      var CurrentDate = moment(TodaysDate).format('DD-MM-YYYY');
      console.log(CurrentDate);
  
      //var start_Date_NoTime=new Date(start_Date);
      //console.log(start_Date_NoTime.toString(),'hi');
      var Start_final = moment(start_Date);
      console.log(Start_final, 'checkkkk1');
      var Start_final_withoutTime = Start_final.startOf('day');
  
      // var end_Date_NoTime=new Date(end_Date);
      var End_final = moment(end_Date);
      var End_final_withoutTime = End_final.startOf('day');
  
      var dif = Start_final.diff(moment(), 'days');
      console.log(dif);
  
      if (req.body.Status == 'Enable') {
        var Module_status = 1;
      } else if (req.body.Status == 'Disable') {
        var Module_status = 0;
      }

  
      //get month
      const Getmonth = new Date(Start_final);
      LaunchPreMonth = Getmonth.toLocaleString('default', { month: 'long' });
      //getmonth
  
      NewOwners.findById({ _id: mongoose.Types.ObjectId(Owner_id) }).then((OwnerDetails) => {
        Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((boatDetails) => {
          if (boatDetails.Boat_Status == '1') {
            //check whether boat is Active or not
            //between Launch And PreLuanch
  
            if (check_Status == '1' && specialDayCheck == 0) {
              console.log(dif, 'diffff');
              if (dif >= 0) {
                Schedule.find({ Boat_Id: Boat_id, IsActive: true, User_Id: Owner_id, Check_Status: check_Status, Check_Month: LaunchPreMonth }).then((Checkresult) => {
                  console.log(Checkresult.length, 'length');
                  var _LengthCheck = Checkresult.length;
                  if (_LengthCheck == 0) {
                    console.log('pre and launchhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh');
                    PreLaunchAndLaunchBookingDays.findOne({ Boat_Id: Boat_id }).then((bookingDays) => {
                      var b_days = bookingDays.Booking_Days;
                      console.log(b_days);
                      console.log(Total_Count);
                      if (Total_Count <= b_days) {
                        console.log('hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii');
  
                        Schedule.find({ Boat_Id: Boat_id, IsActive: true, isBookingPending: false, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then(
                          (result) => {
                            console.log(result.length, 'length');
                            var _Length = result.length;
                            if (_Length == 0) {
                              Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                                if (result2 == null) {
                                  console.log('hi1');
                                  Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                                    if (results == null) {
                                      console.log('hi2');
                                      Schedule.findOne({
                                        Boat_Id: Boat_id,
                                        isBookingPending: false,
                                        IsActive: true,
                                        $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                                      }).then((results) => {
                                        if (results == null) {
                                          console.log('hi3');
  
                                          //Add
                                          console.log('Admin');
                                          let bookingType = getBookingTypeofAbooking(req.body.start,req.body.end,boatDetails.PreLaunch_Date,boatDetails.Launch_Date,boatDetails.SummerSeason_SDate,boatDetails.SummerSeason_EDate,boatDetails.WinterSeason_SDate,boatDetails.WinterSeason_EDate);
                                          let Add_Schedule = new Schedule({
                                            Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                            Booking_ID: globalbookingid,
                                            Boat_Name: req.body.Boat_Name,
                                            Total_DaysBooked: Total_Count,
                                            calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                            title: req.body.title,
                                            body: req.body.body,
                                            start: req.body.start,
                                            end: req.body.end,
                                            start_NoTime: Start_final_withoutTime,
                                            end_NoTime: End_final_withoutTime,
                                            goingDuration: req.body.goingDuration,
                                            comingDuration: req.body.comingDuration,
                                            isAllDay: req.body.isAllDay,
                                            category: req.body.category,
                                            dueDateClass: req.body.dueDateClass,
                                            location: req.body.location,
                                            attendees: req.body.attendees,
                                            recurrenceRule: req.body.recurrenceRule,
                                            isPending: req.body.isPending,
                                            isFocused: req.body.isFocused,
                                            Is_StandByBooking: req.body.Is_StandByBooking,
                                            isVisible: req.body.isVisible,
                                            isReadOnly: req.body.isReadOnly,
                                            isPrivate: req.body.isPrivate,
                                            color: req.body.color,
                                            bgColor: req.body.bgColor,
                                            dragBgColor: req.body.dragBgColor,
                                            borderColor: req.body.borderColor,
                                            customStyle: req.body.customStyle,
                                            raw: req.body.raw,
                                            state: req.body.state,
                                            Check_Status: req.body.Check_Status,
                                            commends: req.body.commends,
                                            Check_Month: LaunchPreMonth,
                                            User_RoleType: req.body.User_RoleType,
                                            User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                            Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                            Status: Module_status,
                                            IsActive: req.body.IsActive,
                                            Current_Time: moment(Date.now()),
                                            Updated_time: moment(Date.now()),
                                            Booking_Type:bookingType,
                                            WeekDay_Count,
                                            WeekEnd_Count,
                                            isStandByBookingIncluded:true,
                                            standByBookingId
                                          });
  
                                          Add_Schedule.save()
                                            .then((response) => {
                                              console.log('booking saved to schedule');
  
                                              //mail
  const emailState =  'Successfully Booked.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value: boatDetails.Boat_Name  },
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Booking  Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }

  
                                              var mailOptions = {
                                                from: 'noreply.smartboatbooking@gmail.com',
                                                to: OwnerDetails.Email,
                                                subject: 'Successfully Booked',
                                                html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                                 
                                              };
  
                                              transporter.sendMail(mailOptions, function (error, info) {});
  
                                              var mailOptionsAdmin = {
                                                from: 'noreply.smartboatbooking@gmail.com',
                                                to: 'admin@smartboating.com.au',
                                                subject: 'Successfully Booked',
                                                html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                                 
                                              };
  
                                              transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                              //mail
  
                                              return resolve({ status: true, message: 'The booking has been successfully created' });
                                            })
                                            .catch((error) => {
                                              return reject({
                                                message: error,
                                              });
                                            });
                                        } else {
                                          return reject({
                                            status: true,
                                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                          });
                                        }
                                      });
                                      //Add
                                    } else {
                                      return reject({
                                        status: true,
                                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                      });
                                    }
                                  });
                                } else {
                                  return reject({
                                    status: true,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              });
                            } else {
                              return reject({
                                status: true,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          }
                        );
                      } else {
                        return reject({
                          status: true,
                          message: 'Allowed Booking Days Exceeds max count Between launch Date And Pre-Launch Date',
                        });
                      }
                    });
                  } else {
                    return reject({
                      status: true,
                      message: 'The booking allocation for the pre-launch period has been exceeded. Please try booking after launch date of the boat.',
                    });
                  }
                });
              } else {
                console.log('inside between Launch And PreLuanch');
                return reject({
                  status: false,
                  message: 'A booking cannot be created for a previous day',
                });
              }
            }
  
            //between Launch And PreLaunch
  
            //After Launch before current date
  
            if (check_Status == '2' && specialDayCheck == 0) {
              if (dif >= 0) {
                Schedule.findOne({
                  Boat_Id: Boat_id,
                  User_Id: Owner_id,
                  IsActive: false,
                  Cancelled_Status: 1,
                  $or: [
                    { end_NoTime: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } },
                    { start_NoTime: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } },
                    { start_NoTime: Start_final_withoutTime },
                    { end_NoTime: End_final_withoutTime },
                    { $and: [{ start: { $gte: start_Date } }, { end: { $lte: End_final_withoutTime } }] },
                    { $and: [{ start: { $lte: start_Date } }, { end: { $gte: End_final_withoutTime } }] },
                  ],
                }).then(
                  (
                    Cancelresults //for cancellation
                  ) => {
                    if (Cancelresults == null) {
                      Schedule.find({ Boat_Id: Boat_id, IsActive: true, isBookingPending: false, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then(
                        (result) => {
                          console.log(result.length, 'length');
                          var _Length = result.length;
                          if (_Length == 0) {
                            Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                              if (result2 == null) {
                                Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                                  if (results == null) {
                                    Schedule.findOne({
                                      Boat_Id: Boat_id,
                                      isBookingPending: false,
                                      IsActive: true,
                                      $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                                    }).then((results) => {
                                      if (results == null) {
                                        Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((response) => {
                                          var SummerWeekdays = response.Summer_WeekDays;
                                          var SummerWeekendDays = response.Summer_WeekEndDays;
                                          var WinterWeekDays = response.Winter_WeekDays;
                                          var WinterweekendDays = response.Winter_WeekEndDays;
  
                                          //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
  
                                          Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (Boatresults) => {
                                            console.log(Boatresults);
  
                                            let stopExecution = { stop: false };
                                            let isAvailableDay = await checkIfIncludedInSeason(
                                              Boat_id,
                                              Owner_id,
                                              Boatresults.SummerSeason_SDate,
                                              Boatresults.SummerSeason_EDate,
                                              start_Date,
                                              end_Date
                                            ).catch((error) => {
                                              console.log(error);
                                              stopExecution = error;
                                            });
  
                                            if (stopExecution.stop) {
                                              return reject({ status: true, message: stopExecution.error });
                                            }
  
                                            if (isAvailableDay && isAvailableDay.status) {
                                              //check Date Between Summer Dates
                                              //check if next booking included
  
                                              let isNextDaysError = false;
                                              let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                req.body.start,
                                                req.body.end,
                                                req.body.Boat_Id,
                                                req.body.timeZone,
                                                true,
                                                req.body.User_Id
                                              ).catch((error) => {
                                                isNextDaysError = true;
                                                return reject(error);
                                              });
  
                                              if (isNextDaysError) return;
  
                                              consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                if (element != null) {
                                                  if (element.Summer_ConsecutiveDays >= Total_Count) {
                                                    //consecutive count
  
                                                    //count of weekday and week end
                                                    // for updating Summer days
                                                    Boats.findByIdAndUpdate(
                                                      { _id: mongoose.Types.ObjectId(Boat_id) },
                                                      {
                                                        Summer_WeekDays: SummerWeekdays - WeekDay_Count,
                                                        Summer_WeekEndDays: SummerWeekendDays - WeekEnd_Count,
                                                      },
                                                      { new: true },
                                                      function (err, data) {}
                                                    );
  
                                                    var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                    console.log(x);
  
                                                    //Add Summer Section
  
                                                    let Add_Schedule = new Schedule({
                                                      Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                      Booking_ID: globalbookingid,
                                                      Boat_Name: req.body.Boat_Name,
                                                      Total_DaysBooked: Total_Count,
                                                      calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                      title: req.body.title,
                                                      body: req.body.body,
                                                      start: req.body.start,
                                                      end: req.body.end,
                                                      start_NoTime: Start_final,
                                                      end_NoTime: End_final,
                                                      goingDuration: req.body.goingDuration,
                                                      comingDuration: req.body.comingDuration,
                                                      isAllDay: req.body.isAllDay,
                                                      category: req.body.category,
                                                      dueDateClass: req.body.dueDateClass,
                                                      location: req.body.location,
                                                      attendees: req.body.attendees,
                                                      recurrenceRule: req.body.recurrenceRule,
                                                      isPending: req.body.isPending,
                                                      isFocused: req.body.isFocused,
                                                      isVisible: req.body.isVisible,
                                                      isReadOnly: req.body.isReadOnly,
                                                      isPrivate: req.body.isPrivate,
                                                      Is_StandByBooking: req.body.Is_StandByBooking,
                                                      Check_Status: req.body.Check_Status,
                                                      commends: req.body.commends,
                                                      color: req.body.color,
                                                      bgColor: req.body.bgColor,
                                                      dragBgColor: req.body.dragBgColor,
                                                      borderColor: req.body.borderColor,
                                                      customStyle: req.body.customStyle,
                                                      raw: req.body.raw,
                                                      state: req.body.state,
                                                      User_RoleType: req.body.User_RoleType,
                                                      User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                      Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                      Status: Module_status,
                                                      IsActive: req.body.IsActive,
                                                      Current_Time: moment(Date.now()),
                                                      Updated_time: moment(Date.now()),
                                                      isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                      isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                      WeekDay_Count,
                                                      WeekEnd_Count,
                                                       isStandByBookingIncluded:true,
                                                      standByBookingId
                                                    });
  
                                                    Add_Schedule.save()
                                                      .then((response) => {
                                                        console.log('booking saved to schedule');
  
                                                        //mail
                                                        const emailState =  'Successfully Booked.';
                                                        const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
                                                        const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
                                                        const emailDetailName = 'Booking Details'
                                                        const emailDetails = [
                                                          { key: 'Boat Name', value: boatDetails.Boat_Name  },
                                                          { key: 'Booking Date', value: getCurrentTimeFormatted() },
                                                        ];
                                                        const emailNameAndLink = {
                                                          name:'Booking  Link',
                                                          link:`${process.env.CLIENT_URL}/boat-bookings`
                                                        }

  
                                                        var mailOptions = {
                                                          from: 'noreply.smartboatbooking@gmail.com',
                                                          to: OwnerDetails.Email,
                                                          //to: "bjibin3@gmail.com",
                                                          subject: 'Successfully Booked',
                                                          html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                                          
                                                        };
  
                                                        transporter.sendMail(mailOptions, function (error, info) {});
  
                                                        var mailOptionsAdmin = {
                                                          from: 'noreply.smartboatbooking@gmail.com',
                                                          to: 'admin@smartboating.com.au',
                                                          subject: 'Successfully Booked',
                                                          html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                                          
                                                        };
  
                                                        transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                                        //mail
  
                                                        return resolve({ status: true, message: 'The booking has been successfully created' });
                                                      })
                                                      .catch((error) => {
                                                        return reject({
                                                          message: error,
                                                        });
                                                      });
                                                  } else {
                                                    return reject({
                                                      status: false,
                                                      message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                    });
                                                  }
                                                } else {
                                                  return reject({
                                                    status: false,
                                                    message: 'Consecutive days for this boat is Empty',
                                                  });
                                                }
                                              });
                                            } else {
                                              //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                              Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (BoatresultsWinter) => {
                                                console.log(BoatresultsWinter);
  
                                                //list all winter start and end date of  owne  based on owner duration  duration which include all year
  
                                                let stopExecution = { stop: false };
                                                let isAvailableDay = await checkIfIncludedInSeason(
                                                  Boat_id,
                                                  Owner_id,
                                                  BoatresultsWinter.WinterSeason_SDate,
                                                  BoatresultsWinter.WinterSeason_EDate,
                                                  start_Date,
                                                  end_Date
                                                ).catch((error) => {
                                                  console.log(error);
                                                  stopExecution = error;
                                                });
  
                                                if (stopExecution.stop) {
                                                  return reject({ status: true, message: stopExecution.error });
                                                }
  
                                                if (isAvailableDay && isAvailableDay.status) {
                                                  //check Date Between winter Dates
                                                  //check if next booking included
  
                                                  let isNextDaysError = false;
                                                  let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                    req.body.start,
                                                    req.body.end,
                                                    req.body.Boat_Id,
                                                    req.body.timeZone,
                                                    false,
                                                    req.body.User_Id
                                                  ).catch((error) => {
                                                    isNextDaysError = true;
                                                    return reject(error);
                                                  });
  
                                                  if (isNextDaysError) return;
  
                                                  consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                    if (element != null) {
                                                      if (element.Winter_ConsecutiveDays >= Total_Count) {
                                                        //count of weekday and week end
                                                        // for updating Summer days
                                                        Boats.findByIdAndUpdate(
                                                          { _id: mongoose.Types.ObjectId(Boat_id) },
                                                          {
                                                            Winter_WeekDays: WinterWeekDays - WeekDay_Count,
                                                            Winter_WeekEndDays: WinterweekendDays - WeekEnd_Count,
                                                          },
                                                          { new: true },
                                                          function (err, data) {}
                                                        );
  
                                                        var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                        console.log(x);
  
                                                        //Add Winter Section
  
                                                        let Add_Schedule = new Schedule({
                                                          Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                          Booking_ID: globalbookingid,
                                                          Boat_Name: req.body.Boat_Name,
                                                          Total_DaysBooked: Total_Count,
                                                          calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                          title: req.body.title,
                                                          body: req.body.body,
                                                          start: req.body.start,
                                                          end: req.body.end,
                                                          start_NoTime: Start_final,
                                                          end_NoTime: End_final,
                                                          goingDuration: req.body.goingDuration,
                                                          comingDuration: req.body.comingDuration,
                                                          isAllDay: req.body.isAllDay,
                                                          category: req.body.category,
                                                          dueDateClass: req.body.dueDateClass,
                                                          location: req.body.location,
                                                          attendees: req.body.attendees,
                                                          recurrenceRule: req.body.recurrenceRule,
                                                          isPending: req.body.isPending,
                                                          isFocused: req.body.isFocused,
                                                          Is_StandByBooking: req.body.Is_StandByBooking,
                                                          Check_Status: req.body.Check_Status,
                                                          commends: req.body.commends,
                                                          isVisible: req.body.isVisible,
                                                          isReadOnly: req.body.isReadOnly,
                                                          isPrivate: req.body.isPrivate,
                                                          color: req.body.color,
                                                          bgColor: req.body.bgColor,
                                                          dragBgColor: req.body.dragBgColor,
                                                          borderColor: req.body.borderColor,
                                                          customStyle: req.body.customStyle,
                                                          raw: req.body.raw,
                                                          state: req.body.state,
                                                          User_RoleType: req.body.User_RoleType,
                                                          User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                          Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                          Status: Module_status,
                                                          IsActive: req.body.IsActive,
                                                          Current_Time: moment(Date.now()),
                                                          Updated_time: moment(Date.now()),
                                                          isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                          isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                          WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                        });
  
                                                        Add_Schedule.save()
                                                          .then((response) => {
                                                            console.log('booking saved to schedule');
  
                                                            //mail
  const emailState =  'Successfully Booked.';
  const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
  const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
  const emailDetailName = 'Booking Details'
  const emailDetails = [
    { key: 'Boat Name', value: boatDetails.Boat_Name  },
    { key: 'Booking Date', value: getCurrentTimeFormatted() },
  ];
  const emailNameAndLink = {
    name:'Booking  Link',
    link:`${process.env.CLIENT_URL}/boat-bookings`
  }
  
                                                            var mailOptions = {
                                                              from: 'noreply.smartboatbooking@gmail.com',
                                                              to: OwnerDetails.Email,
                                                              //to: "bjibin3@gmail.com",
                                                              subject: 'Successfully Booked',
                                                              html: getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                                               
                                                            };
  
                                                            transporter.sendMail(mailOptions, function (error, info) {});
  
                                                            var mailOptionsAdmin = {
                                                              from: 'noreply.smartboatbooking@gmail.com',
                                                              to: 'admin@smartboating.com.au',
                                                              subject: 'Successfully Booked',
                                                              html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                                              
                                                            };
  
                                                            transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                                            //mail
  
                                                            return resolve({ status: true, message: 'The booking has been successfully created' });
                                                          })
                                                          .catch((error) => {
                                                            return reject({
                                                              message: error,
                                                            });
                                                          });
  
                                                        //Add Winter Section
                                                      } else {
                                                        return reject({
                                                          status: false,
                                                          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                        });
                                                      }
                                                    } else {
                                                      return reject({
                                                        status: false,
                                                        message: 'Consecutive days for this boat is Empty',
                                                      });
                                                    }
                                                  });
                                                } else {
                                                  return reject({
                                                    status: false,
                                                    message: 'These Dates Are not Allowed for Booking',
                                                  });
                                                }
                                              });
                                            } //else
                                          });
                                        });
                                      } else {
                                        return reject({
                                          status: false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                        });
                                      }
                                    });
                                  } else {
                                    return reject({
                                      status: false,
                                      message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                    });
                                  }
                                });
                              } else {
                                return reject({
                                  status: false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                });
                              }
                            }); //else inside function owner
                          } else {
                            return reject({
                              status: false,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.',
                            });
                          }
                        }
                      );
                    } else {
                      console.log(Start_final_withoutTime);
                      console.log(End_final_withoutTime);
                      console.log(Cancelresults.Updated_time, 'thissssssssss');
                      var todaysdate = moment();
                      console.log(todaysdate);
                      var canceldate = moment(Cancelresults.Updated_time);
                      var dif = moment.duration(todaysdate.diff(canceldate));
                      console.log(dif.asHours());
                      var Hrdif = Math.round(dif.asHours());
  
                      console.log(Hrdif);
  
                      if (Hrdif > 24) {
                        Schedule.find({ Boat_Id: Boat_id, IsActive: true, isBookingPending: false, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then(
                          (result) => {
                            console.log(result.length, 'length');
                            var _Length = result.length;
                            if (_Length == 0) {
                              Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                                if (result2 == null) {
                                  Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                                    if (results == null) {
                                      Schedule.findOne({
                                        Boat_Id: Boat_id,
                                        isBookingPending: false,
                                        IsActive: true,
                                        $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                                      }).then((results) => {
                                        if (results == null) {
                                          Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((response) => {
                                            var SummerWeekdays = response.Summer_WeekDays;
                                            var SummerWeekendDays = response.Summer_WeekEndDays;
                                            var WinterWeekDays = response.Winter_WeekDays;
                                            var WinterweekendDays = response.Winter_WeekEndDays;
  
                                            //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
  
                                            Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (Boatresults) => {
                                              console.log(Boatresults);
  
                                              let stopExecution = { stop: false };
                                              let isAvailableDay = await checkIfIncludedInSeason(
                                                Boat_id,
                                                Owner_id,
                                                Boatresults.SummerSeason_SDate,
                                                Boatresults.SummerSeason_EDate,
                                                start_Date,
                                                end_Date
                                              ).catch((error) => {
                                                console.log(error);
                                                stopExecution = error;
                                              });
  
                                              if (stopExecution.stop) {
                                                return reject({ status: true, message: stopExecution.error });
                                              }
  
                                              if (isAvailableDay && isAvailableDay.status) {
                                                //check Date Between Summer Dates
                                                //check if next booking included
  
                                                let isNextDaysError = false;
                                                let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                  req.body.start,
                                                  req.body.end,
                                                  req.body.Boat_Id,
                                                  req.body.timeZone,
                                                  true,
                                                  req.body.User_Id
                                                ).catch((error) => {
                                                  isNextDaysError = true;
                                                  return reject(error);
                                                });
  
                                                if (isNextDaysError) return;
  
                                                consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                  if (element != null) {
                                                    if (element.Summer_ConsecutiveDays >= Total_Count) {
                                                      //consecutive count
  
                                                      //count of weekday and week end
                                                      // for updating Summer days
                                                      Boats.findByIdAndUpdate(
                                                        { _id: mongoose.Types.ObjectId(Boat_id) },
                                                        {
                                                          Summer_WeekDays: SummerWeekdays - WeekDay_Count,
                                                          Summer_WeekEndDays: SummerWeekendDays - WeekEnd_Count,
                                                        },
                                                        { new: true },
                                                        function (err, data) {}
                                                      );
  
                                                      var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                      console.log(x);
  
                                                      //Add Summer Section
  
                                                      let Add_Schedule = new Schedule({
                                                        Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                        Booking_ID: globalbookingid,
                                                        Boat_Name: req.body.Boat_Name,
                                                        Total_DaysBooked: Total_Count,
                                                        calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                        title: req.body.title,
                                                        body: req.body.body,
                                                        start: req.body.start,
                                                        end: req.body.end,
                                                        start_NoTime: Start_final,
                                                        end_NoTime: End_final,
                                                        goingDuration: req.body.goingDuration,
                                                        comingDuration: req.body.comingDuration,
                                                        isAllDay: req.body.isAllDay,
                                                        category: req.body.category,
                                                        dueDateClass: req.body.dueDateClass,
                                                        location: req.body.location,
                                                        attendees: req.body.attendees,
                                                        recurrenceRule: req.body.recurrenceRule,
                                                        isPending: req.body.isPending,
                                                        isFocused: req.body.isFocused,
                                                        isVisible: req.body.isVisible,
                                                        isReadOnly: req.body.isReadOnly,
                                                        isPrivate: req.body.isPrivate,
                                                        Is_StandByBooking: req.body.Is_StandByBooking,
                                                        Check_Status: req.body.Check_Status,
                                                        commends: req.body.commends,
                                                        color: req.body.color,
                                                        bgColor: req.body.bgColor,
                                                        dragBgColor: req.body.dragBgColor,
                                                        borderColor: req.body.borderColor,
                                                        customStyle: req.body.customStyle,
                                                        raw: req.body.raw,
                                                        state: req.body.state,
                                                        User_RoleType: req.body.User_RoleType,
                                                        User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                        Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                        Status: Module_status,
                                                        IsActive: req.body.IsActive,
                                                        Current_Time: moment(Date.now()),
                                                        Updated_time: moment(Date.now()),
                                                        isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                        isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                        WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                      });
  
                                                      Add_Schedule.save()
                                                        .then((response) => {
                                                          console.log('booking saved to schedule');
  
                                                          return resolve({ status: true, message: 'The booking has been successfully created' });
                                                        })
                                                        .catch((error) => {
                                                          return reject({
                                                            message: error,
                                                          });
                                                        });
                                                    } else {
                                                      return reject({
                                                        status: false,
                                                        message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                      });
                                                    }
                                                  } else {
                                                    return reject({
                                                      status: false,
                                                      message: 'Consecutive days for this boat is Empty',
                                                    });
                                                  }
                                                });
                                              } else {
                                                //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (BoatresultsWinter) => {
                                                  console.log(BoatresultsWinter);
  
                                                  //list all winter start and end date of  owne  based on owner duration  duration which include all year
  
                                                  let stopExecution = { stop: false };
                                                  let isAvailableDay = await checkIfIncludedInSeason(
                                                    Boat_id,
                                                    Owner_id,
                                                    BoatresultsWinter.WinterSeason_SDate,
                                                    BoatresultsWinter.WinterSeason_EDate,
                                                    start_Date,
                                                    end_Date
                                                  ).catch((error) => {
                                                    console.log(error);
                                                    stopExecution = error;
                                                  });
  
                                                  if (stopExecution.stop) {
                                                    return reject({ status: true, message: stopExecution.error });
                                                  }
  
                                                  if (isAvailableDay && isAvailableDay.status) {
                                                    //check Date Between winter Dates
                                                    //check if next booking included
  
                                                    let isNextDaysError = false;
                                                    let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                      req.body.start,
                                                      req.body.end,
                                                      req.body.Boat_Id,
                                                      req.body.timeZone,
                                                      false,
                                                      req.body.User_Id
                                                    ).catch((error) => {
                                                      isNextDaysError = true;
                                                      return reject(error);
                                                    });
  
                                                    if (isNextDaysError) return;
  
                                                    consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                      if (element != null) {
                                                        if (element.Winter_ConsecutiveDays >= Total_Count) {
                                                          //count of weekday and week end
                                                          // for updating Summer days
                                                          Boats.findByIdAndUpdate(
                                                            { _id: mongoose.Types.ObjectId(Boat_id) },
                                                            {
                                                              Winter_WeekDays: WinterWeekDays - WeekDay_Count,
                                                              Winter_WeekEndDays: WinterweekendDays - WeekEnd_Count,
                                                            },
                                                            { new: true },
                                                            function (err, data) {}
                                                          );
  
                                                          var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                          console.log(x);
  
                                                          //Add Winter Section
  
                                                          let Add_Schedule = new Schedule({
                                                            Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                            Booking_ID: globalbookingid,
                                                            Boat_Name: req.body.Boat_Name,
                                                            Total_DaysBooked: Total_Count,
                                                            calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                            title: req.body.title,
                                                            body: req.body.body,
                                                            start: req.body.start,
                                                            end: req.body.end,
                                                            start_NoTime: Start_final,
                                                            end_NoTime: End_final,
                                                            goingDuration: req.body.goingDuration,
                                                            comingDuration: req.body.comingDuration,
                                                            isAllDay: req.body.isAllDay,
                                                            category: req.body.category,
                                                            dueDateClass: req.body.dueDateClass,
                                                            location: req.body.location,
                                                            attendees: req.body.attendees,
                                                            recurrenceRule: req.body.recurrenceRule,
                                                            isPending: req.body.isPending,
                                                            isFocused: req.body.isFocused,
                                                            Is_StandByBooking: req.body.Is_StandByBooking,
                                                            Check_Status: req.body.Check_Status,
                                                            commends: req.body.commends,
                                                            isVisible: req.body.isVisible,
                                                            isReadOnly: req.body.isReadOnly,
                                                            isPrivate: req.body.isPrivate,
                                                            color: req.body.color,
                                                            bgColor: req.body.bgColor,
                                                            dragBgColor: req.body.dragBgColor,
                                                            borderColor: req.body.borderColor,
                                                            customStyle: req.body.customStyle,
                                                            raw: req.body.raw,
                                                            state: req.body.state,
                                                            User_RoleType: req.body.User_RoleType,
                                                            User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                            Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                            Status: Module_status,
                                                            IsActive: req.body.IsActive,
                                                            Current_Time: moment(Date.now()),
                                                            Updated_time: moment(Date.now()),
                                                            isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                            isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                            WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                          });
  
                                                          Add_Schedule.save()
                                                            .then((response) => {
                                                              console.log('booking saved to schedule');
  
                                                              return resolve({ status: true, message: 'The booking has been successfully created' });
                                                            })
                                                            .catch((error) => {
                                                              return reject({
                                                                message: error,
                                                              });
                                                            });
                                                        } else {
                                                          return reject({
                                                            status: false,
                                                            message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                          });
                                                        }
                                                      } else {
                                                        return reject({
                                                          status: false,
                                                          message: 'Consecutive days for this boat is Empty',
                                                        });
                                                      }
                                                    });
                                                  } else {
                                                    return reject({
                                                      status: false,
                                                      message: 'These Dates Are not Allowed for Booking',
                                                    });
                                                  }
                                                });
                                              } //else
                                            });
                                          });
                                        } else {
                                          return reject({
                                            status: false,
                                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                          });
                                        }
                                      });
                                    } else {
                                      return reject({
                                        status: false,
                                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                      });
                                    }
                                  });
                                } else {
                                  return reject({
                                    status: false,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              }); //else inside function owner
                            } else {
                              return reject({
                                status: false,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          }
                        );
                      } else {
                        return reject({
                          status: false,
                          message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again',
                        });
                      }
                    }
                  }
                );
              } else {
                return reject({
                  status: false,
                  message: 'A booking cannot be created for a previous day',
                });
              }
            }
  
            //between Launch And PreLuanch
            if (check_Status == '3' && specialDayCheck == 0) {
              if (dif >= 0) {
                //for Previous Date
                if (User_role == 'Admin') {
                  //for Admin
                  Schedule.find({ Boat_Id: Boat_id, IsActive: true, isBookingPending: false, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then((result) => {
                    console.log(result.length, 'length');
                    var _Length = result.length;
                    if (_Length == 0) {
                      Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                        if (result2 == null) {
                          Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                            if (results == null) {
                              Schedule.findOne({
                                Boat_Id: Boat_id,
                                isBookingPending: false,
                                IsActive: true,
                                $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                              }).then((results) => {
                                if (results == null) {
                                  //Add
                                  console.log('Admin');
                                  let Add_Schedule = new Schedule({
                                    Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                    Booking_ID: globalbookingid,
                                    Boat_Name: req.body.Boat_Name,
                                    Total_DaysBooked: Total_Count,
                                    calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                    title: req.body.title,
                                    body: req.body.body,
                                    start: req.body.start,
                                    end: req.body.end,
                                    start_NoTime: Start_final_withoutTime,
                                    end_NoTime: End_final_withoutTime,
                                    goingDuration: req.body.goingDuration,
                                    comingDuration: req.body.comingDuration,
                                    isAllDay: req.body.isAllDay,
                                    category: req.body.category,
                                    dueDateClass: req.body.dueDateClass,
                                    location: req.body.location,
                                    attendees: req.body.attendees,
                                    recurrenceRule: req.body.recurrenceRule,
                                    isPending: req.body.isPending,
                                    isFocused: req.body.isFocused,
                                    isVisible: req.body.isVisible,
                                    isReadOnly: req.body.isReadOnly,
                                    isPrivate: req.body.isPrivate,
                                    color: req.body.color,
                                    bgColor: req.body.bgColor,
                                    Is_StandByBooking: req.body.Is_StandByBooking,
                                    Check_Status: req.body.Check_Status,
                                    commends: req.body.commends,
                                    dragBgColor: req.body.dragBgColor,
                                    borderColor: req.body.borderColor,
                                    customStyle: req.body.customStyle,
                                    raw: req.body.raw,
                                    state: req.body.state,
                                    User_RoleType: req.body.User_RoleType,
                                    User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                    Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                    Status: Module_status,
                                    IsActive: req.body.IsActive,
                                    Current_Time: moment(Date.now()),
                                    Updated_time: moment(Date.now()),
                                    WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                  });
  
                                  Add_Schedule.save()
                                    .then((response) => {
                                      console.log('booking saved to schedule');
  
                                      //mail
                                      const emailState =  'Successfully Booked.';
                                      const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
                                      const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
                                      const emailDetailName = 'Booking Details'
                                      const emailDetails = [
                                        { key: 'Boat Name', value: boatDetails.Boat_Name  },
                                        { key: 'Booking Date', value: getCurrentTimeFormatted() },
                                      ];
                                      const emailNameAndLink = {
                                        name:'Booking  Link',
                                        link:`${process.env.CLIENT_URL}/boat-bookings`
                                      }
  
                                      var mailOptionsAdmin = {
                                        from: 'noreply.smartboatbooking@gmail.com',
                                        to: 'admin@smartboating.com.au',
                                        subject: 'Successfully Booked',
                                        html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                         
                                      };
  
                                      transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                      //mail
  
                                      return reject({
                                        status: true,
                                        message: 'The admin booking has been successfully created',
                                      });
                                    })
                                    .catch((error) => {
                                      return reject({
                                        message: error,
                                      });
                                    });
                                } else {
                                  return reject({
                                    status: true,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              });
                              //Add
                            } else {
                              return reject({
                                status: true,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          });
                        } else {
                          return reject({
                            status: true,
                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                          });
                        }
                      });
                    } else {
                      return reject({
                        status: true,
                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                      });
                    }
                  });
                } //For Owner
                else {
                  Schedule.findOne({
                    Boat_Id: Boat_id,
                    User_Id: Owner_id,
                    IsActive: false,
                    Cancelled_Status: 1,
                    $or: [
                      { end_NoTime: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } },
                      { start_NoTime: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } },
                      { start_NoTime: Start_final_withoutTime },
                      { end_NoTime: End_final_withoutTime },
                      { $and: [{ start: { $gte: start_Date } }, { end: { $lte: End_final_withoutTime } }] },
                      { $and: [{ start: { $lte: start_Date } }, { end: { $gte: End_final_withoutTime } }] },
                    ],
                  }).then(
                    (
                      Cancelresults //for cancellation
                    ) => {
                      if (Cancelresults == null) {
                        console.log(Cancelresults, 'cancellation rewsulttttt');
  
                        Schedule.find({ Boat_Id: Boat_id, isBookingPending: false, IsActive: true, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then(
                          (result) => {
                            console.log(result.length, 'length');
                            var _Length = result.length;
                            if (_Length == 0) {
                              Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                                if (result2 == null) {
                                  Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                                    if (results == null) {
                                      Schedule.findOne({
                                        Boat_Id: Boat_id,
                                        isBookingPending: false,
                                        IsActive: true,
                                        $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                                      }).then((results) => {
                                        if (results == null) {
                                          Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((response) => {
                                            var SummerWeekdays = response.Summer_WeekDays;
                                            var SummerWeekendDays = response.Summer_WeekEndDays;
                                            var WinterWeekDays = response.Winter_WeekDays;
                                            var WinterweekendDays = response.Winter_WeekEndDays;
                                            //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
  
                                            Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (Boatresults) => {
                                              console.log(Boatresults);
  
                                              let stopExecution = { stop: false };
                                              let isAvailableDay = await checkIfIncludedInSeason(
                                                Boat_id,
                                                Owner_id,
                                                Boatresults.SummerSeason_SDate,
                                                Boatresults.SummerSeason_EDate,
                                                start_Date,
                                                end_Date
                                              ).catch((error) => {
                                                console.log(error);
                                                stopExecution = error;
                                              });
  
                                              if (stopExecution.stop) {
                                                return reject({ status: true, message: stopExecution.error });
                                              }
  
                                              if (isAvailableDay && isAvailableDay.status) {
                                                //check Date Between Summer Dates
                                                //check if next booking included
  
                                                let isNextDaysError = false;
                                                let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                  req.body.start,
                                                  req.body.end,
                                                  req.body.Boat_Id,
                                                  req.body.timeZone,
                                                  true,
                                                  req.body.User_Id
                                                ).catch((error) => {
                                                  isNextDaysError = true;
                                                  return reject(error);
                                                });
  
                                                if (isNextDaysError) return;
  
                                                consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                  if (element != null) {
                                                    if (element.Summer_ConsecutiveDays >= Total_Count) {
                                                      //consecutive count
  
                                                      //count of weekday and week end
                                                      // for updating Summer days
                                                      Boats.findByIdAndUpdate(
                                                        { _id: mongoose.Types.ObjectId(Boat_id) },
                                                        {
                                                          Summer_WeekDays: SummerWeekdays - WeekDay_Count,
                                                          Summer_WeekEndDays: SummerWeekendDays - WeekEnd_Count,
                                                        },
                                                        { new: true },
                                                        function (err, data) {}
                                                      );
  
                                                      var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                      console.log(x);
  
                                                      //update Summer
  
                                                      //Add Summer Section
  
                                                      let Add_Schedule = new Schedule({
                                                        Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                        Booking_ID: globalbookingid,
                                                        Boat_Name: req.body.Boat_Name,
                                                        Total_DaysBooked: Total_Count,
                                                        calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                        title: req.body.title,
                                                        body: req.body.body,
                                                        start: req.body.start,
                                                        end: req.body.end,
                                                        start_NoTime: Start_final,
                                                        end_NoTime: End_final,
                                                        goingDuration: req.body.goingDuration,
                                                        comingDuration: req.body.comingDuration,
                                                        isAllDay: req.body.isAllDay,
                                                        category: req.body.category,
                                                        dueDateClass: req.body.dueDateClass,
                                                        location: req.body.location,
                                                        attendees: req.body.attendees,
                                                        recurrenceRule: req.body.recurrenceRule,
                                                        Is_StandByBooking: req.body.Is_StandByBooking,
                                                        Check_Status: req.body.Check_Status,
                                                        commends: req.body.commends,
                                                        isPending: req.body.isPending,
                                                        isFocused: req.body.isFocused,
                                                        isVisible: req.body.isVisible,
                                                        isReadOnly: req.body.isReadOnly,
                                                        isPrivate: req.body.isPrivate,
                                                        color: req.body.color,
                                                        bgColor: req.body.bgColor,
                                                        dragBgColor: req.body.dragBgColor,
                                                        borderColor: req.body.borderColor,
                                                        customStyle: req.body.customStyle,
                                                        raw: req.body.raw,
                                                        state: req.body.state,
                                                        User_RoleType: req.body.User_RoleType,
                                                        User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                        Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                        Status: Module_status,
                                                        IsActive: req.body.IsActive,
                                                        Current_Time: moment(Date.now()),
                                                        Updated_time: moment(Date.now()),
                                                        isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                        isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                        WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                      });
  
                                                      Add_Schedule.save()
                                                        .then((response) => {
                                                          console.log('booking saved to schedule');
  
                                                          //mail
                                                          const emailState =  'Successfully Booked.';
                                                          const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
                                                          const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
                                                          const emailDetailName = 'Booking Details'
                                                          const emailDetails = [
                                                            { key: 'Boat Name', value: boatDetails.Boat_Name  },
                                                            { key: 'Booking Date', value: getCurrentTimeFormatted() },
                                                          ];
                                                          const emailNameAndLink = {
                                                            name:'Booking  Link',
                                                            link:`${process.env.CLIENT_URL}/boat-bookings`
                                                          }
  
                                                          var mailOptions = {
                                                            from: 'noreply.smartboatbooking@gmail.com',
                                                            to: OwnerDetails.Email,
                                                            //to: "bjibin3@gmail.com",
                                                            subject: 'Successfully Booked',
                                                            html: getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                                              
                                                          };
  
                                                          transporter.sendMail(mailOptions, function (error, info) {});
  
                                                          var mailOptionsAdmin = {
                                                            from: 'noreply.smartboatbooking@gmail.com',
                                                            to: 'admin@smartboating.com.au',
                                                            subject: 'Successfully Booked',
                                                            html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                                              
                                                          };
  
                                                          transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                                          //mail
  
                                                          return resolve({ status: true, message: 'The booking has been successfully created' });
                                                        })
                                                        .catch((error) => {
                                                          return reject({
                                                            message: error,
                                                          });
                                                        });
                                                    } else {
                                                      return reject({
                                                        status: false,
                                                        message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                      });
                                                    }
                                                  } else {
                                                    return reject({
                                                      status: false,
                                                      message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                    });
                                                  }
                                                });
                                              } else {
                                                //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
  
                                                Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (BoatresultsWinter) => {
                                                  console.log(BoatresultsWinter);
  
                                                  //list all winter start and end date of  owne  based on owner duration  duration which include all year
  
                                                  let stopExecution = { stop: false };
                                                  let isAvailableDay = await checkIfIncludedInSeason(
                                                    Boat_id,
                                                    Owner_id,
                                                    BoatresultsWinter.WinterSeason_SDate,
                                                    BoatresultsWinter.WinterSeason_EDate,
                                                    start_Date,
                                                    end_Date
                                                  ).catch((error) => {
                                                    console.log(error);
                                                    stopExecution = error;
                                                  });
  
                                                  if (stopExecution.stop) {
                                                    return reject({ status: true, message: stopExecution.error });
                                                  }
  
                                                  if (isAvailableDay && isAvailableDay.status) {
                                                    //check Date Between winter Dates
                                                    //check if next booking included
  
                                                    let isNextDaysError = false;
                                                    let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                      req.body.start,
                                                      req.body.end,
                                                      req.body.Boat_Id,
                                                      req.body.timeZone,
                                                      false,
                                                      req.body.User_Id
                                                    ).catch((error) => {
                                                      isNextDaysError = true;
                                                      return reject(error);
                                                    });
  
                                                    if (isNextDaysError) return;
  
                                                    console.log(Boat_id, 'Boat_Id');
  
                                                    consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                      console.log('consecutive find one');
  
                                                      if (element != null) {
                                                        console.log(element, 'element');
  
                                                        if (element.Winter_ConsecutiveDays >= Total_Count) {
                                                          console.log(
                                                            WinterWeekDays,
                                                            'WinterWeekDays',
                                                            WeekDay_Count,
                                                            'WeekDay_Count',
                                                            WinterweekendDays,
                                                            'WinterweekendDays',
                                                            WeekEnd_Count,
                                                            'WeekEnd_Count'
                                                          );
  
                                                          //count of weekday and week end
                                                          // for updating Summer days
                                                          Boats.findByIdAndUpdate(
                                                            { _id: mongoose.Types.ObjectId(Boat_id) },
                                                            {
                                                              Winter_WeekDays: WinterWeekDays - WeekDay_Count,
                                                              Winter_WeekEndDays: WinterweekendDays - WeekEnd_Count,
                                                            },
                                                            { new: true },
                                                            function (err, data) {}
                                                          );
  
                                                          var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                          console.log(x);
                                                          //
                                                          console.log('before save');
  
                                                          //Add Winter Section
  
                                                          let Add_Schedule = new Schedule({
                                                            Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                            Booking_ID: globalbookingid,
                                                            Boat_Name: req.body.Boat_Name,
                                                            Total_DaysBooked: Total_Count,
                                                            calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                            title: req.body.title,
                                                            body: req.body.body,
                                                            start: req.body.start,
                                                            end: req.body.end,
                                                            start_NoTime: Start_final,
                                                            end_NoTime: End_final,
                                                            goingDuration: req.body.goingDuration,
                                                            comingDuration: req.body.comingDuration,
                                                            isAllDay: req.body.isAllDay,
                                                            category: req.body.category,
                                                            dueDateClass: req.body.dueDateClass,
                                                            location: req.body.location,
                                                            attendees: req.body.attendees,
                                                            recurrenceRule: req.body.recurrenceRule,
                                                            isPending: req.body.isPending,
                                                            isFocused: req.body.isFocused,
                                                            isVisible: req.body.isVisible,
                                                            isReadOnly: req.body.isReadOnly,
                                                            isPrivate: req.body.isPrivate,
                                                            Is_StandByBooking: req.body.Is_StandByBooking,
                                                            Check_Status: req.body.Check_Status,
                                                            commends: req.body.commends,
                                                            color: req.body.color,
                                                            bgColor: req.body.bgColor,
                                                            dragBgColor: req.body.dragBgColor,
                                                            borderColor: req.body.borderColor,
                                                            customStyle: req.body.customStyle,
                                                            raw: req.body.raw,
                                                            state: req.body.state,
                                                            User_RoleType: req.body.User_RoleType,
                                                            User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                            Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                            Status: Module_status,
                                                            IsActive: req.body.IsActive,
                                                            Current_Time: moment(Date.now()),
                                                            Updated_time: moment(Date.now()),
                                                            isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                            isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                            WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                          });
  
                                                          Add_Schedule.save()
                                                            .then((response) => {
                                                              console.log('booking saved to schedule');
  
                                                              //mail
                                                              const emailState =  'Successfully Booked.';
                                                              const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
                                                              const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
                                                              const emailDetailName = 'Booking Details'
                                                              const emailDetails = [
                                                                { key: 'Boat Name', value: boatDetails.Boat_Name  },
                                                                { key: 'Booking Date', value: getCurrentTimeFormatted() },
                                                              ];
                                                              const emailNameAndLink = {
                                                                name:'Booking  Link',
                                                                link:`${process.env.CLIENT_URL}/boat-bookings`
                                                              }
                                                              var mailOptions = {
                                                                from: 'noreply.smartboatbooking@gmail.com',
                                                                to: OwnerDetails.Email,
                                                                //to: "bjibin3@gmail.com",
                                                                subject: 'Successfully Booked',
                                                                html:getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                                                                 
                                                              };
  
                                                              transporter.sendMail(mailOptions, function (error, info) {});
  
                                                              var mailOptionsAdmin = {
                                                                from: 'noreply.smartboatbooking@gmail.com',
                                                                to: 'admin@smartboating.com.au',
                                                                subject: 'Successfully Booked',
                                                                html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                                                  
                                                              };
  
                                                              transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                                              //mail
  
                                                              return resolve({ status: true, message: 'The booking has been successfully created' });
                                                            })
                                                            .catch((error) => {
                                                              console.log(error, 'save error');
                                                              return reject({
                                                                message: error,
                                                              });
                                                            });
                                                        } else {
                                                          console.log({
                                                            message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                          });
  
                                                          return reject({
                                                            status: false,
                                                            message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                          });
                                                        }
                                                      } else {
                                                        console.log({
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                        });
  
                                                        return reject({
                                                          status: false,
                                                          message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                        });
                                                      }
                                                    });
                                                  } else {
                                                    return reject({
                                                      status: false,
                                                      message: 'These Dates Are not Allowed for Booking',
                                                    });
                                                  }
                                                });
                                              } //else
                                            });
                                          });
                                        } else {
                                          return reject({
                                            status: false,
                                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                          });
                                        }
                                      });
                                    } else {
                                      return reject({
                                        status: false,
                                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                      });
                                    }
                                  });
                                } else {
                                  return reject({
                                    status: false,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              }); //else inside function owner
                            } else {
                              return reject({
                                status: false,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          }
                        );
                      } else {
                        //
  
                        console.log(Start_final_withoutTime);
                        console.log(End_final_withoutTime);
                        console.log(Cancelresults.Updated_time, 'thissssssssss');
                        var todaysdate = moment();
                        console.log(todaysdate);
                        var canceldate = moment(Cancelresults.Updated_time);
                        var dif = moment.duration(todaysdate.diff(canceldate));
                        console.log(dif.asHours());
                        var Hrdif = Math.round(dif.asHours());
  
                        console.log(Hrdif);
  
                        if (Hrdif > 24) {
                          Schedule.find({ Boat_Id: Boat_id, isBookingPending: false, IsActive: true, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then(
                            (result) => {
                              console.log(result.length, 'length');
                              var _Length = result.length;
                              if (_Length == 0) {
                                Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                                  if (result2 == null) {
                                    Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                                      if (results == null) {
                                        Schedule.findOne({
                                          Boat_Id: Boat_id,
                                          isBookingPending: false,
                                          IsActive: true,
                                          $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                                        }).then((results) => {
                                          if (results == null) {
                                            Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((response) => {
                                              var SummerWeekdays = response.Summer_WeekDays;
                                              var SummerWeekendDays = response.Summer_WeekEndDays;
                                              var WinterWeekDays = response.Winter_WeekDays;
                                              var WinterweekendDays = response.Winter_WeekEndDays;
  
                                              //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
  
                                              Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (Boatresults) => {
                                                console.log(Boatresults);
  
                                                let stopExecution = { stop: false };
                                                let isAvailableDay = await checkIfIncludedInSeason(
                                                  Boat_id,
                                                  Owner_id,
                                                  Boatresults.SummerSeason_SDate,
                                                  Boatresults.SummerSeason_EDate,
                                                  start_Date,
                                                  end_Date
                                                ).catch((error) => {
                                                  console.log(error);
                                                  stopExecution = error;
                                                });
  
                                                if (stopExecution.stop) {
                                                  return reject({ status: true, message: stopExecution.error });
                                                }
  
                                                if (isAvailableDay && isAvailableDay.status) {
                                                  //check Date Between Summer Dates
                                                  //check if next booking included
  
                                                  let isNextDaysError = false;
                                                  let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                    req.body.start,
                                                    req.body.end,
                                                    req.body.Boat_Id,
                                                    req.body.timeZone,
                                                    true,
                                                    req.body.User_Id
                                                  ).catch((error) => {
                                                    isNextDaysError = true;
                                                    return reject(error);
                                                  });
  
                                                  if (isNextDaysError) return;
  
                                                  consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                    if (element != null) {
                                                      if (element.Summer_ConsecutiveDays >= Total_Count) {
                                                        //consecutive count
  
                                                        //count of weekday and week end
                                                        // for updating Summer days
                                                        Boats.findByIdAndUpdate(
                                                          { _id: mongoose.Types.ObjectId(Boat_id) },
                                                          {
                                                            Summer_WeekDays: SummerWeekdays - WeekDay_Count,
                                                            Summer_WeekEndDays: SummerWeekendDays - WeekEnd_Count,
                                                          },
                                                          { new: true },
                                                          function (err, data) {}
                                                        );
  
                                                        var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                        console.log(x);
  
                                                        //update Summer
  
                                                        //Add Summer Section
  
                                                        let Add_Schedule = new Schedule({
                                                          Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                          Booking_ID: globalbookingid,
                                                          Boat_Name: req.body.Boat_Name,
                                                          Total_DaysBooked: Total_Count,
                                                          calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                          title: req.body.title,
                                                          body: req.body.body,
                                                          start: req.body.start,
                                                          end: req.body.end,
                                                          start_NoTime: Start_final,
                                                          end_NoTime: End_final,
                                                          goingDuration: req.body.goingDuration,
                                                          comingDuration: req.body.comingDuration,
                                                          isAllDay: req.body.isAllDay,
                                                          category: req.body.category,
                                                          dueDateClass: req.body.dueDateClass,
                                                          location: req.body.location,
                                                          attendees: req.body.attendees,
                                                          recurrenceRule: req.body.recurrenceRule,
                                                          Is_StandByBooking: req.body.Is_StandByBooking,
                                                          Check_Status: req.body.Check_Status,
                                                          commends: req.body.commends,
                                                          isPending: req.body.isPending,
                                                          isFocused: req.body.isFocused,
                                                          isVisible: req.body.isVisible,
                                                          isReadOnly: req.body.isReadOnly,
                                                          isPrivate: req.body.isPrivate,
                                                          color: req.body.color,
                                                          bgColor: req.body.bgColor,
                                                          dragBgColor: req.body.dragBgColor,
                                                          borderColor: req.body.borderColor,
                                                          customStyle: req.body.customStyle,
                                                          raw: req.body.raw,
                                                          state: req.body.state,
                                                          User_RoleType: req.body.User_RoleType,
                                                          User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                          Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                          Status: Module_status,
                                                          IsActive: req.body.IsActive,
                                                          Current_Time: moment(Date.now()),
                                                          Updated_time: moment(Date.now()),
                                                          isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                          isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                          WeekDay_Count,
                                                          WeekEnd_Count,
                                                          isStandByBookingIncluded:true,
                                                         standByBookingId
                                                        });
  
                                                        Add_Schedule.save()
                                                          .then((response) => {
                                                            console.log('booking saved to schedule');
  
                                                            return resolve({ status: true, message: 'The booking has been successfully created' });
                                                          })
                                                          .catch((error) => {
                                                            return reject({
                                                              message: error,
                                                            });
                                                          });
                                                      } else {
                                                        return reject({
                                                          status: false,
                                                          message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                        });
                                                      }
                                                    } else {
                                                      return reject({
                                                        status: false,
                                                        message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                      });
                                                    }
                                                  });
                                                } else {
                                                  //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                                  Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (BoatresultsWinter) => {
                                                    console.log(BoatresultsWinter);
                                                    //list all winter start and end date of  owne  based on owner duration  duration which include all year
  
                                                    let stopExecution = { stop: false };
                                                    let isAvailableDay = await checkIfIncludedInSeason(
                                                      Boat_id,
                                                      Owner_id,
                                                      BoatresultsWinter.WinterSeason_SDate,
                                                      BoatresultsWinter.WinterSeason_EDate,
                                                      start_Date,
                                                      end_Date
                                                    ).catch((error) => {
                                                      console.log(error);
                                                      stopExecution = error;
                                                    });
  
                                                    if (stopExecution.stop) {
                                                      return reject({ status: true, message: stopExecution.error });
                                                    }
  
                                                    if (isAvailableDay && isAvailableDay.status) {
                                                      //check Date Between winter Dates
                                                      //check if next booking included
  
                                                      let isNextDaysError = false;
                                                      let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                                        req.body.start,
                                                        req.body.end,
                                                        req.body.Boat_Id,
                                                        req.body.timeZone,
                                                        false,
                                                        req.body.User_Id
                                                      ).catch((error) => {
                                                        isNextDaysError = true;
                                                        return reject(error);
                                                      });
  
                                                      if (isNextDaysError) return;
  
                                                      consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                                        if (element != null) {
                                                          if (element.Winter_ConsecutiveDays >= Total_Count) {
                                                            //count of weekday and week end
                                                            // for updating Summer days
                                                            Boats.findByIdAndUpdate(
                                                              { _id: mongoose.Types.ObjectId(Boat_id) },
                                                              {
                                                                Winter_WeekDays: WinterWeekDays - WeekDay_Count,
                                                                Winter_WeekEndDays: WinterweekendDays - WeekEnd_Count,
                                                              },
                                                              { new: true },
                                                              function (err, data) {}
                                                            );
  
                                                            var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                            console.log(x);
  
                                                            //Add Winter Section
  
                                                            let Add_Schedule = new Schedule({
                                                              Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                              Booking_ID: globalbookingid,
                                                              Boat_Name: req.body.Boat_Name,
                                                              Total_DaysBooked: Total_Count,
                                                              calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                              title: req.body.title,
                                                              body: req.body.body,
                                                              start: req.body.start,
                                                              end: req.body.end,
                                                              start_NoTime: Start_final,
                                                              end_NoTime: End_final,
                                                              goingDuration: req.body.goingDuration,
                                                              comingDuration: req.body.comingDuration,
                                                              isAllDay: req.body.isAllDay,
                                                              category: req.body.category,
                                                              dueDateClass: req.body.dueDateClass,
                                                              location: req.body.location,
                                                              attendees: req.body.attendees,
                                                              recurrenceRule: req.body.recurrenceRule,
                                                              isPending: req.body.isPending,
                                                              isFocused: req.body.isFocused,
                                                              isVisible: req.body.isVisible,
                                                              isReadOnly: req.body.isReadOnly,
                                                              isPrivate: req.body.isPrivate,
                                                              Is_StandByBooking: req.body.Is_StandByBooking,
                                                              Check_Status: req.body.Check_Status,
                                                              commends: req.body.commends,
                                                              color: req.body.color,
                                                              bgColor: req.body.bgColor,
                                                              dragBgColor: req.body.dragBgColor,
                                                              borderColor: req.body.borderColor,
                                                              customStyle: req.body.customStyle,
                                                              raw: req.body.raw,
                                                              state: req.body.state,
                                                              User_RoleType: req.body.User_RoleType,
                                                              User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                              Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                              Status: Module_status,
                                                              IsActive: req.body.IsActive,
                                                              Current_Time: moment(Date.now()),
                                                              Updated_time: moment(Date.now()),
                                                              isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                              isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                              WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                            });
  
                                                            Add_Schedule.save()
                                                              .then((response) => {
                                                                console.log('booking saved to schedule');
  
                                                                return resolve({ status: true, message: 'The booking has been successfully created' });
                                                              })
                                                              .catch((error) => {
                                                                return reject({
                                                                  message: error,
                                                                });
                                                              });
  
                                                            //Add Winter Section
                                                          } else {
                                                            return reject({
                                                              status: false,
                                                              message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                            });
                                                          }
                                                        } else {
                                                          return reject({
                                                            status: false,
                                                            message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                          });
                                                        }
                                                      });
                                                    } else {
                                                      return reject({
                                                        status: false,
                                                        message: 'These Dates Are not Allowed for Booking',
                                                      });
                                                    }
                                                  });
                                                } //else
                                              });
                                            });
                                          } else {
                                            return reject({
                                              status: false,
                                              message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                            });
                                          }
                                        });
                                      } else {
                                        return reject({
                                          status: false,
                                          message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                        });
                                      }
                                    });
                                  } else {
                                    return reject({
                                      status: false,
                                      message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                    });
                                  }
                                }); //else inside function owner
                              } else {
                                return reject({
                                  status: false,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                });
                              }
                            }
                          );
                        } else {
                          return reject({
                            status: false,
                            message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again',
                          });
                        } //
  
                        // return reject({
                        //     status:false,
                        //     message: 'You will be allowed to rebook on '+' ' +moment(Start_final).format('DD-MM-YYYY') +' '  +'to' +' ' +moment(End_final).format('DD-MM-YYYY') +' '  +'for' +' ' +boatDetails.Boat_Name +' '  +'only after 24 hours from now'
                        // })
                      }
                    }
                  );
                }
              } else {
                return reject({
                  status: false,
                  message: 'A booking cannot be created for a previous day',
                });
              }
            }
  
            if ((check_Status = '4' && User_role == 'Maintenance')) {
              if (dif >= 0) {
                //for Previous Date
                Schedule.find({ Boat_Id: Boat_id, isBookingPending: false, IsActive: true, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then((result) => {
                  console.log(result.length, 'length');
                  var _Length = result.length;
                  if (_Length == 0) {
                    Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                      if (result2 == null) {
                        Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                          if (results == null) {
                            Schedule.findOne({
                              Boat_Id: Boat_id,
                              isBookingPending: false,
                              IsActive: true,
                              $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                            }).then((results) => {
                              if (results == null) {
                                //Add
                                console.log('Admin');
                                let Add_Schedule = new Schedule({
                                  Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                  Booking_ID: globalbookingid,
                                  Boat_Name: req.body.Boat_Name,
                                  Total_DaysBooked: Total_Count,
                                  calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                  title: req.body.title,
                                  body: req.body.body,
                                  start: req.body.start,
                                  end: req.body.end,
                                  start_NoTime: Start_final_withoutTime,
                                  end_NoTime: Start_final_withoutTime,
                                  goingDuration: req.body.goingDuration,
                                  comingDuration: req.body.comingDuration,
                                  isAllDay: req.body.isAllDay,
                                  category: req.body.category,
                                  dueDateClass: req.body.dueDateClass,
                                  location: req.body.location,
                                  attendees: req.body.attendees,
                                  recurrenceRule: req.body.recurrenceRule,
                                  isPending: req.body.isPending,
                                  isFocused: req.body.isFocused,
                                  isVisible: req.body.isVisible,
                                  isReadOnly: req.body.isReadOnly,
                                  isPrivate: req.body.isPrivate,
                                  color: req.body.color,
                                  Is_StandByBooking: req.body.Is_StandByBooking,
                                  Check_Status: req.body.Check_Status,
                                  commends: req.body.commends,
                                  bgColor: req.body.bgColor,
                                  dragBgColor: req.body.dragBgColor,
                                  borderColor: req.body.borderColor,
                                  customStyle: req.body.customStyle,
                                  raw: req.body.raw,
                                  state: req.body.state,
                                  User_RoleType: req.body.User_RoleType,
                                  User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                  Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                  Status: Module_status,
                                  IsActive: req.body.IsActive,
                                  Current_Time: moment(Date.now()),
                                  Updated_time: moment(Date.now()),
                                  WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                });
  
                                Add_Schedule.save()
                                  .then((response) => {
                                    console.log('booking saved to schedule');
  
                                    //mail
                                    const emailState =  'Successfully Booked.';
                                    const emailContent = `Dear ${OwnerDetails.First_Name} your Boat ${boatDetails.Boat_Name} has been succesfully booked on ${getCurrentTimeFormatted()}`;
                                    const emailContentAdmin = `Dear Adminsistrator the Boat ${boatDetails.Boat_Name} has been successfully booked by ${OwnerDetails.First_Name} on ${getCurrentTimeFormatted()}`;
                                    const emailDetailName = 'Booking Details'
                                    const emailDetails = [
                                      { key: 'Boat Name', value: boatDetails.Boat_Name  },
                                      { key: 'Booking Date', value: getCurrentTimeFormatted() },
                                    ];
                                    const emailNameAndLink = {
                                      name:'Booking  Link',
                                      link:`${process.env.CLIENT_URL}/boat-bookings`
                                    }
  
                                    var mailOptionsAdmin = {
                                      from: 'noreply.smartboatbooking@gmail.com',
                                      to: 'admin@smartboating.com.au',
                                      subject: 'Maintainance Booking',
                                      html:getEmailTemplate(emailState,emailContentAdmin,emailDetailName,emailDetails,emailNameAndLink)
                                       
                                    };
  
                                    transporter.sendMail(mailOptionsAdmin, function (error, info) {});
                                    //mail
  
                                    return reject({
                                      status: true,
                                      message: 'The boat maintenance booking has been successfully created',
                                    });
                                  })
                                  .catch((error) => {
                                    return reject({
                                      message: error,
                                    });
                                  });
                              } else {
                                return reject({
                                  status: true,
                                  message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                });
                              }
                            });
                            //Add
                          } else {
                            return reject({
                              status: true,
                              message: 'An existing booking already exists for this date. A new booking cannot be created.',
                            });
                          }
                        });
                      } else {
                        return reject({
                          status: true,
                          message: 'An existing booking already exists for this date. A new booking cannot be created.',
                        });
                      }
                    });
                  } else {
                    return reject({
                      status: true,
                      message: 'An existing booking already exists for this date. A new booking cannot be created.',
                    });
                  }
                });
              } else {
                return reject({
                  status: false,
                  message: 'A booking cannot be created for a previous day',
                });
              }
            }
  
            // special Day
            if (specialDayCheck == 1) {
              console.log('special dayyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy');
              const Specialday_id = req.body.Specialday_id;
              const obj = req.body.Special_Day;
  
              if (dif >= 0) {
                //for Previous Date
                if (User_role == 'Admin') {
                  //for Admin
                  Schedule.find({ Boat_Id: Boat_id, isBookingPending: false, IsActive: true, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then((result) => {
                    console.log(result.length, 'length');
                    var _Length = result.length;
                    if (_Length == 0) {
                      Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                        if (result2 == null) {
                          Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                            if (results == null) {
                              Schedule.findOne({
                                Boat_Id: Boat_id,
                                isBookingPending: false,
                                IsActive: true,
                                $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                              }).then((results) => {
                                if (results == null) {
                                  //Add
                                  console.log('Admin');
                                  let Add_Schedule = new Schedule({
                                    Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                    Booking_ID: globalbookingid,
                                    Boat_Name: req.body.Boat_Name,
                                    Total_DaysBooked: Total_Count,
                                    calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                    title: req.body.title,
                                    body: req.body.body,
                                    start: req.body.start,
                                    end: req.body.end,
                                    start_NoTime: Start_final_withoutTime,
                                    end_NoTime: End_final_withoutTime,
                                    goingDuration: req.body.goingDuration,
                                    comingDuration: req.body.comingDuration,
                                    isAllDay: req.body.isAllDay,
                                    category: req.body.category,
                                    dueDateClass: req.body.dueDateClass,
                                    location: req.body.location,
                                    attendees: req.body.attendees,
                                    recurrenceRule: req.body.recurrenceRule,
                                    isPending: req.body.isPending,
                                    isFocused: req.body.isFocused,
                                    isVisible: req.body.isVisible,
                                    isReadOnly: req.body.isReadOnly,
                                    isPrivate: req.body.isPrivate,
                                    color: req.body.color,
                                    bgColor: req.body.bgColor,
                                    Is_StandByBooking: req.body.Is_StandByBooking,
                                    Check_Status: req.body.Check_Status,
                                    commends: req.body.commends,
                                    dragBgColor: req.body.dragBgColor,
                                    borderColor: req.body.borderColor,
                                    customStyle: req.body.customStyle,
                                    raw: req.body.raw,
                                    state: req.body.state,
                                    User_RoleType: req.body.User_RoleType,
                                    User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                    Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                    Status: Module_status,
                                    IsActive: req.body.IsActive,
                                    Current_Time: moment(Date.now()),
                                    Updated_time: moment(Date.now()),
                                    WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                  });
  
                                  Add_Schedule.save()
                                    .then((response) => {
                                      console.log('booking saved to schedule');
  
                                      return reject({
                                        status: true,
                                        message: 'The admin booking has been successfully created',
                                      });
                                    })
                                    .catch((error) => {
                                      return reject({
                                        message: error,
                                      });
                                    });
                                } else {
                                  return reject({
                                    status: true,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              });
                              //Add
                            } else {
                              return reject({
                                status: true,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          });
                        } else {
                          return reject({
                            status: true,
                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                          });
                        }
                      });
                    } else {
                      return reject({
                        status: true,
                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                      });
                    }
                  });
                } //For Owner
                else {
                  Schedule.find({ Boat_Id: Boat_id, isBookingPending: false, IsActive: true, $or: [{ start_NoTime: Start_final_withoutTime }, { end_NoTime: End_final_withoutTime }] }).then((result) => {
                    console.log(result.length, 'length');
                    var _Length = result.length;
                    if (_Length == 0) {
                      Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $gte: start_Date }, end: { $lte: End_final_withoutTime }, IsActive: true }).then((result2) => {
                        if (result2 == null) {
                          Schedule.findOne({ Boat_Id: Boat_id, isBookingPending: false, start: { $lte: start_Date }, end: { $gte: End_final_withoutTime }, IsActive: true }).then((results) => {
                            if (results == null) {
                              Schedule.findOne({
                                Boat_Id: Boat_id,
                                isBookingPending: false,
                                IsActive: true,
                                $or: [{ end: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }, { start: { $gte: Start_final_withoutTime, $lte: End_final_withoutTime } }],
                              }).then((results) => {
                                if (results == null) {
                                  // special Day
                                  // CheckSpecialDaysExist(Boat_id,Owner_id,obj).then(function(myflag) {
                                  //     console.log(myflag,'Orginal value')
  
                                  // if(myflag==0)
                                  // {
                                  //     console.log('inside if jibin')
  
                                  //     obj.map(function(objs) {
                                  //     var specialday=objs.special_date;
                                  //     var Specialdayid=objs._id;
                                  //     var Start_final=moment(specialday);
                                  //     var Start_final_withoutTime=Start_final.startOf('day');
                                  //     console.log(Start_final_withoutTime)
                                  // var addspecial=AddSpecialDay(Boat_id,Owner_id,Specialdayid,specialday,Start_final)
                                  // if( addspecial == true)
                                  //     {
                                  //     console.log('successs')
                                  //     }
                                  //     else{
                                  //         console.log('fail')
                                  //     }
                                  // })
                                  // }
  
                                  //special day
  
                                  Boats.findById({ _id: mongoose.Types.ObjectId(Boat_id) }).then((response) => {
                                    var SummerWeekdays = response.Summer_WeekDays;
                                    var SummerWeekendDays = response.Summer_WeekEndDays;
                                    var WinterWeekDays = response.Winter_WeekDays;
                                    var WinterweekendDays = response.Winter_WeekEndDays;
  
                                    //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime},
  
                                    Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (Boatresults) => {
                                      console.log(Boatresults);
  
                                      let stopExecution = { stop: false };
                                      let isAvailableDay = await checkIfIncludedInSeason(Boat_id, Owner_id, Boatresults.SummerSeason_SDate, Boatresults.SummerSeason_EDate, start_Date, end_Date).catch(
                                        (error) => {
                                          console.log(error);
                                          stopExecution = error;
                                        }
                                      );
  
                                      if (stopExecution.stop) {
                                        return reject({ status: true, message: stopExecution.error });
                                      }
  
                                      if (isAvailableDay && isAvailableDay.status) {
                                        //check Date Between Summer Dates
                                        //check if next booking included
  
                                        let isNextDaysError = false;
                                        let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                          req.body.start,
                                          req.body.end,
                                          req.body.Boat_Id,
                                          req.body.timeZone,
                                          true,
                                          req.body.User_Id
                                        ).catch((error) => {
                                          isNextDaysError = true;
                                          return reject(error);
                                        });
  
                                        if (isNextDaysError) return;
  
                                        consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                          if (element != null) {
                                            if (element.Summer_ConsecutiveDays >= Total_Count) {
                                              //consecutive count
  
                                              //count of weekday and week end
                                              // for updating Summer days
                                              Boats.findByIdAndUpdate(
                                                { _id: mongoose.Types.ObjectId(Boat_id) },
                                                {
                                                  Summer_WeekDays: SummerWeekdays - WeekDay_Count,
                                                  Summer_WeekEndDays: SummerWeekendDays - WeekEnd_Count,
                                                },
                                                { new: true },
                                                function (err, data) {}
                                              );
  
                                              var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                              console.log(x);
  
                                              //update Summer
                                              // special Day
  
                                              CheckSpecialDaysExist(Boat_id, Owner_id, obj).then(function (myflag) {
                                                console.log(myflag, 'Orginal value');
                                                console.log(hello, 'Orginal Value22222');
  
                                                if (myflag == 0) {
                                                  console.log('inside if jibin');
  
                                                  obj.map(function (objs) {
                                                    var specialday = objs.special_date;
                                                    var Specialdayid = objs._id;
                                                    var Start_final = moment(specialday);
                                                    var Start_final_withoutTime = Start_final.startOf('day');
                                                    console.log(Start_final_withoutTime);
                                                    var addspecial = AddSpecialDay(Boat_id, Owner_id, Specialdayid, specialday, Start_final);
                                                    if (addspecial == true) {
                                                      console.log('successs');
                                                    } else {
                                                      console.log('fail');
                                                    }
                                                  });
  
                                                  // special Day
  
                                                  //Add Summer Section
  
                                                  let Add_Schedule = new Schedule({
                                                    Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                    Booking_ID: globalbookingid,
                                                    Boat_Name: req.body.Boat_Name,
                                                    Total_DaysBooked: Total_Count,
                                                    calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                    title: req.body.title,
                                                    body: req.body.body,
                                                    start: req.body.start,
                                                    end: req.body.end,
                                                    start_NoTime: Start_final,
                                                    end_NoTime: End_final,
                                                    goingDuration: req.body.goingDuration,
                                                    comingDuration: req.body.comingDuration,
                                                    isAllDay: req.body.isAllDay,
                                                    category: req.body.category,
                                                    dueDateClass: req.body.dueDateClass,
                                                    location: req.body.location,
                                                    attendees: req.body.attendees,
                                                    recurrenceRule: req.body.recurrenceRule,
                                                    Is_StandByBooking: req.body.Is_StandByBooking,
                                                    Check_Status: req.body.Check_Status,
                                                    commends: req.body.commends,
                                                    isPending: req.body.isPending,
                                                    isFocused: req.body.isFocused,
                                                    isVisible: req.body.isVisible,
                                                    isReadOnly: req.body.isReadOnly,
                                                    isPrivate: req.body.isPrivate,
                                                    color: req.body.color,
                                                    bgColor: req.body.bgColor,
                                                    dragBgColor: req.body.dragBgColor,
                                                    borderColor: req.body.borderColor,
                                                    customStyle: req.body.customStyle,
                                                    raw: req.body.raw,
                                                    state: req.body.state,
                                                    User_RoleType: req.body.User_RoleType,
                                                    User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                    Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                    Status: Module_status,
                                                    IsActive: req.body.IsActive,
                                                    Current_Time: moment(Date.now()),
                                                    Updated_time: moment(Date.now()),
                                                    isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                    isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                    WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                  });
  
                                                  Add_Schedule.save()
                                                    .then((response) => {
                                                      console.log('booking saved to schedule');
  
                                                      return resolve({ status: true, message: 'The booking has been successfully created' });
                                                    })
                                                    .catch((error) => {
                                                      return reject({
                                                        message: error,
                                                      });
                                                    });
                                                } //special day
                                                else {
                                                  return reject({
                                                    status: true,
                                                    message: 'You Have Already Booked Special Day',
                                                  });
                                                }
                                              });
                                            } else {
                                              return reject({
                                                status: false,
                                                message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                              });
                                            }
                                          } else {
                                            return reject({
                                              status: false,
                                              message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                            });
                                          }
                                        });
                                      } else {
                                        //WinterSeason_SDate:{$lte:Start_final_withoutTime},WinterSeason_EDate:{$gte:End_final_withoutTime},
                                        Boats.findOne({ _id: Boat_id, IsActive: true }).then(async (BoatresultsWinter) => {
                                          console.log(BoatresultsWinter);
  
                                          //list all winter start and end date of  owne  based on owner duration  duration which include all year
  
                                          let stopExecution = { stop: false };
                                          let isAvailableDay = await checkIfIncludedInSeason(
                                            Boat_id,
                                            Owner_id,
                                            BoatresultsWinter.WinterSeason_SDate,
                                            BoatresultsWinter.WinterSeason_EDate,
                                            start_Date,
                                            end_Date
                                          ).catch((error) => {
                                            console.log(error);
                                            stopExecution = error;
                                          });
  
                                          if (stopExecution.stop) {
                                            return reject({ status: true, message: stopExecution.error });
                                          }
  
                                          if (isAvailableDay && isAvailableDay.status) {
                                            //check Date Between winter Dates
                                            //check if next booking included
  
                                            let isNextDaysError = false;
                                            let isNextBookingDayIncluded = await checkIfNextBookingDayIsIncluded(
                                              req.body.start,
                                              req.body.end,
                                              req.body.Boat_Id,
                                              req.body.timeZone,
                                              false,
                                              req.body.User_Id
                                            ).catch((error) => {
                                              isNextDaysError = true;
                                              return reject(error);
                                            });
  
                                            if (isNextDaysError) return;
  
                                            consecutive.findOne({ Boat_Id: mongoose.Types.ObjectId(Boat_id) }).then((element) => {
                                              if (element != null) {
                                                if (element.Winter_ConsecutiveDays >= Total_Count) {
                                                  //count of weekday and week end
                                                  // for updating Summer days
                                                  Boats.findByIdAndUpdate(
                                                    { _id: mongoose.Types.ObjectId(Boat_id) },
                                                    {
                                                      Winter_WeekDays: WinterWeekDays - WeekDay_Count,
                                                      Winter_WeekEndDays: WinterweekendDays - WeekEnd_Count,
                                                    },
                                                    { new: true },
                                                    function (err, data) {}
                                                  );
  
                                                  var x = AddBookingDays_Owner(Boat_id, Owner_id, start_Date, end_Date, ogTotalDaysCount, ogWeekDaysCount, ogWeekendDaysCount);
                                                  console.log(x);
  
                                                  //Add Winter Section
  
                                                  let Add_Schedule = new Schedule({
                                                    Boat_Id: mongoose.Types.ObjectId(req.body.Boat_Id),
                                                    Booking_ID: globalbookingid,
                                                    Boat_Name: req.body.Boat_Name,
                                                    Total_DaysBooked: Total_Count,
                                                    calendarId: mongoose.Types.ObjectId(req.body.calendarId),
                                                    title: req.body.title,
                                                    body: req.body.body,
                                                    start: req.body.start,
                                                    end: req.body.end,
                                                    start_NoTime: Start_final,
                                                    end_NoTime: End_final,
                                                    goingDuration: req.body.goingDuration,
                                                    comingDuration: req.body.comingDuration,
                                                    isAllDay: req.body.isAllDay,
                                                    category: req.body.category,
                                                    dueDateClass: req.body.dueDateClass,
                                                    location: req.body.location,
                                                    attendees: req.body.attendees,
                                                    recurrenceRule: req.body.recurrenceRule,
                                                    isPending: req.body.isPending,
                                                    isFocused: req.body.isFocused,
                                                    isVisible: req.body.isVisible,
                                                    isReadOnly: req.body.isReadOnly,
                                                    isPrivate: req.body.isPrivate,
                                                    Is_StandByBooking: req.body.Is_StandByBooking,
                                                    Check_Status: req.body.Check_Status,
                                                    commends: req.body.commends,
                                                    color: req.body.color,
                                                    bgColor: req.body.bgColor,
                                                    dragBgColor: req.body.dragBgColor,
                                                    borderColor: req.body.borderColor,
                                                    customStyle: req.body.customStyle,
                                                    raw: req.body.raw,
                                                    state: req.body.state,
                                                    User_RoleType: req.body.User_RoleType,
                                                    User_Id: mongoose.Types.ObjectId(req.body.User_Id),
                                                    Admin_Id: mongoose.Types.ObjectId(req.body.Admin_Id),
                                                    Status: Module_status,
                                                    IsActive: req.body.IsActive,
                                                    Current_Time: moment(Date.now()),
                                                    Updated_time: moment(Date.now()),
                                                    isBookingPending: isNextBookingDayIncluded.included ? true : false,
                                                    isNextDayBookingIncluded: isNextBookingDayIncluded.isNextDayBookingIncluded,
                                                    WeekDay_Count,
                                                      WeekEnd_Count,
                                                      isStandByBookingIncluded:true,
                                                     standByBookingId
                                                  });
  
                                                  Add_Schedule.save()
                                                    .then((response) => {
                                                      console.log('booking saved to schedule');
  
                                                      return resolve({ status: true, message: 'The booking has been successfully created' });
                                                    })
                                                    .catch((error) => {
                                                      return reject({
                                                        message: error,
                                                      });
                                                    });
  
                                                  //Add Winter Section
                                                } else {
                                                  return reject({
                                                    status: false,
                                                    message: 'The booking exceeds the maximum booking duration. Please try to create a booking with fewer days',
                                                  });
                                                }
                                              } else {
                                                return reject({
                                                  status: false,
                                                  message: 'The maximum duration for bookings has not been selected. Please go to settings and allocate this setting before making a booking',
                                                });
                                              }
                                            });
                                          } else {
                                            return reject({
                                              status: false,
                                              message: 'These Dates Are not Allowed for Booking',
                                            });
                                          }
                                        });
                                      } //else
                                    });
                                  });
                                } else {
                                  return reject({
                                    status: false,
                                    message: 'An existing booking already exists for this date. A new booking cannot be created.',
                                  });
                                }
                              });
                            } else {
                              return reject({
                                status: false,
                                message: 'An existing booking already exists for this date. A new booking cannot be created.',
                              });
                            }
                          });
                        } else {
                          return reject({
                            status: false,
                            message: 'An existing booking already exists for this date. A new booking cannot be created.',
                          });
                        }
                      }); //else inside function owner
                    } else {
                      return reject({
                        status: false,
                        message: 'An existing booking already exists for this date. A new booking cannot be created.',
                      });
                    }
                  });
                }
              } else {
                return reject({
                  status: false,
                  message: 'A booking cannot be created for a previous day',
                });
              }
            }
  
            //special Day
          } else {
            return reject({
              status: false,
              message: 'Boat Selected is not Active',
            });
          }
        });
      });
    });
  };
  
  //StandbyBooking Adding
  
//StandbyBooking Adding


//check if it is summer or winter 


const checkIfIncludedInSeason = (boatId,Owner_Id,seasonStartDate,seasonEndDate,incomingStartDate,incomingEndDate)=>{
    return new Promise(async(resolve,reject)=>{

       

        let ownerDuration = await Duration.findOne({Boat_Id:boatId,Owner_Id}).catch((error)=> {
            console.log(error)
            return reject({status:false,error:"Something went wrong try again.",stop:true})
        });

        if(!ownerDuration || !ownerDuration.Duration_SDate || !ownerDuration.Duration_EDate ){
            return reject({status:false,error:"Set ownership duration before making any booking.",stop:true})
        }


        let ownerDurationStartYear = moment(ownerDuration.From_Date).format('YYYY');
        let ownerDurationEndYear =   moment(ownerDuration.To_Date).format('YYYY');


        let durationEndInMilliSeconds = new Date(ownerDuration.To_Date).getTime();



              //list all summer start and end date of  owner  based on owner duration  duration which include all year

              let allSeasonStartAndEndDates = []

              let seasonStartMonthAndDate = moment(seasonStartDate).format('MM/DD')
              let seasonEndMonthAndDate = moment(seasonEndDate).format('MM/DD')
                                  
              console.log(ownerDurationStartYear,ownerDurationEndYear)
            
            let differnceBetweenOwnerDurationStartYearAndBoatSeasonStartYear = ownerDurationStartYear - parseInt(moment(seasonStartDate).format('YYYY'));
            let seasonStartYear =  parseInt(moment(seasonStartDate).format('YYYY')) + differnceBetweenOwnerDurationStartYearAndBoatSeasonStartYear;
            let seasonEndYear = parseInt( moment(seasonEndDate).format('YYYY')) + differnceBetweenOwnerDurationStartYearAndBoatSeasonStartYear;

        console.log(seasonStartYear,seasonEndYear)

              while(parseInt(ownerDurationStartYear) <= parseInt(ownerDurationEndYear)){
                                         
                

             ownerDurationStartYear++;
            

               //start year 
               // end year

                                          
               let startDate = `${seasonStartMonthAndDate}/${seasonStartYear}`
               let endDate = `${seasonEndMonthAndDate}/${seasonEndYear}`

              

              let seasonEndDateInMilliSeconds = new Date(endDate).getTime()

               if(seasonEndDateInMilliSeconds > durationEndInMilliSeconds){

                    let differenceBetweenSeasonEndAndDurationEnd = seasonEndDateInMilliSeconds - durationEndInMilliSeconds
                    endDate = moment(new Date(seasonEndDateInMilliSeconds - differenceBetweenSeasonEndAndDurationEnd)).format('MM/DD/YYYY')     

               }


               let startAndEndDate = [startDate,endDate]
               allSeasonStartAndEndDates.push(startAndEndDate)
                
                 seasonStartYear++;
                 seasonEndYear++;
                                      
            }
            

            console.log(allSeasonStartAndEndDates,"allSeasonStartAndEndDates")

            
            

            //get all summer dates betweeen owner duration start to end

           let allAvailbleSSeasonDates = [];

            for(const startAndEndDate of allSeasonStartAndEndDates){


                let startDate = startAndEndDate[0]
                let endDate = startAndEndDate[1]

                let allDatesBetweenStartAndDate = getDaysBetweenDates(startDate,endDate);

                allAvailbleSSeasonDates = allAvailbleSSeasonDates.concat(allDatesBetweenStartAndDate)
             
            }


            let scheduleStartDateFormatted = moment(incomingStartDate).format('MM/DD/YYYY');
            let scheduleEndDateFormatted = moment(incomingEndDate).format('MM/DD/YYYY');

            console.log(scheduleStartDateFormatted)
            console.log(scheduleEndDateFormatted)
            let scheduleStartDateAvailable = false
            let scheduleEndDateAvailable = false

            //loop through all availble winter dates and match if user requeted start and end date inclueded in this

            for (const date of allAvailbleSSeasonDates) {
                
                if(date === scheduleStartDateFormatted) scheduleStartDateAvailable = true
                if(date === scheduleEndDateFormatted) scheduleEndDateAvailable = true

                if(scheduleStartDateAvailable && scheduleEndDateAvailable) break;
            }                   


            if(scheduleStartDateAvailable && scheduleEndDateAvailable){
                return resolve({status:true,message:`included in this season.`})
            }else{
               return resolve({status:false,error:'Not included in the season.',stop:false})
            }
    })

}


const getBookingTypeofAbooking = (startDate,endDate,prelaunchStartDate,preLaunchEndDate,summerStartDate,summerEndDate,winterStartDate,winterEndDate) =>{
console.log("RagaCheck");
    let bookingType 

    let allBookedDays = getDaysBetweenDates(startDate,endDate);
    let allDaysBetweenPrelaunchStartAndEnd = getDaysBetweenDates(prelaunchStartDate,preLaunchEndDate);
    let allDaysBetweenSummerStartAndEnd = getDaysBetweenDates(summerStartDate,summerEndDate);
    let allDaysBetweenWinterStartAndEnd = getDaysBetweenDates(winterStartDate,winterEndDate);

    //check if this booking is between launch and prelaunch
    
    if(allBookedDays.filter((bookedDay) => allDaysBetweenPrelaunchStartAndEnd.includes(bookedDay)).length){
        bookingType = "prelaunch and launch booking"
    }else if(allBookedDays.filter((bookedDay) => allDaysBetweenSummerStartAndEnd.includes(bookedDay)).length){
        bookingType = "Summer booking"
    }else if(allBookedDays.filter((bookedDay) => allDaysBetweenWinterStartAndEnd.includes(bookedDay)).length){
        bookingType = "Winter booking"
    }

    return bookingType;


}


const AddCleans=async(Boat_id,Owner_id,Noofcleans,User_role)=>
{
    
         
    let CleanDays = await  No_OfCleans.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id }).catch((error)=> console.log(error));
   // No_OfCleans.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
       // {

                 
        if(!CleanDays)
        {

                  
             let AddCleaningDays= new No_OfCleans({                  
            
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                Cleans:Noofcleans,
                User_RoleType:User_role,
                IsActive:true,
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
    
            });
             
            AddCleaningDays.save()
                .then(response => {
                    return true;
                })
                .catch(error => {
                    console.log(error)
                    return  false;
                })
            
        }

        else
        {
            console.log('updation3')
            No_OfCleans.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id}).then(result=>
                {
                    console.log(result)
                    var Clean_day=result.Cleans;
                 
            

            No_OfCleans.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id},
            { 
                
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                Cleans:Noofcleans+Clean_day,
                User_RoleType:User_role,
                IsActive:true,
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
            },
              
                function(err, data) {
                if(err){
                  
                    return false
                  
                }
                else{
                  
                    return true
                    
                }

            });
        })
    }
}
const TotalCancellations=async(Boat_id,Owner_id,Noofcancellation,Cancellationyear)=>
{
    
         
    let No_Cancellation = await  TotalNoCancellations.findOne({ Boat_Id: Boat_id, Owner_Id: Owner_id,Cancellationyear:Cancellationyear }).catch((error)=> console.log(error));

                 
        if(!No_Cancellation)
        {

            
             let AddCancellation= new TotalNoCancellations({                  
            
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                No_Cancellation:Noofcancellation,
                Cancellationyear:Cancellationyear,
                IsActive:true,
              
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
    
            });
             
            AddCancellation.save()
                .then(response => {
                    return true;
                })
                .catch(error => {
                    console.log(error)
                    return  false;
                })
            
        }

        else
        {
            console.log('updation2')
            TotalNoCancellations.findOne({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear}).then(result=>
                {
                    console.log(result)
                    var No_Cancellation=result.No_Cancellation;
                   

                    TotalNoCancellations.findOneAndUpdate({Boat_Id:Boat_id,Owner_Id:Owner_id,Cancellationyear:Cancellationyear},
            { 
                
                Boat_Id:Boat_id,
                Owner_Id:Owner_id,
                No_Cancellation:Noofcancellation+No_Cancellation,
                Cancellationyear:Cancellationyear,
                IsActive:true,
              
                Current_Time:moment(Date.now()),
                Updated_time: moment(Date.now())
            },
              
                function(err, data) {
                if(err){
                  
                    return false
                  
                }
                else{
                  
                    return true
                    
                }

            });
        })
    }
}


const GetAllMaintenanceSchedule = (req,res)=>{

    return new Promise(async(resolve,reject)=>{

       let maintenanceData = await Schedule.aggregate([
           {$match:{IsActive:true,User_RoleType:"Maintenance"}},

           {$project:{
            start:1,end:1,commends:1,location:1,Boat_Name:1
           }}

       ]).catch((error)=>{
           console.log(error);
           return reject({status:true,message:"Something went wrong try again."})
       })

       return resolve({status:true,response:maintenanceData});

    }).then((response)=>{
        return res.json(response)
    }).catch((error)=>{
        return res.json(error)
    })

}



const GetAllCleaningScheduleReport = (req,res)=>{

    return new Promise(async(resolve,reject)=>{

       let cleaningData = await Boats.aggregate([
           {$match:{IsActive:true}},

           {
               $lookup:{
                   from:"tb_schedules",
                   localField:"_id",
                   foreignField:"Boat_Id",
                   as:"schedules"
               }
           },
     
           {"$unwind": {"path":"$schedules", "preserveNullAndEmptyArrays": true } },

           {
               $lookup:{
                   from:"tb_addowners",
                   localField:"schedules.User_Id",
                   foreignField:"_id",
                   as:"schedules.owner"
               }
           },

           {$project:{
            "Boat_Name":1,
            "Location_Name":1,

               schedules:{
                start:1,
                end:1,
                commends:1,
                _id:1,
                User_Id:1,
                User_RoleType:1,
                
            },
            "schedules.owner.First_Name": 1,
            "schedules.owner.Last_Name": 1,
            "schedules.owner.Housekeeping": 1,
            
           
           }}

       ]).catch((error)=>{
           console.log(error);
           return reject({status:true,message:"Something went wrong try again."})
       })

    

    function removeDuplicates(originalArray, prop) {
     var newArray = [];
     var lookupObject  = {};

     for(var i in originalArray) {
        lookupObject[originalArray[i][prop]] = originalArray[i];
     }

     for(i in lookupObject) {
         newArray.push(lookupObject[i]);
     }
      return newArray;
 }


let uniqueArrays = removeDuplicates(cleaningData, "_id");

 let sameBoatBookings = [];

for(const  uniqueArray of uniqueArrays){

    let boatId = uniqueArray._id.toString()

    let sameBoatFound = cleaningData.filter(obj => {
  return obj._id == boatId
})

    

     let schedules = [];

    sameBoatFound.map((boat,i)=>{
        
     schedules.push(boat.schedules)

     if(i+1 === sameBoatFound.length){
         sameBoatBookings.push({
             _id:boat._id,
             Location_Name:boat.Location_Name,
             Boat_Name:boat.Boat_Name,
             schedules
         })
     }
        
       
    })



}

       //sort date by end date

       let sortedCleaningData = []

       let i = 0;

       
       
       for(const boat of sameBoatBookings){

        boat.schedules.sort(function(a,b){
            return new Date(b.end) - new Date(a.end);
          }).reverse()


         


            const dividingArrayLength = 2;
             let scheduleCopy = [...boat.schedules];

            const dividedSchedules = new Array(Math.ceil(scheduleCopy.length / dividingArrayLength)).fill().map((_) => scheduleCopy.splice(0, dividingArrayLength));
            

            for(const dividedSchedule of dividedSchedules){

        

                                let scheduleOneOwner = dividedSchedule[0].owner.length ? dividedSchedule[0].owner[0] : false ;
                                let scheduleTwoOwner;
                                if(dividedSchedule.length > 1){
                                    scheduleTwoOwner = dividedSchedule[1].owner.length ? dividedSchedule[1].owner[0] : false ;
                                }

             

                       let data = {
                    _id:boat._id,
                    Boat_Name:boat.Boat_Name,
                    Location_Name:boat.Location_Name,
                    ReturningOwner: `${scheduleOneOwner ?  `${scheduleOneOwner.First_Name} ${scheduleOneOwner.Last_Name}` : 'Not available' } `   ,
                    HouseKeepingLevel: `${scheduleOneOwner ? `${scheduleOneOwner.Housekeeping}` : 'Not available'}`,
                    ReturningDate: `${scheduleOneOwner ? `${dividedSchedule[0].end}` : 'Not available'}`,
                    DepartingOwner:`${scheduleTwoOwner ? `${scheduleTwoOwner.First_Name} ${scheduleTwoOwner.Last_Name}` : 'Not available.'}`,
                    DepartureaDate:`${scheduleTwoOwner ?  `${dividedSchedule[1].start}` : 'Not available.'}`,
                    BookingNote:`${scheduleTwoOwner ?  `${dividedSchedule[1].commends}` : 'Not available.'}`

                       }



                       

                
                        sortedCleaningData.push(data)

                }
             
            }
            
        

      
           return resolve({status:true,response:sortedCleaningData});
       

     

    }).then((response)=>{
        return res.json(response)
    }).catch((error)=>{
        return res.json(error)
    })

}


const getWeekDayAndWeekEndsOfCancellationByAllowedCancellationOfAnOwner = (cancellationStartDate,canceallionEndDate,NumberOfAllowedCancealltion)=>{


//get days and weeks 
let obj = Object();
obj.start =new Date(cancellationStartDate);
obj.end = new Date(canceallionEndDate);


let datas =  getDaysInMonth_Sheduler(obj);
let arr=[];
             
     datas.forEach(function(item) {
                Object.keys(item).forEach(function(key) {   
                    arr.push(item[key]);
                  console.log( item[key]);
                });
              });

            

    let reAssignedWeekendCount = 0;
    let reAssignedWeekDaysCount = 0;
    let allowedOwnerCancellationCount = NumberOfAllowedCancealltion;
    let i = arr.length - 1;


    while(allowedOwnerCancellationCount>0){

        let day = arr[i];

        if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){

            reAssignedWeekDaysCount++; 
        }else{
             reAssignedWeekendCount++;
        }

        allowedOwnerCancellationCount--;
        i--;
}


return {reAssignedWeekDaysCount,reAssignedWeekendCount}
    
}



let getAllCanceledDates = (originalStartDate,originalEndDate,editStartDate,editEndDate)=>{  

    let getDaysBetweenDates = (startDate, endDate) =>{
        let now = moment(startDate).clone(), dates = [];
    
        while (now.isSameOrBefore(moment(endDate))) {
            dates.push(now.format('DD/MM/YYYY'));
            now.add(1, 'days');
        }
        return dates;
    };
    
    

    let allOriginallyBookedDays = getDaysBetweenDates(originalStartDate,originalEndDate);
    let allBookedDaysByEditing = getDaysBetweenDates(editStartDate,editEndDate)

    let allCanceledDates  = allOriginallyBookedDays.filter((originallyBookedDay)=> !allBookedDaysByEditing.includes(originallyBookedDay))

    return allCanceledDates;


  

}

// to check if next booking days last day is included in this in incoming booking 

const checkIfNextBookingDayIsIncluded = (incomingStartDate,incomingEndDate,boatId,timeZone,summer = true,ownerId,isEdit = false)=>{

    return new Promise(async(resolve,reject)=>{

    
      

        console.log("called checkIfNextBookingDayIsIncluded");

        incomingStartDate = new Date(incomingStartDate);
        incomingEndDate = new Date(incomingEndDate);

        console.log("clientCurrentBeforeExecution")

        if(!timeZone) timeZone = process.env.TIME_ZONE;

        let clientCurrentTime = new Date();


          console.log(clientCurrentTime,"clientCurrentTime")
        
        let boat = await Boats.findById(boatId).catch((error)=>{
            console.log(error);
            return reject({status:true,message:"Something went wrong. Try again"});
        });
        
        if(!boat) return reject({status:false,message:"inavlid boat id."})

        let tzOffsetOfTimeZone = tzOffset.offsetOf(timeZone);


        //get next booking day from db
 
       let nextBookingDay = await nextBookinDayModel.findOne({Boat_Id:boatId,IsActive:true}).catch((error)=>{
        console.log(error);
        return reject({status:true,message:"Something went wrong. Try again"});
       })
        
       if(!nextBookingDay) return reject({status:true,message:'Set next booking day before you make a booking.'});

        let nextBookingDayDate;
        let boatLaunchDate = new Date(boat.Launch_Date);
        let nextBookingDaysCount = nextBookingDay.Next_BookingDay;

        console.log(nextBookingDaysCount,"nextBookingDaysCount")

        if(boatLaunchDate.getTime() > new Date().getTime()){
            console.log("inside before launch next booking day")
            nextBookingDay = boatLaunchDate.setDate(boatLaunchDate.getDate() + nextBookingDaysCount);
            console.log(nextBookingDay,"nextBookingDay")
        }else{
            console.log("inside after launch next booking day")
            let dayNow = new Date()     
            nextBookingDay = new Date(dayNow.setDate(dayNow.getDate() + nextBookingDaysCount))
            console.log(nextBookingDay,"nextBookingDay")
        }
        
        console.log(nextBookingDay, new Date(nextBookingDay),"next booking day date")

        
        //check incoming owner has a booking on the incoming days to avoid duplicate booking
        if(!isEdit){

            
       let allDaysBetweenStartAndEnd = getDaysBetweenDates(incomingStartDate,incomingEndDate)

       let queryToCheckDuplicateBooking = []  
       
       allDaysBetweenStartAndEnd.map((date)=> queryToCheckDuplicateBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))

       console.log(queryToCheckDuplicateBooking[0].$and,"queryToCheckDuplicateBooking")

     let isPendingNextBookingExist = await Schedule.findOne({Boat_Id:boatId,User_Id:ownerId,isBookingPending:true,isBookingCancelled:false,IsActive:true,$or:queryToCheckDuplicateBooking}).catch((error)=>{
             console.log(error);
          return reject({status:true,message:"Something went wrong. Try again."});
   })

   if(isPendingNextBookingExist) return reject({status:true,message:'You are trying to make a duplicate booking.'})

        }

    //check incoming owner has a booking on the incoming days to avoid duplicate booking end
           
       let isNextDayBookingIncluded = false

        if(new Date(incomingStartDate).setUTCHours(00,00,00,00) <= new Date(nextBookingDay).setUTCHours(00,00,00,00) && new Date(incomingEndDate).setUTCHours(00,00,00,00) >= new Date(nextBookingDay).setUTCHours(00,00,00,00)){

            isNextDayBookingIncluded = true 

    }

        //check if a pending booking

        if(new Date(new Date(incomingStartDate).setUTCHours(00,00,00,00)).getTime() ===  new Date(new Date(nextBookingDay).setUTCHours(00,00,00,00)).getTime() ){
           
            

            //check if booking is before 11:55
            
           
            console.log(tzOffsetOfTimeZone,"TZ")

            let craetedTime =  isNegative(tzOffsetOfTimeZone) ? new Date(clientCurrentTime).setUTCHours(23,55,00,00) - Math.abs(tzOffsetOfTimeZone * 60000 ) : new Date(clientCurrentTime).setUTCHours(23,55,00,00) + Math.abs(tzOffsetOfTimeZone * 60000 )
           

            if(clientCurrentTime.getTime() >= craetedTime){
                return reject({status:true,message:"You can't make a booking after 11:55 PM "})
            } 
            
            console.log({status:true,included:true,isNextDayBookingIncluded,message:"Next booking day is included in this booking."})
            resolve({status:true,included:true,isNextDayBookingIncluded,message:"Next booking day is included in this booking."})

            //

            //send pending mail

            let owner = await NewOwners.findOne({_id:ownerId,IsActive:true},{Email:1,First_Name:1}).catch((error)=> console.log(error))
            let boatDetails = await Boats.findOne({_id:boatId,IsActive:true},{Boat_Name:1}).catch((error)=> console.log(error))

            const emailState =  'Pending Booking.';
            const emailContent = `Dear ${owner.First_Name} Your booking bid on, ${boatDetails.Boat_Name} has been recieved.
            You will be notifed tomorrow with the outcome of the automatic decision.
            
            Please login the the system to see this booking bid: (link to the system booking)
            ${process.env.CLIENT_URL}/boat-bookings`;
            const emailDetailName = 'Booking Details'
            const emailDetails = [
              { key: 'Boat Name', value:  boatDetails.Boat_Name},
              { key: 'Booking Date', value: getCurrentTimeFormatted() },
            ];
            const emailNameAndLink = {
              name:'Booking Link',
              link:`${process.env.CLIENT_URL}/boat-bookings`
            }
           
            let  ownerPendingMailOptions = { 
            from:"noreply.smartboatbooking@gmail.com",
            to: owner.Email,
             subject: 'Pending Booking',
            html:  getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
        };
        
            transporter.sendMail(ownerPendingMailOptions, (error)=> {
                if (error){
                    console.log(error);
                }else{
                    console.log("ownerPendingMail send successfully")
                }
             });   


             //admin mail 

             let emailContentPendingBookingAdmin = `Dear Administrator,

             An booking bid on ${boatDetails.Boat_Name} for ${owner.First_Name}  has been made for ${getCurrentTimeFormatted()}. It is awaiting confirmation until this evening. 
             
             Please login the the system to see this booking bid: (link to the system booking)
             ${process.env.CLIENT_URL}/boat-bookings.`

           
            let  adminPendingMailOptions = { 
                from:"noreply.smartboatbooking@gmail.com",
                to: "admin@smartboating.com.au", 
                subject: 'Pending Booking', 
                html: getEmailTemplate(emailState,emailContentPendingBookingAdmin,emailDetailName,emailDetails,emailNameAndLink)
             };
        
            transporter.sendMail(adminPendingMailOptions, (error)=> {
                if (error){
                    console.log(error);
                }else{
                    console.log("ownerPendingMail send successfully")
                }
             });   


             //send pending mail end


            const executeDate = new Date(new Date(clientCurrentTime).setUTCHours(17,40,00,00));

            console.log(new Date(),"Time Now")
            
            let cronExecutionTime = isNegative(tzOffsetOfTimeZone) ? new Date(executeDate -  Math.abs(tzOffsetOfTimeZone * 60000 )) : new Date(executeDate + Math.abs(tzOffsetOfTimeZone * 60000 ))
            
            console.log(cronExecutionTime,"cron execution time")

            //check if already a cron is scheduled or not if scheduled do not schedule anothe one , if not add new cron schedule to DB


            const isCronExist = await cronModel.findOne({boatId,cronExecutionTime}).catch((error)=>{
                console.log(error)
            })

            if(isCronExist){
                console.log('cron already exist')
                return resolve({status:true})
            }


            console.log('cron do not exist')

           await new cronModel({boatId,cronExecutionTime}).save().catch((error)=>{
               console.log(error)
           })

            //cron 
          
            schedule.scheduleJob(cronExecutionTime,async()=>{
          
                //check if already a booking is accepted if it is accepted cancel all pendiing booking

                console.log("inside next boking cron")

                console.log({Boat_Id:boatId,IsActive:true,isBookingPending:false,isBookingCancelled:false,start:{$lte:new Date(nextBookingDay)},end:{$gte:new Date(nextBookingDay)}})

             let acceptedBooking = await Schedule.findOne({Boat_Id:boatId,IsActive:true,isBookingPending:false,isBookingCancelled:false,start:{$lte:new Date(nextBookingDay)},end:{$gte:new Date(nextBookingDay)}}).catch((error)=>{
                console.log(error);
                return reject({status:true,message:"Something went wrong. Try again."});
            })

           

             if(acceptedBooking){

                console.log("accepted booking is found");

               // before cancelling give back all pending days of that owner based on his booking

               const allNextDayPendingBooking = await Schedule.find({Boat_Id:boatId,isBookingPending:true,isBookingCancelled:false,IsActive:true}).catch((error)=>{
                console.log(error);
                return reject({status:true,message:"Something went wrong. Try again."});
            })


            //give back all pending days
             if(allNextDayPendingBooking && allNextDayPendingBooking.length){
                allNextDayPendingBooking.map((nextDayPendingBooking)=>{


            let allDatesBetweenBookingStartAndEndDate = getDaysBetweenDates(nextDayPendingBooking.start,nextDayPendingBooking.end);

            let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(allDatesBetweenBookingStartAndEndDate) || {}

                //find and update this owner owner booking days 

                    if(summer){
                        OwnerBooking_Days.findOneAndUpdate({Owner_Id:nextDayPendingBooking.User_Id,Boat_Id:nextDayPendingBooking.Boat_Id,IsActive:true},{
                                        $inc:{Summer_WeekDays: -numberOfWeekDays,Summer_WeekEndDays: -numberOfWeekEnds}
                        }).catch((error)=>{
                            console.log(error)
                        })
                    }else{
                        OwnerBooking_Days.findOneAndUpdate({Owner_Id:nextDayPendingBooking.User_Id,Boat_Id:nextDayPendingBooking.Boat_Id,IsActive:true},{
                            $inc:{Winter_WeekDays: -numberOfWeekDays,Winter_WeekEndDays: -numberOfWeekEnds}
                        }).catch((error)=>{
                            console.log(error)
                        })
                    }
             
                    

                })
             }



                //update all canceled booking

               await Schedule.updateMany({Boat_Id:boatId,isBookingPending:true,isBookingCancelled:false},{
                        isBookingCancelled:true,
                        isBookingPending:false
                 },{new:true}).catch((error)=>{
                console.log(error);
                return reject({status:true,message:"Something went wrong. Try again."});
            })
            

          
            return resolve({status:true})
            }

            //


              let allBookingNextDayBookings = await Schedule.find({Boat_Id:boatId,isBookingPending:true,isBookingCancelled:false,IsActive:true}).catch((error)=>{
                console.log(error);
                return reject({status:true,message:"Something went wrong. Try again."});
            })
            
            console.log(allBookingNextDayBookings.length,"ok");

            let ownerSeasonQuery =  allBookingNextDayBookings.map((allBookingNextDayBooking)=> allBookingNextDayBooking.User_Id)

            console.log(ownerSeasonQuery,"ownerSeasonQuery")

            let ownersPendingDays = await manageBoat.find({Boat_Id:boatId,IsActive:true,Owner_Id:{$in:ownerSeasonQuery}}).catch((error)=>{
                console.log(error)
            })

            let ownerUsedDays = await OwnerBooking_Days.find({Boat_Id:boatId,IsActive:true,Owner_Id:{$in:ownerSeasonQuery}}).catch((error)=>{
                console.log(error)
            })

            
            
            ownersPendingDays.map((pendingDay)=>{

                ownerUsedDays.map((usedDay)=>{

                    if(pendingDay.Owner_Id.toString() == usedDay.Owner_Id.toString()){


                        pendingDay.Summer_WeekDays -= usedDay.Summer_WeekDays
                        pendingDay.Summer_WeekEndDays -= usedDay.Summer_WeekEndDays
                        pendingDay.Winter_WeekDays -= usedDay.Winter_WeekDays
                        pendingDay.Winter_WeekEndDays -= usedDay.Winter_WeekEndDays
                 
                    }

                })
            })

            

            let allOwnersTotalPendingDays = []

            if(summer){
                ownersPendingDays.map((owner)=> allOwnersTotalPendingDays.push({ownerId:owner.Owner_Id,toatalPendingDaysAvailable: owner.Summer_WeekDays + owner.Summer_WeekEndDays}))
            }else{
                ownersPendingDays.map((owner)=> allOwnersTotalPendingDays.push({ownerId:owner.Owner_Id,toatalPendingDaysAvailable: owner.Winter_WeekDays + owner.Winter_WeekEndDays}))
            }
            console.log(allOwnersTotalPendingDays,"allOwnersTotalPendingDays")

            let ownerWhoHaveMoreDays =  allOwnersTotalPendingDays.reduce((a, e) => {
                a[e.toatalPendingDaysAvailable] = ++a[e.toatalPendingDaysAvailable] || 0;
                return a;
                }, {});

            ownerWhoHaveMoreDays = allOwnersTotalPendingDays.filter(owner => ownerWhoHaveMoreDays[owner.toatalPendingDaysAvailable])
            
            if(ownerWhoHaveMoreDays.length){
                ownerWhoHaveMoreDays = ownerWhoHaveMoreDays[Math.floor(Math.random() * ownerWhoHaveMoreDays.length)]
            }else{
                ownerWhoHaveMoreDays = allOwnersTotalPendingDays.reduce((prev, current) => (prev.toatalPendingDaysAvailable > current.toatalPendingDaysAvailable) ? prev : current)
            }
            
            
            console.log(ownerWhoHaveMoreDays,"Accepted owner")


           

          

            let allocateBooking = await Schedule.findOneAndUpdate({Boat_Id:boatId,isBookingPending:true,User_Id:ownerWhoHaveMoreDays.ownerId,IsActive:true},{
                isBookingPending:false,
                isBookingAccepted:true
            }).catch((error)=>{
                console.log(error)
                 return reject({status:true,message:"Something went wrong. Try again."});
            })


            //send approved mail 

            if(ownerWhoHaveMoreDays){
                
                //owner mail

                let owner = await NewOwners.findOne({_id:ownerWhoHaveMoreDays.ownerId,IsActive:true},{Email:1,First_Name:1}).catch((error)=> console.log(error))
               
            const emailState =  'Booking Approved.';
            const emailContent = `Dear ${owner.First_Name},

            Your booking bid on, ${boatDetails.Boat_Name} has been approved. The booking is confirmed for ${getCurrentTimeFormatted()}.
            
            Please login the the system to see this booking: (link to the system booking)
            ${process.env.CLIENT_URL}/boat-bookings`;
            const emailDetailName = 'Booking Details'
            const emailDetails = [
              { key: 'Boat Name', value:  boatDetails.Boat_Name},
              { key: 'Booking Date', value: getCurrentTimeFormatted() },
            ];
            const emailNameAndLink = {
              name:'Booking Link',
              link:`${process.env.CLIENT_URL}/boat-bookings`
            }

       
            let  ownerApprovedMailOptions = { 
                from:"noreply.smartboatbooking@gmail.com",
                to: owner.Email,
                 subject: 'Booking Approved',
                 html: getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
            };
        
            transporter.sendMail(ownerApprovedMailOptions, (error)=> {
                if (error){
                    console.log(error);
                }else{
                    console.log("ownerApprovedMail send successfully")
                }
             });   


             //admin approved mail 

            

             let emailContentApprovedBookingAdmin =  `Dear Administrator,

             An booking bid on ${boatDetails.Boat_Name} for ${owner.First_Name} has been approved for ${getCurrentTimeFormatted()}. 
             
             Please login the the system to see this booking: (link to the system booking)
             ${process.env.CLIENT_URL}/boat-bookings`;

             
            let  adminApprovedMailOptions = {
                 from:"noreply.smartboatbooking@gmail.com",
                 to: "admin@smartboating.com.au",
                  subject: 'Booking Approved',
                   html: getEmailTemplate(emailState,emailContentApprovedBookingAdmin,emailDetailName,emailDetails,emailNameAndLink)
                 };
        
            transporter.sendMail(adminApprovedMailOptions, (error)=> {
                if (error){
                    console.log(error);
                }else{
                    console.log("adminApprovedMail send successfully")
                }
             });   


            }


            let cenceledOwners = allOwnersTotalPendingDays.filter((owner)=> owner.ownerId !== ownerWhoHaveMoreDays.ownerId);
            let canceledOwnerQuery = cenceledOwners.map((owner)=> owner.ownerId)

            //give back all days to canceled owner

            let canceledOwnerBookings = await Schedule.find({Boat_Id:boatId,isBookingPending:true,User_Id:{$in:canceledOwnerQuery},IsActive:true}).catch((error)=>{
                console.log(error)
            })


            if(canceledOwnerBookings && canceledOwnerBookings.length){
                canceledOwnerBookings.map((nextDayPendingBooking)=>{

                      //give back all pending days

            let allDatesBetweenBookingStartAndEndDate = getDaysBetweenDates(nextDayPendingBooking.start,nextDayPendingBooking.end);

            let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(allDatesBetweenBookingStartAndEndDate) || {}

                //find and update this owner owner booking days 

                    if(summer){
                        OwnerBooking_Days.findOneAndUpdate({Owner_Id:nextDayPendingBooking.User_Id,Boat_Id:nextDayPendingBooking.Boat_Id,IsActive:true},{
                                        $inc:{Summer_WeekDays: -numberOfWeekDays,Summer_WeekEndDays: -numberOfWeekEnds}
                        }).catch((error)=>{
                            console.log(error)
                        })
                    }else{
                        OwnerBooking_Days.findOneAndUpdate({Owner_Id:nextDayPendingBooking.User_Id,Boat_Id:nextDayPendingBooking.Boat_Id,IsActive:true},{
                            $inc:{Winter_WeekDays: -numberOfWeekDays,Winter_WeekEndDays: -numberOfWeekEnds}
                        }).catch((error)=>{
                            console.log(error)
                        })
                    }
             
                    

                })
             }


             //   give back all days  to canceled owner


             //get all cancaled owners and mail them booking is disapproved

             let allCanceledOwners =  await NewOwners.find({_id:{$in:canceledOwnerQuery},IsActive:true},{Email:1,First_Name:1}).catch((error)=> console.log(error))


             allCanceledOwners.map((owner)=>{

               //owner disapproved emai

               const emailState =  'Booking Disapproved.';
               const emailContent =  `Dear ${owner.First_Name},

               Your booking bid on, ${boatDetails.Boat_Name} has been not gone ahead at this time`;
               const emailDetailName = 'Booking Details'
               const emailDetails = [
                 { key: 'Boat Name', value:  boatDetails.Boat_Name},
                 { key: 'Booking Date', value: getCurrentTimeFormatted() },
               ];
               const emailNameAndLink = {
                 name:'Booking Link',
                 link:`${process.env.CLIENT_URL}/boat-bookings`
               }
   

                let  ownerDisapprovedMailOptions = { 
                from:"noreply.smartboatbooking@gmail.com",
                to: owner.Email, 
                subject: 'Booking Disapproved',
                html: getEmailTemplate(emailState,emailContent,emailDetailName,emailDetails,emailNameAndLink)
                };
            
                transporter.sendMail(ownerDisapprovedMailOptions, (error)=> {
                    if (error){
                        console.log(error);
                    }else{
                        console.log("ownerApprovedMail send successfully")
                    }
                 });   
    

                 //owner disapproved admin email

              

                 let emailContentDisapprovedBookingAdmin =  `Dear Administrator,

                 An booking bid on ${boatDetails.Boat_Name} for ${owner.First_Name} has been disapproved for ${getCurrentTimeFormatted}. 
                 
                 Please login the the system to see this booking: (link to the system booking)
                ${process.env.CLIENT_URL}/boat-bookings`;
    
                let  adminDispprovedMailOptions = {
                     from:"noreply.smartboatbooking@gmail.com",
                     to: "admin@smartboating.com.au", 
                     subject: 'Booking Disapproved',
                     html: getEmailTemplate(emailState,emailContentDisapprovedBookingAdmin,emailDetailName,emailDetails,emailNameAndLink)
                      };
            
                transporter.sendMail(adminDispprovedMailOptions, (error)=> {
                    if (error){
                        console.log(error);
                    }else{
                        console.log("admindDisapprovedMail send successfully")
                    }
                 });   
                 

             })

             //


            console.log(cenceledOwners,"Canceled owners")

            console.log(canceledOwnerQuery,"canceledOwnerQuery")

            let cancelOtherBookings = await Schedule.updateMany({Boat_Id:boatId,isBookingPending:true,User_Id:{$in:canceledOwnerQuery}},{
                isBookingPending:false,
                isBookingCancelled:true,
                IsActive:false
            })

            })

            //cron end

        }else{
            console.log({status:true,included:false,isNextDayBookingIncluded,message:"Next booking day is not included in this booking."})
         return resolve({status:true,included:false,isNextDayBookingIncluded,message:"Next booking day is not included in this booking."})
        }

    })

}


const isNegative = (num)=>{

    if(num < 0){
        return true
    }else{
        return false
    }
}

// DoApproveCancellation

const DoApproveCancellation = (scheduleid, Loa, PartialStatus,TotalLoa_Edit,WeekDay_Count_Edit,WeekEnd_Count_Edit,Newstartdate,Newenddate) => {

   

    Schedule.findById({_id:mongoose.Types.ObjectId(scheduleid)}).then(response=>
        { 
            

            var Boat_id=response.Boat_Id;
            var Owner_id=response.User_Id;
            var start_Date=response.start;
            var Start_final=moment(start_Date);
            console.log(start_Date)
            console.log(Start_final)
            var Start_final_withoutTime=Start_final.startOf('day');
            var end_Date=response.end;
            var End_final=moment(end_Date);
            var End_final_withoutTime=End_final.startOf('day');
            console.log(Start_final_withoutTime)
            console.log(End_final_withoutTime)
            var RoleAssigned=response.User_RoleType;
            var Cancel_date=moment();
            console.log(Cancel_date)
            var dif=moment.duration(Start_final.diff(Cancel_date));
            console.log(dif.asHours());
            var Hrdif=Math.round(dif.asHours());
        var Totalday_prev=response.Total_DaysBooked_Reassign;
        var Weekdays_prev=response.WeekDay_Count_Reassign;
        var WeekEndDays_prev=response.WeekEnd_Count_Reassign;
        console.log(Weekdays_prev,'hiiiii')
        console.log(WeekEndDays_prev,'hiiiii')
if(PartialStatus==1)
    {
        var  WeekDay_Count=WeekDay_Count_Edit;
        var  WeekEnd_Count=WeekEnd_Count_Edit;      
        var Total_Count=0;
        Total_Count= WeekDay_Count+ WeekEnd_Count;       
     
       if(TotalLoa_Edit>=Total_Count)
       {
                     Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                         {  
                             var SummerWeekdays=response.Summer_WeekDays;
                             var SummerWeekendDays=response.Summer_WeekEndDays;
                             var  WinterWeekDays=response.Winter_WeekDays;
                             var WinterweekendDays=response.Winter_WeekEndDays;

               //  SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                 //is active is not here before
                             
                             Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                                 {
                                 //console.log(Boatresults)
                                    
                                 let stopExecution = {stop:false}
                                 let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                     console.log(error)
                                     stopExecution = error
                                 })
                     
                     
                                 if(stopExecution.stop){
                                     return 
                                 }
                     
                                 if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                                 {

                                 Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                           
                                 Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                                 Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                                 
                                 },
                                 {new: true},
                                 function(err, data) {
                                 
                                     console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                                 });
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x)
                               
                                   
                             }
                             else
                             {
         
     
                                 Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                                 {   
                                                                  
                                    Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                                    Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                     
                                 },
                                 {new: true},
                                 function(err, data) {                                     
                                     console.log('Winter sucesss')
                                 });
                            
                                 var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                                 console.log(x,'thisssss')
                                
                                 
                                        
                             }
                         })
                     })
     
                     let getcaceldates_only = getAllCanceledDates(response.start,response.end,Newstartdate,Newenddate);
         Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
         { 
           
             Updated_time: moment(Date.now()),
             BookingStatus:"PartiallyAccepted",
             PartialCancellation_Status:0,
             Approved_LOA:Total_Count,
          
         },
           
             function(err, data) {
             if(err){
               return
             }
             else{
            let ownerPartial = new OwnerPartialCancelation();
            ownerPartial.Scheduleid = scheduleid;
            ownerPartial.Owner_Id = response.User_Id;
            ownerPartial.Boat_Id = Boat_id;
            ownerPartial.Boat_Name=response.Boat_Name;
            ownerPartial.cancaledDays=getcaceldates_only;
            ownerPartial.Approved_LOA=Total_Count;
            ownerPartial.WeekDay_Count=response.WeekDay_Count;
            ownerPartial.WeekEnd_Count=response.WeekEnd_Count;
            ownerPartial.WeekDay_Count_Edit=response.WeekDay_Count_Edit;
            ownerPartial.WeekEnd_Count_Edit=response.WeekEnd_Count_Edit;
            ownerPartial.Booking_ID = response.Booking_ID;
            ownerPartial. BookingStatus="PartiallyAccepted";
            ownerPartial.PartialCancellation_Status=0;
            ownerPartial.Total_Edit_Loa = response.Total_Edit_Loa;
            ownerPartial.save(function(err,saved){

              if(err) return;

            });

             
             }
         }); 

        



        }
        else
        {
           return
        
        }
    }
    else
    {
           
   var  WeekDay_Count=WeekDay_Count_Edit;
   var  WeekEnd_Count=WeekEnd_Count_Edit;       
   var Total_Count=0;
   Total_Count= WeekDay_Count+ WeekEnd_Count;       

   if(Loa>=Total_Count)
       {
                Boats.findById({_id:mongoose.Types.ObjectId(Boat_id)}).then(response=>
                    {  
                        var SummerWeekdays=response.Summer_WeekDays;
                        var SummerWeekendDays=response.Summer_WeekEndDays;
                        var  WinterWeekDays=response.Winter_WeekDays;
                        var WinterweekendDays=response.Winter_WeekEndDays;

                        //SummerSeason_SDate:{$lte:Start_final_withoutTime},SummerSeason_EDate:{$gte:End_final_withoutTime}
                         //is active is not here before
                        
                        Boats.findOne({_id:Boat_id,IsActive:true}).then(async(Boatresults)=>
                            {
                            //console.log(Boatresults)
                               
                            let stopExecution = {stop:false}
                            let isAvailableDay =  await checkIfIncludedInSeason(Boat_id,Owner_id,Boatresults.SummerSeason_SDate,Boatresults.SummerSeason_EDate,start_Date,end_Date).catch((error)=>{
                                console.log(error)
                                stopExecution = error
                            })
    
    
                            if(stopExecution.stop){
                               return
                            }
    
                            if(isAvailableDay && isAvailableDay.status)//check Date Between Summer Dates
                            {

    
                          
                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                            {   
                                                      
                            Summer_WeekDays:SummerWeekdays-WeekDay_Count,
                            Summer_WeekEndDays:SummerWeekendDays-WeekEnd_Count
                            
                            },
                            {new: true},
                            function(err, data) {
                            
                                console.log('reassigneddddddddddddddddddddddddddddddddddddddddd')
                            });
                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                            console.log(x)
                          
                               

                        }
                        else
                        {


                            Boats.findByIdAndUpdate({_id:mongoose.Types.ObjectId(Boat_id)}, 
                            {   
                                                             
                               Winter_WeekDays:WinterWeekDays-WeekDay_Count,
                               Winter_WeekEndDays:WinterweekendDays-WeekEnd_Count
                                
                            },
                            {new: true},
                            function(err, data) {
                                
                                console.log('Winter sucesss')
                            });
                       
                            var x= AddBookingDays_Owner(Boat_id,Owner_id,start_Date,end_Date,Total_Count,WeekDay_Count,WeekEnd_Count)
                            console.log(x,'thisssss')
 

                        }
                    })
                })


    Schedule.findByIdAndUpdate({_id:mongoose.Types.ObjectId(scheduleid)}, 
    { 
      
        IsActive:false,
        Updated_time: moment(Date.now()),
        Approved_LOA:Loa,
        BookingStatus:"Accepted",

     
    },
      
        function(err, data) {
        if(err){
           return
        }
        else{

          let ownerPartial = new OwnerPartialCancelation();
          ownerPartial.Scheduleid = scheduleid;
          ownerPartial.Boat_Id = Boat_id;
          ownerPartial.Owner_Id = response.User_Id;
          ownerPartial.Boat_Name=response.Boat_Name;
          ownerPartial.cancaledDays=getcaceldates_only;
          ownerPartial.Approved_LOA=Loa;
          ownerPartial.WeekDay_Count=response.WeekDay_Count;
          ownerPartial.WeekEnd_Count=response.WeekEnd_Count;
          ownerPartial.WeekDay_Count_Edit=response.WeekDay_Count_Edit;
          ownerPartial.WeekEnd_Count_Edit=response.WeekEnd_Count_Edit;
          ownerPartial.Booking_ID = response.Booking_ID;
          ownerPartial. BookingStatus="Accepted";
          ownerPartial.PartialCancellation_Status=response.PartialCancellation_Status;
          ownerPartial.Total_Edit_Loa = response.Total_Edit_Loa;
          ownerPartial.save(function(err,saved){
           if(err){
             return;
           }
          
          });
           return
        }
    }); 
       }
       else
       {
            return
       }
}         
})

}

//do approve cancellation end


const IsLOAIncluded = (req,res) =>{console.log("ENTERRLOASS");
console.log(req.body);

    return new Promise(async(resolve,reject)=>{

        let dataValidation = await validateIsLOAInclued(req.body);
            
        if (dataValidation.error) {
            let message = dataValidation.error.details[0].message.replace(/"/g, "");
           return reject({ status: false, message });
       }

       let {bookingId,incomingStartDate,incomingEndDate} = req.body

        const originalBooking = await Schedule.findOne({_id:bookingId,IsActive:true}).catch((error)=>{
            console.log(error)
            return reject({status:false,message:'Something went wrong try again.'})
        })

        if(!originalBooking)  return reject({status:false,message:'Permission Denied'});

        let originalTotalDays = moment(new Date(originalBooking.end)).diff(moment(new Date(originalBooking.start)),"days") + 1;
        //number of days between new incoming start and end date
        let incomingTotalDays = moment(new Date(incomingEndDate)).diff(moment(new Date(incomingStartDate)),"days") + 1

        let noOfcancellation = originalTotalDays - incomingTotalDays;

        let  numberOfPartialCancellation = await manageBoat.findOne({Boat_Id:originalBooking.Boat_Id,Owner_Id:originalBooking.User_Id,IsActive:true}).catch((error)=>{ 
            console.log(error)
            return reject({status:false,message:'Something went wrong try again.'})
        })

        let noOfLOA = noOfcancellation - numberOfPartialCancellation.No_PartialCancellation

        //if LOA

        if(noOfLOA > 0){

            let obj = Object();
            obj.start = moment(new Date(incomingStartDate));
            obj.end = moment(new Date(incomingEndDate));

            let datas =  getDaysInMonth_Sheduler(obj);

            let arr=[];
             
            datas.forEach(function(item) {
                Object.keys(item).forEach(function(key) {
                    arr.push(item[key]);
                });
              });

        let index=arr.length - 1;
        let Loa_Length = noOfLOA;
        let WeekDay_Count_edit = 0;
        let  WeekEnd_Count_edit = 0;

        while(Loa_Length>0){

    let day = arr[index];

    if(day=='Mo' || day=='Tu' || day=='We' || day=='Th' || day=='Fr'){
        WeekDay_Count_edit=WeekDay_Count_edit+1;
      
    }
    else
    {
        WeekEnd_Count_edit= WeekEnd_Count_edit+1;

    }

    Loa_Length--;
    index--;
}
        let LOAInWeekday = WeekDay_Count_edit;
        let LOAInWeekend = WeekEnd_Count_edit;

        return resolve({status:true,message:"LOA is included.",IsLOAIncluded:true,LOAInWeekday,LOAInWeekend})

        }


    return resolve({status:true,message:"LOA is not included.",IsLOAIncluded:false})

    }).then((response)=>{
        return res.json(response)
     }).catch((error)=>{
        return res.json(error)
     })
}


const checkPrelaunchLaunchConsecutiveDays = (boatLaunchDate,incomingBookingStart,incomingBookingEnd,Boat_id,Owner_id,isEditSchedule = false,editSchedulerIdOne,editSchedulerIdTwo)=>{

    console.log("'Entered in checkPrelaunchLaunchConsecutiveDays block'");
  
    return new Promise(async(resolve,reject)=>{

    incomingBookingStart = new Date(incomingBookingStart)
    incomingBookingEnd = new Date(incomingBookingEnd)

    console.log(incomingBookingStart,"incomingBookingStart")
    console.log(incomingBookingEnd,"incomingBookingEnd")

    

    let allDaysBetweenCanceldates = getDaysBetweenDates(incomingBookingStart,incomingBookingEnd);

   

        if(allDaysBetweenCanceldates.length!=0){

            let queryToCheckCancelDatesBooking = []  
    
            allDaysBetweenCanceldates.map((date)=> queryToCheckCancelDatesBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}));
        
            const canceldStatus = await Schedule.findOne({'Cancelled_Status':1,User_Id:Owner_id,Boat_Id:Boat_id,$or:queryToCheckCancelDatesBooking})
        
            if(canceldStatus){
                return reject({
                   status:true,
                   message: 'You cannot book theses dates. A booking was cancelled for these dates within the last 24 hours. Please wait until this window has passed to book these dates again.'
                })
            }
        

        }

  

    const launchDate =  new Date(boatLaunchDate).getTime();
    let isBookingBeforeLaunchDate = false;
    
    
    //get all dates between start and end date
    const allIncomingBookingDays =  getDaysBetweenDates(incomingBookingStart,incomingBookingEnd).map((date)=> new Date(date));
    
    //check if any of incoming booking is included before launch date 
      allIncomingBookingDays.map((date)=>{
          if(date.getTime() < launchDate){
              isBookingBeforeLaunchDate = true
          }
      })

      if(isBookingBeforeLaunchDate){

        console.log("incomingBookingStart:"+incomingBookingStart+"@"+"incomingBookingEnd:"+incomingBookingEnd);

        //check if booking start date and end date month is same if it is not change that booking to two different booking from two month 
        // in order to check consecutive days it will not be saved as two booking 

        const bookedDaysStartAndEndDates = []

        const bookingStartDateMonth = moment(new Date(incomingBookingStart)).month();
        const bookingEndDateMonth =  moment(new Date(incomingBookingEnd)).month();

        console.log(bookingStartDateMonth,"bookingStartDateMonth")
        console.log(bookingEndDateMonth,"bookingEndDateMonth")

        if(bookingStartDateMonth === bookingEndDateMonth){
            bookedDaysStartAndEndDates.push({
                startDate:incomingBookingStart,
                endDate:incomingBookingEnd,
                bookedMonth:moment(incomingBookingStart).month()
            })
        }else{

            console.log("booking start and end month does not match")

            //map through all incoming booking and filter booking based on month

            let boookingOnfirstMonth = [];
            let bookingOnSecondMonth = [];

            allIncomingBookingDays.map((date)=>{
                if(bookingStartDateMonth === moment(date).month()){
                    boookingOnfirstMonth.push(date)
                }else{
                    bookingOnSecondMonth.push(date)
                }
            })

            bookedDaysStartAndEndDates.push(
                {
                    startDate:boookingOnfirstMonth[0],
                    endDate:boookingOnfirstMonth[boookingOnfirstMonth.length - 1],
                    bookedMonth:moment(boookingOnfirstMonth[0]).month()
                },
                {
                    startDate:bookingOnSecondMonth[0],
                    endDate:bookingOnSecondMonth[bookingOnSecondMonth.length - 1],
                    bookedMonth:moment(bookingOnSecondMonth[0]).month()
                }
            )

        }

        console.log(bookedDaysStartAndEndDates,"bookedDaysStartAndEndDates")

        for(const {startDate,endDate,bookedMonth} of bookedDaysStartAndEndDates){
                 //get total booking on incoming boat by incoming owner in that month

        const startOfMonth = new Date(moment(new Date(startDate)).startOf('month').utc(true));
        const endOfMonth = new Date(moment(new Date(endDate)).endOf('month').utc(true));

        let totalDaysBookedCount = moment(new Date(endDate)).diff(moment(new Date(startDate)),"days") + 1;
        let incomingBookingWeekdaysAndWeekendsCount = getNumberOfWeekDaysAndWeekendsFromDates(getDaysBetweenDates(startDate,endDate))
        let totaWeekDaysBooked = incomingBookingWeekdaysAndWeekendsCount.numberOfWeekDays;
        let totalWeekendBooked = incomingBookingWeekdaysAndWeekendsCount.numberOfWeekEnds;

        //query to get all bboking in the month

        let queryToGetBooking = []  
       
        let allDaysBetweenMonthStartAndEndDate = getDaysBetweenDates(startOfMonth,endOfMonth).map((date)=> new Date(date));

        allDaysBetweenMonthStartAndEndDate.map((date)=> queryToGetBooking.push({$and:[{start_NoTime:{$lte:new Date(date)}},{end_NoTime:{$gte:new Date(date)}}]}))
 
       
        //all normal booking

     //const allNormalBookings = await Schedule.find({...(isEditSchedule && {$and:[{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdOne)}},{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdTwo)}}]}),Boat_Id:Boat_id,User_Id:Owner_id,IsActive:true,$or:queryToGetBooking}).catch((error)=> console.log(error))
     const allNormalBookings = await Schedule.find({...(isEditSchedule && {$and:[{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdOne)}},{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdTwo)}}]}),Boat_Id:Boat_id,User_Id:Owner_id,delStatus:0,$or:queryToGetBooking}).catch((error)=> console.log(error));
    
     console.log(allNormalBookings.length,"allNormalBookings.length")

     if(allNormalBookings.length){
        allNormalBookings.map((normalBooking)=>{
            
            //check if any of the booking does not included in the same month as booked month then remove it from count
             let filteredBookingDaysBasedOnBookedMonth = []
              getDaysBetweenDates(normalBooking.start_NoTime,normalBooking.end_NoTime).map((date)=>{

                console.log(bookedMonth,"bookedMonth")
                console.log(moment(new Date(date)).month(),"moment(new Date(date)).month()")

                  if(moment(new Date(date)).month() === bookedMonth) {
                    filteredBookingDaysBasedOnBookedMonth.push(new Date(date))
                  }
              });

              console.log(filteredBookingDaysBasedOnBookedMonth,"filteredBookingDaysBasedOnBookedMonth")


              normalBooking.start_NoTime = filteredBookingDaysBasedOnBookedMonth[0];
              normalBooking.end_NoTime = filteredBookingDaysBasedOnBookedMonth[filteredBookingDaysBasedOnBookedMonth.length - 1]

              console.log(normalBooking.start_NoTime,"normalBooking.start_NoTime")
              console.log(normalBooking.end_NoTime,"normalBooking.end_NoTime")

            totalDaysBookedCount += moment(new Date(normalBooking.end_NoTime)).diff(moment(new Date(normalBooking.start_NoTime)),"days") + 1
            let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(getDaysBetweenDates(normalBooking.start_NoTime,normalBooking.end_NoTime))
            totaWeekDaysBooked += numberOfWeekDays;
            totalWeekendBooked += numberOfWeekEnds;
        })
     }

     //all standby booking

     const allStandByBookings = await AddStandByBooking.find({...(isEditSchedule && {$and:[{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdOne)}},{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdTwo)}}]}),Boat_Id:Boat_id,User_Id:Owner_id,IsActive:true,showThisBookingInCalendar:true,$or:queryToGetBooking}).catch((error)=> console.log(error))
     //const allStandByBookings = await AddStandByBooking.find({...(isEditSchedule && {$and:[{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdOne)}},{_id:{$ne:mongoose.Types.ObjectId(editSchedulerIdTwo)}}]}),Boat_Id:Boat_id,User_Id:Owner_id,delStatus:0,showThisBookingInCalendar:true,$or:queryToGetBooking}).catch((error)=> console.log(error))

     if(allStandByBookings.length){
        allStandByBookings.map((normalBooking)=>{
         
             //check if any of the booking does not included in the same month as booked month then remove it from count
             let filteredBookingDaysBasedOnBookedMonth = []
              getDaysBetweenDates(normalBooking.start_NoTime,normalBooking.end_NoTime).map((date)=>{
                  if(moment(new Date(date)).month() === bookedMonth) filteredBookingDaysBasedOnBookedMonth.push(new Date(date))
              });

              normalBooking.start_NoTime = filteredBookingDaysBasedOnBookedMonth[0];
              normalBooking.end_NoTime = filteredBookingDaysBasedOnBookedMonth[filteredBookingDaysBasedOnBookedMonth.length - 1]

            totalDaysBookedCount += moment(new Date(normalBooking.end_NoTime)).diff(moment(new Date(normalBooking.start_NoTime)),"days") + 1
            let {numberOfWeekDays,numberOfWeekEnds} = getNumberOfWeekDaysAndWeekendsFromDates(getDaysBetweenDates(normalBooking.start_NoTime,normalBooking.end_NoTime))
            totaWeekDaysBooked += numberOfWeekDays;
            totalWeekendBooked += numberOfWeekEnds;
        })
     }

     


     console.log(totalDaysBookedCount,"totalDaysBookedCount")
     console.log(totaWeekDaysBooked,"totaWeekDaysBooked")
     console.log(totalWeekendBooked,"totalWeekendBooked")

     let beforeLaunchLimit = await PreLaunchAndLaunchBookingDays.findOne({Boat_Id:Boat_id,IsActive:true}).catch((error)=> console.log(error));

     if(!beforeLaunchLimit){
         return reject({
             status:false,
             message:"Set coneseccutive days before making any booking ."
         })
     }

     if((totalDaysBookedCount > beforeLaunchLimit.Booking_Days || totaWeekDaysBooked > beforeLaunchLimit.No_Of_WeekDays || totalWeekendBooked > beforeLaunchLimit.No_Of_WeekEndDays)){
        return reject({
            status:false,
            message:"Allowed Booking Days Exceeds max count Between Launch Date And Pre-Launch Date."
        })
     }
        }

        
    }
    return resolve({status:true,message:"Incoming booking does not exceed consecutive day.",isBookingBeforeLaunchDate})
    })
}




module.exports = {
    AddSchedule,
    EditSchedule,
    DeleteSchedule,
    ViewAllSchedule,
    GetBoatNames,
    ViewCancelledBooking,
    ViewCancelledBookingNew,
    ApproveCancellationNew,
    ViewBookingDetailsWithBoatAndOwner,
    AddBookingDays_Owner,
    GetAllPendingDaysOfOwner,
    StandByBooking_AcceptReject,
    ViewBookingDetailsFilterByDates,
    ApproveCancellation,
    AddSpecialDay,
    ViewCancelledBookingById,
    ViewBookingById,
    DeleteScheduleForOwner,
    AddScheduleStandByBooking,
    ViewAllScheduleActiveAndNonActive,
    GetAllMaintenanceSchedule,
    GetAllCleaningScheduleReport,
    checkIfIncludedInSeason,
    IsLOAIncluded,
    checkPrelaunchLaunchConsecutiveDays
   
}


